{"meta":{"title":"ConorLuo 博客","subtitle":"胆小认生，不易相处","description":"北京化工大学10级，从事工程建设行业开发，擅长.Net, Python。此为博客一枚。","author":"ConorLuo","url":"https://buctllx.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-12-20T05:54:39.000Z","updated":"2021-12-20T06:01:52.896Z","comments":false,"path":"tags/index.html","permalink":"https://buctllx.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-12-20T05:59:49.000Z","updated":"2021-12-20T06:01:59.580Z","comments":false,"path":"categories/index.html","permalink":"https://buctllx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"计算机网络基础","slug":"计算机网络基础","date":"2022-03-25T10:21:59.000Z","updated":"2022-03-25T11:57:38.717Z","comments":true,"path":"2022/03/25/计算机网络基础/","link":"","permalink":"https://buctllx.github.io/2022/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","excerpt":"本文以科普的性质说明计算机网络是一个什么样的东西，顺便回顾一下自己大学计算机网络的基本知识","text":"本文以科普的性质说明计算机网络是一个什么样的东西，顺便回顾一下自己大学计算机网络的基本知识 自从互联网诞生以来，现在基本上绝大多数的程序都是网络程序或者跟网络有关，很少有单机版的程序了。 计算机网络本质上就是：多个计算机（网络设置）连载一起，像一张网一样，彼此可以直接或者间接的相互通信；世界上所有的电脑（网络设备）同通过这张网联系在一起，就是计算机网络，通俗讲就是互联网。 网络编程，就是在计算机网络（互联网）中实现两台或者多台计算机之间的数据通信。 网络编程按照编程语言的不同又可以划分成不同是编程实现方式，但是他们用到的原理和协议都是一致的。 1. 网络基础知识 主要介绍，IP 地址，域名，网络模型等基本知识 1.1 IP 地址 在互联网中，一个 IP 地址用于唯一标识一个网络接口（Network Interface）。 一台联入互联网的计算机肯定有一个 IP 地址，但也可能有多个 IP 地址。 IP 地址分为 IPv4 和 IPv6 两种。 IPv4 采用32位地址，类似 192.168.10.1， 而 IPv6 采用128位地址，类似 2001:0DA8:100A:0000:0000:1020:F2F3:1428。 \\[ \\begin{flalign} &amp; IPv4 \\,\\, 地址总共有\\,\\, 2^{32}，而\\,\\,IPv6 \\,\\, 地址则总共有\\,\\, 2^{128} 个（大约340万亿亿亿亿）&amp; \\end{flalign} \\] IPv4 的地址目前已耗尽，而 IPv6 的地址是根本用不完的。 IP 地址又分为公网 IP 地址和内网 IP 地址。公网 IP 地址可以直接被访问，内网 IP 地址只能在内网访问。内网 IP 地址类似于： 192.168.x.x 10.x.x.x 有一个特殊的 IP 地址，称之为本机地址，它总是127.0.0.1。 IPv4 地址实际上是一个32位整数。例如： 1231707762444 = 0x65ca630c = 65 ca 63 0c = 101.202.99.12 如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址127.0.0.1，还有一个 IP 地址，例如101.202.99.12，可以通过这个 IP 地址接入网络。 如果一台计算机有两块网卡，那么除了本机地址，它可以有两个 IP 地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个 IP 地址，分别接入不同的网络，让网络之间连接起来。 如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的 IP 地址前段是相同的，也就是网络号是相同的。网络号是 IP 地址通过子网掩码过滤后得到的。例如： 某台计算机的 IP 是101.202.99.2，子网掩码是255.255.255.0，那么计算该计算机的网络号是： 123IP = 101.202.99.2Mask = 255.255.255.0Network = IP &amp; Mask = 101.202.99.0 每台计算机都需要正确配置 IP 地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。 网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。 所以，一台计算机的一个网卡会有3个关键配置： IP 地址，例如：10.80.2.24 子网掩码，例如：255.255.255.0 网关的 IP 地址，例如：10.80.2.254 image-20220325191123462 1.2 域名 因为直接记忆 IP 地址非常困难，所以我们通常使用域名访问某个特定的服务。 域名解析服务器 DNS 负责把域名翻译成对应的 IP，客户端再根据 IP 地址访问服务器。 用nslookup可以查看域名对应的 IP 地址： 1234567891011121314$ nslookup buctllx.github.ioServer: bogonAddress: 10.80.253.253Non-authoritative answer:Name: buctllx.github.ioAddresses: 2606:50c0:8002::153 2606:50c0:8001::153 2606:50c0:8000::153 2606:50c0:8003::153 185.199.110.153 185.199.109.153 185.199.111.153 185.199.108.153 有一个特殊的本机域名localhost，它对应的 IP 地址总是本机地址127.0.0.1。 1.3 网络模型 由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是： 应用层，提供应用程序之间的通信； 表示层：处理数据格式，加解密等等； 会话层：负责建立和维护会话； 传输层：负责提供端到端的可靠传输； 网络层：负责根据目标地址选择路由来传输数据； 链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。 互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型： OSI TCP/IP 应用层 应用层 表示层 会话层 传输层 传输层 网络层 IP层 链路层 网络接口层 物理层 2. 常用网络协议 虽然大家现在对互联网很熟悉，但是计算机网络的出现比互联网要早很多。 计算机为了联网，就必须规定通信协议，早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容，这就好比一群人有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同的语言之间就不行了。 为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议簇（Internet Protocol Suite）就是通用协议标准。Internet是由inter和net两个单词组合起来的，原意就是连接“网络”的网络，有了Internet，任何私有网络，只要支持这个协议，就可以联入互联网。 UDP 协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为 UDP 协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。 选择 UDP 协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择 UDP 协议。 2.1 TCP/IP 协议 因为互联网协议包含了上百种协议标准，但是最重要的两个协议是 TCP 和 IP 协议，所以，大家把互联网的协议简称 TCP/IP 协议。 网络通信的时候，双方必须知道对方的标识，好比发邮件必须知道对方的邮件地址。 互联网上每个计算机的唯一标识就是 IP 地址。如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个 IP 地址，所以，IP地址对应的实际上是计算机的网络接口，通常是网卡。 IP 协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过 IP 包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个 IP 包转发出去。IP 包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。 IP 协议是一个分组交换，它不保证可靠传输。 而 TCP 协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。 TCP 协议是建立在 IP 协议之上的，简单地说，IP 协议只负责发数据包，不保证顺序和正确性，而 TCP 协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。 TCP协议会通过握手建立连接，然后，对每个 IP 包编号，确保对方按顺序收到，如果包丢掉了，就自动重发；传输完后还需要断开连接。 TCP 协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。 TCP 协议也是应用最广泛的协议，许多高级协议都是建立在 TCP 协议之上的，例如 HTTP、SMTP 等。 一个 TCP 报文除了包含要传输的数据外，还包含源 IP 地址和目标 IP 地址，源端口和目标端口。 端口有什么作用？在两台计算机通信时，只发 IP 地址是不够的，因为同一台计算机上跑着多个网络程序。一个 TCP 报文来了之后，到底是交给浏览器还是 QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的 IP地址和各自的端口号。 一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。 2.2 UDP 协议 TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对 TCP，UDP 则是面向无连接的协议。 使用 UDP 协议时，不需要建立连接，只需要知道对方的 IP 地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。 缺点：传输数据不可靠 优点：速度快，对于不要求可靠到达的数据，就可以使用 UDP 协议。 此外，服务器绑定 UDP 端口和 TCP 端口互不冲突，也就是说，UDP 的 80 端口与 TCP 的 80 端口可以各自绑定。 2.3 HTTP 协议 在 Web 应用中，服务器把网页传给浏览器，实际上就是把网页的 HTML 代码发送给浏览器，让浏览器显示出来。 而浏览器和服务器之间的传输协议是 HTTP，所以： HTML 是一种用来定义网页的文本，会 HTML，就可以编写网页； HTTP 是在网络上传输 HTML 的协议，用于浏览器和服务器的通信。 在举例子之前，我们需要安装 Google 的 Chrome 浏览器。或者 Microsoft 的 Edge 浏览器。本质上都是基于 Chromium 内核的浏览器 为什么要使用 Chromium 内核的浏览器而不是 IE 呢？因为 IE 实在是太慢了，并且，IE 对于开发和调试 Web 应用程序完全是一点用也没有。 我们需要在浏览器很方便地调试我们的 Web 应用，而 Chromium 提供了一套完整地调试工具，非常适合 Web 开发。 安装好 Chromium 内核的浏览器后，打开浏览器，按 F12，就可以显示开发者工具： image-20220325193907204 Elements显示网页的结构，Network显示浏览器和服务器的通信。我们点Network，确保第一个小红灯亮着，Chrome就会记录所有浏览器和服务器之间的通信： 当我们在地址栏输入www.sina.com.cn时，浏览器将显示新浪的首页。在这个过程中，浏览器都干了哪些事情呢？通过Network的记录，我们就可以知道。在Network中，定位到第一条记录，点击，右侧将显示Request Headers，点击右侧的view source，我们就可以看到浏览器发给新浪服务器的请求： 最主要的头两行分析如下，第一行： 1GET / HTTP/1.1 GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。目前HTTP协议的版本就是1.1，但是大部分服务器也支持1.0版本，主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接，以加快传输速度。 从第二行开始，每一行都类似于Xxx: abcdefg： 1Host: www.sina.com.cn 表示请求的域名是www.sina.com.cn。如果一台服务器有多个网站，服务器就需要通过Host来区分浏览器请求的是哪个网站。 继续往下找到Response Headers，点击view source，显示服务器返回的原始响应数据： HTTP响应分为Header和Body两部分（Body是可选项），我们在Network中看到的Header最重要的几行如下： 1200 OK 200表示一个成功的响应，后面的OK是说明。失败的响应有404 Not Found：网页不存在，500 Internal Server Error：服务器内部出错，等等。 1Content-Type: text/html Content-Type指示响应的内容，这里是text/html表示HTML网页。请注意，浏览器就是依靠Content-Type来判断响应的内容是网页还是图片，是视频还是音乐。浏览器并不靠URL来判断响应的内容，所以，即使URL是http://example.com/abc.jpg，它也不一定就是图片。 HTTP响应的Body就是HTML源码，我们在菜单栏选择“视图”，“开发者”，“查看网页源码”就可以在浏览器中直接查看HTML源码： 当浏览器读取到新浪首页的HTML源码后，它会解析HTML，显示页面，然后，根据HTML里面的各种链接，再发送HTTP请求给新浪服务器，拿到相应的图片、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出一个完整的页面。所以我们在Network下面能看到很多额外的HTTP请求。 2.3.1 HTTP 请求 跟踪了新浪的首页，我们来总结一下HTTP请求的流程： 步骤1：浏览器首先向服务器发送HTTP请求，请求包括： 方法：GET还是POST，GET仅请求资源，POST会附带用户数据； 路径：/full/url/path； 域名：由Host头指定：Host: www.sina.com.cn 以及其他相关的Header； 如果是POST，那么请求还包括一个Body，包含用户数据。 步骤2：服务器向浏览器返回HTTP响应，响应包括： 响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误； 响应类型：由Content-Type指定，例如：Content-Type: text/html;charset=utf-8表示响应类型是HTML文本，并且编码是UTF-8，Content-Type: image/jpeg表示响应类型是JPEG格式的图片； 以及其他相关的Header； 通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。 步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。 Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP响应中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。 HTTP协议同时具备极强的扩展性，虽然浏览器请求的是http://www.sina.com.cn/的首页，但是新浪在HTML中可以链入其他服务器的资源，比如&lt;img src=\"http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png\"&gt;，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称“三达不溜”（WWW）。 2.3.2 HTTP 格式 每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。 HTTP协议是一种文本协议，所以，它的格式也非常简单。HTTP GET请求的格式： 1234GET /path HTTP/1.1Header1: Value1Header2: Value2Header3: Value3 每个Header一行一个，换行符是\\r\\n。 HTTP POST请求的格式： 123456POST /path HTTP/1.1Header1: Value1Header2: Value2Header3: Value3body data goes here... 当遇到连续两个\\r\\n时，Header部分结束，后面的数据全部是Body。 HTTP响应的格式： 123456200 OKHeader1: Value1Header2: Value2Header3: Value3body data goes here... HTTP响应如果包含body，也是通过\\r\\n\\r\\n来分隔的。请再次注意，Body的数据类型由Content-Type头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。 当存在Content-Encoding时，Body数据是被压缩的，最常见的压缩方式是gzip，所以，看到Content-Encoding: gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。 要详细了解HTTP协议，推荐“HTTP: The Definitive Guide”一书，非常不错，有中文译本： HTTP权威指南 参考文档： 网络编程基础 - 廖雪峰的官方网站 (liaoxuefeng.com) HTTP协议简介 - 廖雪峰的官方网站 (liaoxuefeng.com)","categories":[{"name":"network","slug":"network","permalink":"https://buctllx.github.io/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"https://buctllx.github.io/tags/network/"}]},{"title":"Nginx 反向代理 FileBrowser","slug":"Nginx-反向代理-FileBrowser","date":"2022-03-23T10:47:42.000Z","updated":"2022-03-25T11:15:50.177Z","comments":true,"path":"2022/03/23/Nginx-反向代理-FileBrowser/","link":"","permalink":"https://buctllx.github.io/2022/03/23/Nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-FileBrowser/","excerpt":"本文主要说明如果使用 Nginx 方向代理已经启动的 FileBrowser 服务。","text":"本文主要说明如果使用 Nginx 方向代理已经启动的 FileBrowser 服务。 1. 准备工作 开始本文的主要内容前，默认已经做好了以下准备工作 使用 linux 系统，比如 centos； 已安装并启动 nginx 服务 已安装并启动 filebrowser 服务 2. 有关 FileBrowser 的配置 如果不知道已经启动的 filebrowser 服务的相关配置，可以通过以下命令查看 123# 1. 查看 filebrowser 服务的进程 (可以看到启动命令的相关参数，比如说配置文件，数据库文件等)ps -ef |grep filebrowserpstree -ap |grep filebrowser image-20220323190406153 123456789101112# 2. 导出 filebrowser 的配置信息cd /etc/filebrowser # 首先进入包含 filebrowser 可执行文件的目录filebrowser config cat # 临时查看filebrowser config export config.json # 导出 filebrowser 配置信息到 config.json 文件# 如果存在多个 db 可以通过 -d 参数导出指定数据库中存储的配置信息(其他命令也是如此，后面不在重复说明举例)filebrowser -d /etc/filebrowser/filebrowser.db config export config.json# 可能用到的其他命令filebrowser users update admin -p admin # 更新 admin 用户的密码为 adminfilebrowser config set --port 18080 # 重新设置端口信息 以下 json 信息是我用到的配置 123456789101112131415&#123; &quot;port&quot;: 18080, &quot;root&quot;:&quot;/data/file&quot;, &quot;database&quot;:&quot;/etc/filebrowser/filebrowser.db&quot;, &quot;log&quot;:&quot;/etc/filebrowser/log.log&quot;, &quot;plugin&quot;: &quot;&quot;, &quot;baseURL&quot;: &quot;/files&quot;, &quot;allowCommands&quot;: true, &quot;allowEdit&quot;: true, &quot;allowNew&quot;: true, &quot;commands&quot;: [ &quot;ls&quot;, &quot;df&quot; ]&#125; 需要注意的问题： baseURL 配置项的值在后面 nginx 的配置中要使用到，一定要记录下来；如果没有设置，默认值是 files， 强烈建议设置一下； 使用 vi 或者 vim 写 json 配置文件的时候一定要注意，缩进符号是 空格，而且不能和 tab 混合用；尤其是从网页上面复制 json 文本的时候一定要确保是空格（有些网页上的缩进是 tab，但是默认空白看不到） 如果在 filebrowser 启动后通过 ui 设置了一些操作，或者添加了一些用户，那么通过上面的命名可能获取不到最新的配置信息，或者出现 timeout 的问题，这时候需要关闭 filebrowser 服务，然后通过 -d 参数执行 db 就可以了； 3. 在 Nginx 中配置 FileBrowser 服务 核心配置如下： 12345678910111213server &#123; listen 80; server_name ai.cbim.com 10.80.253.133; access_log /var/logs/nginx/filebrowser.access.log; # file browser url location ^~ /files/ &#123; proxy_pass http://127.0.0.1:18080/; proxy_set_header Host $proxy_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 新增或者修改完 nginx 的配置文件后，可以使用下面的命令测试 / 重新载入配置 12345# 测试 配置文件的语法是否正确nginx -t# 重新载入修改后的 配置文件nginx -s reload 最后就可以通过设定的域名或者 IP 访问 filebrowser 了 image-20220323195000831 需要注意的问题： server_name 不要和 nginx/conf.d 中其他的配置文件中的 server_name 重复，否则可能被忽略； location 后面的匹配项，一定要和 前面 filebrowser 配置文件中的 baseURL 配置项保持一致，否则无法代理成功； location 的具体匹配规则视情况而定，我这里通过 ^~ 匹配以 files 开头的所有 api；^~ 如果删除，而又没有其他 location 匹配规则，同样会导致代理失败，无法访问 filebrowser 最后访问的时候，如果是局域网域名，访问前最好关掉 vpn 或者其他一类的代理软件，否则也可能会访问失败； 4. 相关参考资料： nginx documentation filebrowser/filebrowser: 📂 Web File Browser (github.com) Welcome - File Browser file browser介绍 - shanyu20 - 博客园 (cnblogs.com) timeout on commands that connect to a locked database · Issue #627 · filebrowser/filebrowser (github.com) Usable configuration for executing command behind NGINX. · Issue #549 · filebrowser/filebrowser (github.com)","categories":[{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Nginx","slug":"工具/Nginx","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://buctllx.github.io/tags/Nginx/"},{"name":"FileBrowsern","slug":"FileBrowsern","permalink":"https://buctllx.github.io/tags/FileBrowsern/"}]},{"title":"Microsoft.Toolkit.Mvvm 使用记录","slug":"Microsoft-Toolkit-Mvvm-使用记录","date":"2022-03-16T02:22:18.000Z","updated":"2022-03-16T03:33:24.722Z","comments":true,"path":"2022/03/16/Microsoft-Toolkit-Mvvm-使用记录/","link":"","permalink":"https://buctllx.github.io/2022/03/16/Microsoft-Toolkit-Mvvm-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"1. Microsoft.Toolkit.Mvvm 介绍 模型-视图-视图模型 (MVVM) 是用于解耦 UI 代码和非 UI 代码的 UI 体系结构设计模式。 借助 MVVM，可以在 XAML 中以声明方式定义 UI，并使用数据绑定标记将 UI 链接到包含数据和命令的其他层。 MVVM 最早是 Microsoft 提出来的，但是官方一直没有提供框架；很多人会说 Prism 框架，但是 Prism 已经出走了，而且比较臃肿；至于 MVVMLight 也很久没有更新了，直到 2020 年 Windows Community Toolkit 开源了一套 MVVM 框架 Microsoft.Toolkit.Mvvm。","text":"1. Microsoft.Toolkit.Mvvm 介绍 模型-视图-视图模型 (MVVM) 是用于解耦 UI 代码和非 UI 代码的 UI 体系结构设计模式。 借助 MVVM，可以在 XAML 中以声明方式定义 UI，并使用数据绑定标记将 UI 链接到包含数据和命令的其他层。 MVVM 最早是 Microsoft 提出来的，但是官方一直没有提供框架；很多人会说 Prism 框架，但是 Prism 已经出走了，而且比较臃肿；至于 MVVMLight 也很久没有更新了，直到 2020 年 Windows Community Toolkit 开源了一套 MVVM 框架 Microsoft.Toolkit.Mvvm。 Windows Community Toolkit 除了提供开源框架，也贴心的在文档中提供了，基本的使用案例，以及从其他 MVVM 框架迁移到 Microsoft.Toolkit.Mvvm 框架的说明文档。 官方文档：Introduction to the MVVM Toolkit - Windows Community Toolkit | Microsoft Docs [WPF] 使用 MVVM Toolkit 构建 MVVM 程序 - dino.c - 博客园 (cnblogs.com) MVVM Toolkit 延续了 MVVMLight 的风格，是一个轻量级的组件，而且它基于 .NET Standard 2.0，可用于UWP, WinForms, WPF, Xamarin, Uno 等多个平台。相比它的前身 MVVMLight，它有以下特点： 更高：版本号更高，一出手就是 7.0。 更快：速度更快，MVVM Toolkit 从一开始就以高性能为实现目标。 更强：后台更强，MVVM Toolkit 的全称是 'Microsoft.Toolkit.Mvvm'，根正苗红。 2. 各个组件说明 前面说到 MVVM Toolkit 延续了 MVVMLight 的风格，因此他们大部分的组件都是相同的 2.1 ObservableObject ObservableObject 实现了 INotifyPropertyChanged 和INotifyPropertyChanging，并触发 PropertyChanged 和 PropertyChanging 事件。 12345678910public class User : ObservableObject&#123; private string name; public string Name &#123; get =&gt; name; set =&gt; SetProperty(ref name, value); &#125;&#125; 在这段示例代码中，如果 name 和 value 的值不同，首先触发 PropertyChanging 事件，然后触发 PropertyChanged。 2.2 RelayCommand RelayCommand 和 RelayCommand&lt;T&gt; 实现了 ICommand 接口，INotifyPropertyChanged 和 ICommand 是 MVVM 模式的基础。下面的代码使用 ObservableObject 和 RelayCommand 展示一个基本的 ViewModel： 12345678910111213141516171819public class MyViewModel : ObservableObject&#123; public MyViewModel() &#123; IncrementCounterCommand = new RelayCommand(IncrementCounter); &#125; private int counter; public int Counter &#123; get =&gt; counter; private set =&gt; SetProperty(ref counter, value); &#125; public ICommand IncrementCounterCommand &#123; get; &#125; private void IncrementCounter() =&gt; Counter++;&#125; 1234567891011121314&lt;Page x:Class=&quot;MyApp.Views.MyPage&quot; xmlns:viewModels=&quot;using:MyApp.ViewModels&quot;&gt; &lt;Page.DataContext&gt; &lt;viewModels:MyViewModel x:Name=&quot;ViewModel&quot;/&gt; &lt;/Page.DataContext&gt; &lt;StackPanel Spacing=&quot;8&quot;&gt; &lt;TextBlock Text=&quot;&#123;x:Bind ViewModel.Counter, Mode=OneWay&#125;&quot;/&gt; &lt;Button Content=&quot;Click me!&quot; Command=&quot;&#123;x:Bind ViewModel.IncrementCounterCommand&#125;&quot;/&gt; &lt;/StackPanel&gt;&lt;/Page&gt; 在这段示例里 IncrementCounterCommand 包装了 IncrementCounter 函数提供给 Button 绑定。IncrementCounter 函数更改 Counter 的值并通过 PropertyChanged 事件通知绑定的 TextBlock。 2.3 AsyncRelayCommand AsyncRelayCommand 和 AsyncRelayCommand&lt;T&gt; 也实现了 ICommand，不过它们支持异步操作，提供的 ExecutionTask 和 IsRunning 两个属性对监视任务运行状态十分有用。 例如这个 ViewModel： 12345678910111213public MyViewModel()&#123; DownloadTextCommand = new AsyncRelayCommand(DownloadTextAsync);&#125;public IAsyncRelayCommand DownloadTextCommand &#123; get; &#125;private async Task&lt;string&gt; DownloadTextAsync()&#123; await Task.Delay(3000); // Simulate a web request return &quot;Hello world!&quot;;&#125; 使用相关的 UI 代码： 123456789101112131415161718&lt;Page.Resources&gt; &lt;converters:TaskResultConverter x:Key=&quot;TaskResultConverter&quot;/&gt;&lt;/Page.Resources&gt;&lt;StackPanel Spacing=&quot;8&quot;&gt; &lt;TextBlock&gt; &lt;Run Text=&quot;Task status:&quot;/&gt; &lt;Run Text=&quot;&#123;x:Bind ViewModel.DownloadTextCommand.ExecutionTask.Status, Mode=OneWay&#125;&quot;/&gt; &lt;LineBreak/&gt; &lt;Run Text=&quot;Result:&quot;/&gt; &lt;Run Text=&quot;&#123;x:Bind ViewModel.DownloadTextCommand.ExecutionTask, Converter=&#123;StaticResource TaskResultConverter&#125;, Mode=OneWay&#125;&quot;/&gt; &lt;/TextBlock&gt; &lt;Button Content=&quot;Click me!&quot; Command=&quot;&#123;x:Bind ViewModel.DownloadTextCommand&#125;&quot;/&gt; &lt;muxc:ProgressRing HorizontalAlignment=&quot;Left&quot; IsActive=&quot;&#123;x:Bind ViewModel.DownloadTextCommand.IsRunning, Mode=OneWay&#125;&quot;/&gt;&lt;/StackPanel&gt; 点击 Button 后 DownloadTextAsync 开始运行，在 UI 上 TextBlock 和 ProgressRing 绑定到 ExecutionTask 和 IsRunning 并显示任务运行状态，最后通过 TaskResultConverter 显示任务结果。 2.4 Messenger 对于主要目的是松耦合的 MVVM 框架，提供一个用于消息交换的系统十分有必要。MVVM Toolkit 中用于消息交换的核心是 WeakReferenceMessenger 类。 123456789101112131415161718// Create a messagepublic class LoggedInUserChangedMessage : ValueChangedMessage&lt;User&gt;&#123; public LoggedInUserChangedMessage(User user) : base(user) &#123; &#125;&#125;// Register a message in some moduleWeakReferenceMessenger.Default.Register&lt;LoggedInUserChangedMessage&gt;(this, (r, m) =&gt;&#123; // Handle the message here, with r being the recipient and m being the // input messenger. Using the recipient passed as input makes it so that // the lambda expression doesn&#x27;t capture &quot;this&quot;, improving performance.&#125;);// Send a message from some other moduleWeakReferenceMessenger.Default.Send(new LoggedInUserChangedMessage(user)); 正如这段代码所示，WeakReferenceMessenger 主要通过 Register 和 Send 进行信息交换，它的使用方式类似于 MVVMLight 的 messenger 类。MVVM Toolkit 另外还提供了一个 StrongReferenceMessenger 类，更多使用方法可以参考这篇 文档。Messenger 功能强大且简单易用，但也由于误用会带来风险而引发了一些争议，有必要更详细地理解它的原理和用法以避免它带来的其它风险，这篇文章只是简单地介绍一下它的用法。 2.5 ObservableRecipient ObservableRecipient 继承了 ObservableObject 并支持从 Messenger 接收信息，可通过 IsActive 属性激活或停用。它可以用作 ViewModel 的基类，事实上它的作用基本上相遇于 MVVMLight 中的 ViewModelBase ： 1234567public class MyViewModel : ObservableRecipient, IRecipient&lt;LoggedInUserRequestMessage&gt;&#123; public void Receive(LoggedInUserRequestMessage message) &#123; // Handle the message here &#125;&#125; 2.6 ViewModelLocator 在 MVVMLight 中，很多人使用 ViewModelLocator，然后在 xaml 中 binding View 的 DataContext，但是到了 Microsoft.Toolkit.Mvvm 中，却没有默认提供，这里根据官方的 Ioc 迁移说明，给出一个 WPF 应用程序的 ViewModelLocator 的实现方式。 需要的 Package 12&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;6.0.0&quot; /&gt;&lt;PackageReference Include=&quot;Microsoft.Toolkit.Mvvm&quot; Version=&quot;7.1.2&quot; /&gt; ViewModelLocator.cs 代码文件如下 12345678910111213141516171819202122232425262728293031323334using Microsoft.Extensions.DependencyInjection;using Microsoft.Toolkit.Mvvm.DependencyInjection;using System;internal class ViewModelLocator&#123; public ViewModelLocator() &#123; ConfigureServices(); &#125; /// &lt;summary&gt; /// Configures the services for the application. /// &lt;/summary&gt; private IServiceProvider ConfigureServices() &#123; var services = new ServiceCollection(); // Services // services.AddSingleton&lt;IContactsService, ContactsService&gt;(); // services.AddSingleton&lt;IPhoneService, PhoneService&gt;(); // Viewmodels services.AddTransient&lt;MainViewModel&gt;(); var serviceProvider = services.BuildServiceProvider(); Ioc.Default.ConfigureServices(serviceProvider); return serviceProvider; &#125; public MainViewModel? MainVM &#123; get &#123; return Ioc.Default.GetService&lt;MainViewModel&gt;(); &#125; &#125;&#125; App.xaml 添加以下资源 123&lt;Application.Resources&gt; &lt;local:ViewModelLocator x:Key=&quot;Locator&quot; /&gt;&lt;/Application.Resources&gt; 在 View xaml 中的使用方法 123&lt;Window x:Class=&quot;Test.MainWindow&quot; DataContext=&quot;&#123;Binding Source=&#123;StaticResource Locator&#125;, Path=MainVM&#125;&quot;&lt;/Window&gt; 这样即可实现 MVVMLight 中 Locator 的效果。 3. The 性能 MVVM Toolkit 在开发过程中为了追求卓越的性能做了很多努力，例如提供一个 StrongReferenceMessenger 类，性能如上图所示地有了大幅提升。又例如下面这篇文章所介绍的： MVVM Toolkit Preview 3 &amp; The Journey of an API 有兴趣的话可以通过源码详细了解一下。","categories":[{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"MVVM","slug":"工具/MVVM","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/MVVM/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"https://buctllx.github.io/tags/MVVM/"}]},{"title":"WPF 窗口控件默认键盘焦点设置","slug":"WPF-窗口控件默认键盘焦点设置","date":"2022-03-14T06:10:52.000Z","updated":"2022-03-14T07:15:21.083Z","comments":true,"path":"2022/03/14/WPF-窗口控件默认键盘焦点设置/","link":"","permalink":"https://buctllx.github.io/2022/03/14/WPF-%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E9%BB%98%E8%AE%A4%E9%94%AE%E7%9B%98%E7%84%A6%E7%82%B9%E8%AE%BE%E7%BD%AE/","excerpt":"大家经常能够看到 WPF 窗口加载显示后，用户按 Tab 键，就会有一个控价获得焦点，如果这个控件是 Button，那么表现为：在 Button 文本周围有个虚线框；如果是 TextBox，那么表现为：在 TextBox 内部会有光标在闪烁。那么如何在 View 加载后设置默认显示这个效果，本文将会说明。 image-20220314142837858","text":"大家经常能够看到 WPF 窗口加载显示后，用户按 Tab 键，就会有一个控价获得焦点，如果这个控件是 Button，那么表现为：在 Button 文本周围有个虚线框；如果是 TextBox，那么表现为：在 TextBox 内部会有光标在闪烁。那么如何在 View 加载后设置默认显示这个效果，本文将会说明。 image-20220314142837858 一、关于 焦点 的 基本知识 焦点概述 - WPF .NET Framework | Microsoft Docs 为控件中的焦点设置样式以及 FocusVisualStyle - WPF .NET Framework | Microsoft Docs 两种焦点： 键盘焦点 逻辑焦点 这里有一段话明确说明了虚线框是键盘焦点的由来 Focus visual styles act only when the focus action was initiated by the keyboard. Any mouse action or programmatic focus change disables the mode for focus visual styles. 意思是：虚线框这种焦点效果，只能通过按 Tab 键进行触发 二、实现方案 明白了焦点效果产生的缘由，我们就可以思考如何实现 这里主要介绍如下实现方式； 2.1 模拟按键实现 既然只能通过按 Tab 键触发产生想要的效果，最直接的方法就是： 在 View 加载后，通过编码实现模拟用户按键到达想要的键盘焦点效果； 具体实现方式编码，可以通过 PInvoke SendInput 实现， 也可以使用封装好的第三方包，NuGet Gallery | InputSimulator 1.0.4 缺点： 要提前计算好要按几次才能达到指定的控件； 2.2 重写键盘焦点样式 在第一章节中了解了：想要的样式是通过那种 Style 控制产生的，那么我们就可以重新实现一种新的样式，默认显示我们想要的效果。 确定： 复杂，需要重写想过控件的样式 2.3 辅助方法实现 通过反射的方法，调用 ShowFocusVisual Internal 方法实现。 笔者用的就是这种方法，因为我的需要没有复杂的样式要求，只需要显示默认的键盘焦点样式即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public sealed class KeyboardHelper&#123; private static KeyboardHelper _Instance; private readonly PropertyInfo _AlwaysShowFocusVisual; private readonly MethodInfo _ShowFocusVisual; // Explicit static constructor to tell C# compiler // not to mark type as beforefieldinit static KeyboardHelper() &#123; &#125; private KeyboardHelper() &#123; var type = typeof(KeyboardNavigation); _AlwaysShowFocusVisual = type.GetProperty(&quot;AlwaysShowFocusVisual&quot;, BindingFlags.NonPublic | BindingFlags.Static); _ShowFocusVisual = type.GetMethod(&quot;ShowFocusVisual&quot;, BindingFlags.NonPublic | BindingFlags.Static); &#125; internal static KeyboardHelper Instance =&gt; _Instance ?? (_Instance = new KeyboardHelper()); internal void ShowFocusVisualInternal() &#123; _ShowFocusVisual.Invoke(null, null); &#125; internal bool AlwaysShowFocusVisualInternal &#123; get &#123; return (bool)_AlwaysShowFocusVisual.GetValue(null, null); &#125; set &#123; _AlwaysShowFocusVisual.SetValue(null, value, null); &#125; &#125; public static void Focus(UIElement element) &#123; element?.Dispatcher.BeginInvoke(DispatcherPriority.Background, new Action(() =&gt; &#123; var keybHack = KeyboardHelper.Instance; var oldValue = keybHack.AlwaysShowFocusVisualInternal; keybHack.AlwaysShowFocusVisualInternal = true; try &#123; Keyboard.Focus(element); keybHack.ShowFocusVisualInternal(); &#125; finally &#123; keybHack.AlwaysShowFocusVisualInternal = oldValue; &#125; &#125;)); &#125;&#125; 使用方法: 在构造方法中的 InitializeComponent 方法 或者 Loaded 后添加下方代码即可 1KeyboardHelper.Focus(this.OkBtn); // Button Name 缺点： 需要使用控件 Name； 三、总结 这第二章节中介绍了三种方法，大家可以根据自己的需要，选择合适的方法 笔者采用的是 2.3 ，目前没有发现什么问题； 参考链接： WPF Button to have Keyboard focus (dotted border around) during the startup or activation of window - Stack Overflow wpf - How to make CheckBox focus border appear when calling CheckBox.Focus()? - Stack Overflow","categories":[{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/categories/WPF/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/tags/WPF/"}]},{"title":"Visual Studio *.sln file 编辑 bug 记录","slug":"Visual-Studio-sln-file-编辑-bug-记录","date":"2022-03-03T05:47:03.000Z","updated":"2022-03-03T06:39:52.649Z","comments":true,"path":"2022/03/03/Visual-Studio-sln-file-编辑-bug-记录/","link":"","permalink":"https://buctllx.github.io/2022/03/03/Visual-Studio-sln-file-%E7%BC%96%E8%BE%91-bug-%E8%AE%B0%E5%BD%95/","excerpt":"sln 是 Visual Studio 20xx 自动创建的解决方案文件，里面存放了有关解决方案的设置信息，以及有关解决方案下项目文件的组织、结构、配置信息； 一般情况下，我们都是通过 Visual Studio 的可视化操作 对 sln 文件间接进行编辑修改的，但是有时候为了提高效果，需要手动进行编辑操作； 这里主要记录手动编辑 sln 文件遇到的问题：","text":"sln 是 Visual Studio 20xx 自动创建的解决方案文件，里面存放了有关解决方案的设置信息，以及有关解决方案下项目文件的组织、结构、配置信息； 一般情况下，我们都是通过 Visual Studio 的可视化操作 对 sln 文件间接进行编辑修改的，但是有时候为了提高效果，需要手动进行编辑操作； 这里主要记录手动编辑 sln 文件遇到的问题： 0. 有关 sln 文件的介绍 这里假设读者对 sln 文件有一定了解，因此不在详细说明，主要用来说明遇到的问题 有关 sln 文件可以参考官方文档：解决方案 (。Sln) 文件 - Visual Studio (Windows) | Microsoft Docs 理解 Visual Studio 解决方案文件格式（.sln） - walterlv 1. sln 修改后不起效的 bug 软件环境：visual studio 2022，sublime 3 1.1 问题描述 使用 sublime 打开 sln 文件，然后编辑 GlobalSection(SolutionConfigurationPlatforms) = preSolution 信息，如下图所示： image-20220303141026555 红框里面是新增的内容； 修改后保存，然后再 visual studio 中重新载入，发现：新增的解决方案配置项，并没有出现，如下图所示： image-20220303141324034 注：一开始编辑，全部没有出现，这里为了说明问题，故意显示 出 Release R21 Store，便于后面分析问题 1.2 问题分析 根据 1.1 中的现象发现，已经显示的配置项是 Release R21 Store，对应 sln 文件中的是 31 行，没有显示的是 32~40 行，这其中有什么区别不难发现。 唯一的区别是：31 行使用的 缩进是 tab 键，32~40 行使用的是空格 space； 注释：截图中的 —— 代表 Tab 键，…… 代表 Space 空格键 难道竟然是缩进符号的问题？？？ 通过验证发现：果然是缩进符号导致的 1.3 问题总结 产生问题的原因： 笔者再根据 githu 上一篇技术文档的介绍，进行 sln 文件的编辑修改，文档中建议使用编辑器打开手动修改，而且附加上了修改的内容，于是我便很轻易的点击 copy 按钮，进行复制、粘贴，发现没有任何效果。 浪费了半天的事件才发现是 缩进符号导致的， 而且还是在 Sublime 中选中状态下才能发现的 复制粘贴代码害死人，一定要注意。","categories":[{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/categories/VisualStudio/"}],"tags":[{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/tags/VisualStudio/"}]},{"title":"Visual Studio 代码格式化工具","slug":"Visual-Studio-代码格式化工具","date":"2022-03-01T07:43:28.000Z","updated":"2022-03-16T10:05:41.910Z","comments":true,"path":"2022/03/01/Visual-Studio-代码格式化工具/","link":"","permalink":"https://buctllx.github.io/2022/03/01/Visual-Studio-%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7/","excerpt":"Visual Studio 设置 - &gt; 选项 里面自身包含有部分代码格式化的功能，但是比较弱，面对复杂的项目代码，尤其是团队开发的时候，依然存在一些问题，不能够很好的规范，格式化项目代码；比如说 XAML 文件等。 本篇文章，结合 Visual Studio 的基础设置，同时配合 Visual Studio 扩展相关的代码格式化工具进行项目级别代码格式化规范的统一说明。","text":"Visual Studio 设置 - &gt; 选项 里面自身包含有部分代码格式化的功能，但是比较弱，面对复杂的项目代码，尤其是团队开发的时候，依然存在一些问题，不能够很好的规范，格式化项目代码；比如说 XAML 文件等。 本篇文章，结合 Visual Studio 的基础设置，同时配合 Visual Studio 扩展相关的代码格式化工具进行项目级别代码格式化规范的统一说明。 Visual Studio 代码格式化基础设置 vs 自带的文件格式化设置功能位于：工具 -&gt; 选项 -&gt; 文本编辑器 image-20220303115418833 在这里，既可以按照编程语言设置，也可以在“所有语言”中进行统一设置； 这里的设置都是一些基本的设置，比如说：行号，自动补全，缩进等； 以C#为例，在写代码的过程中一般只有在 补全 {} 的时候才会进行自动格式化，如果实在 {} 内部写代码，比如说缩进不对，没有加空格等，那么在保存的时候就不会自动格式化（除非使用了手动/快捷键格式化或者高级插件） 还有，在进行 XAML 开发的时候，由于其标签语言的特性，属性有时候会比较多，尤其实在团队开发的过程中，每个人都有自己的习惯，有些人喜欢一行写下去不带换行，有些喜欢加换行（换行的时候属性的数量也不同，极端的一个属性就换行，或者三五个属性后再换行），而且相同标签的空间在一起，属性的顺序也可能不一样，这就给代码的可读性增加了困难； 如何解决这些问题，下面将会结合高级工具进行说明； 1. Format Document On Save 扩展插件 主要用户解决，再保存代码的时候进行自动格式化； 保存操作支持 ctrl+s vs ide 中保存按钮 1.1 安装设置 插件链接：Format document on Save - Visual Studio Marketplace Elders/VSE-FormatDocumentOnSave: Visual Studio - Format Document on Save (github.com) 安装后，可以在 工具 -&gt; 选项 -&gt; Format Document On Save 中进行格式化的一些设置，操作； image-20220303120914539 设置项比较简单，也有注释，这里就不在一一说明了； 1.2 项目级使用 上面介绍的使用方法，可以满足一般个人的使用，但是在团队开发的过程中，每个人的设置可能不一样，如何解决这个问题能，这里就要使用到项目级的文件格式化配置 EditConfig。 项目级的文件格式化配置 EditConfig，不是针对某个人的；具有以下特点： 一个项目（sln）一个配置文件； 项目配置的优先级高于 工具 -&gt; 选项 -&gt; Format Document On Save 插件中的配置； 这样，有了EditorConfig 即便团队中的人员插件设置不一样，也能使用相同的格式化配置； 有关 EditorConfig 的详细信息可以查看链接，这里不详细说明了。 有了这个插件，可以很好的解决 99% 的代码格式问题，唯一例外的就是 xaml 文件不能格式化，这个会在下面单独说明。 2. XAML Styler 扩展插件 在 .Net 开发中，有一种特殊的代码文件：XAML，是前面讲的代码格式化插件所不能格式的； 而 XAML Styler 就是专门针对 xaml 文件进行格式化，这一点从名字上就能看出来。 参考链接：使用 XAML 格式化工具：XAML Styler - dino.c - 博客园 (cnblogs.com) 2.1 XAML 的问题 XAML 格式化主要的难题是下面几个： 如果所有属性都写在同一行，它太宽了很难看到后面的属性 如果每个属性单独一行，它又太长了很难看清楚它的结构 属性之间没有排序，重要属性的属性找起来很困难 团队没有统一的标准，不小心格式化一下代码的话全部都会变，CodeReview 烦死人 如果不想得过且过忍受上述这些问题的话，可以试试用 XAML Styler 这个工具，它正好解决了这些问题。 2.2 安装使用 XAML Styler 是一个 VisualStudio插件（也可用于其它 IDE），这是它在 Visual Studio Marketplace 和 Github 上的地址： XAML Styler - Visual Studio Marketplace Xavalon/XamlStyler: Visual Studio extension to help format your XAML source code (github.com) Home · Xavalon/XamlStyler Wiki (github.com) 在 VisualStudio 的管理扩展窗口中，输入 XamlStyle 搜索，点击“下载”然后关闭 VisualStudio 即可完成安装。 具体安装步骤不在这里说明了。 安装完成后重启 Visual Studio，可以在“选项”窗口中看到它的配置： 之后，每次在 XAML 编辑器中执行保存都会自动进行格式化操作。你也可以在 XAML 编辑器的右键菜单选择 Format XAML 或使用快捷键进行格式化。 2.3 关键格式化设置项说明 XAML 的格式主要有两种方式：所有属性放一行和每个属性单独一行。 如果选择所有属性放一行的时候，XAML 结构清晰，结构严谨，段落分明，而且文件也很短。 可是万一很多属性问题就出来了，一行 XAML 会变得很长。而且看看下面两个 ContentPresenter，同样都有 Margin 属性、HorizontalAlignment 属性，VerticalAlignment 属性，RecognizesAccessKey 属性，SnapsToDevicePixels 顺序ing，但你能看到第二个 ContentPresenter 后面偷偷塞了个 Margin 吗： 12Copy&lt;ContentPresenter Margin=&quot;&#123;TemplateBinding Padding&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot; SnapsToDevicePixels=&quot;&#123;TemplateBinding SnapsToDevicePixels&#125;&quot;/&gt;&lt;ContentPresenter Margin=&quot;&#123;TemplateBinding Padding&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot; SnapsToDevicePixels=&quot;&#123;TemplateBinding SnapsToDevicePixels&#125;&quot; Margin=&quot;40&quot;/&gt; 如果在 VisualStudio 中“文本编辑器-&gt;XAML-&gt;格式化-&gt;间距-&gt;特性间距”这个选项中选择了“将各个属性分别放置”： 格式化文档后上面的 XAML 就会变成这样： 1234567891011&lt;ContentPresenter Margin=&quot;&#123;TemplateBinding Padding&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot; SnapsToDevicePixels=&quot;&#123;TemplateBinding SnapsToDevicePixels&#125;&quot; /&gt;&lt;ContentPresenter Margin=&quot;&#123;TemplateBinding Padding&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot; SnapsToDevicePixels=&quot;&#123;TemplateBinding SnapsToDevicePixels&#125;&quot; Margin=&quot;40&quot; /&gt; 每个属性单独一行不仅不会看漏属性，而且编辑器本身也不会有横向和纵向两种方向的移动，只有从上到下的移动，这就舒服多了。 可是大部分情况下每个属性分行放置会破坏原本清晰的 XAML 层次结构，例如下面这种本来好好的 XAML: 123456&lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Normal&quot; /&gt;&lt;Setter Property=&quot;UseSystemFocusVisuals&quot; Value=&quot;True&quot; /&gt;&lt;Setter Property=&quot;FocusVisualMargin&quot; Value=&quot;-3&quot; /&gt;&lt;Setter Property=&quot;Height&quot; Value=&quot;50&quot; /&gt;&lt;Setter Property=&quot;Width&quot; Value=&quot;50&quot; /&gt;&lt;Setter Property=&quot;Maximum&quot; Value=&quot;1&quot; /&gt; 变成这样： 123456789101112&lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Normal&quot; /&gt;&lt;Setter Property=&quot;UseSystemFocusVisuals&quot; Value=&quot;True&quot; /&gt;&lt;Setter Property=&quot;FocusVisualMargin&quot; Value=&quot;-3&quot; /&gt;&lt;Setter Property=&quot;Height&quot; Value=&quot;50&quot; /&gt;&lt;Setter Property=&quot;Width&quot; Value=&quot;50&quot; /&gt;&lt;Setter Property=&quot;Maximum&quot; Value=&quot;1&quot; /&gt; 这种风格优雅得像诗歌 我偶尔称为豆瓣风 一行变两行 两行变四行 本来 一页看得完 的代码 变成 两页才看得完 也是够 麻烦的。 XAML Styler 很好地解决了这个问题，它通过 “Attribute tolerance” 属性控制每一行的容许的最多的属性数量，如果一个元素的属性数量少于设定值，那就放在一行，如果超过就所有属性单独一行。通常我将这个属性设置为 2，再配合 “Keep first attribute on same line = true” 的设置，可以做到下面这种格式化效果： 1234567891011121314151617&lt;SolidColorBrush x:Key=&quot;NormalTextColor&quot; Color=&quot;#2E2F33&quot; /&gt;&lt;SolidColorBrush x:Key=&quot;PrimaryColor&quot; Color=&quot;#FFED5B8C&quot; /&gt;&lt;SolidColorBrush x:Key=&quot;LineColor&quot; Color=&quot;#E1E1E1&quot; /&gt;&lt;SolidColorBrush x:Key=&quot;TransparentBackground&quot; Color=&quot;Transparent&quot; /&gt;&lt;ControlTemplate x:Key=&quot;CompletedTemplate&quot; TargetType=&quot;ContentControl&quot;&gt; &lt;Grid x:Name=&quot;CompletedElement&quot; Margin=&quot;-2&quot;&gt; &lt;control:DropShadowPanel HorizontalContentAlignment=&quot;Stretch&quot; VerticalContentAlignment=&quot;Stretch&quot; BlurRadius=&quot;8&quot; OffsetX=&quot;0&quot; OffsetY=&quot;0&quot; Color=&quot;#FFED5B8C&quot;&gt; &lt;Ellipse x:Name=&quot;CompletedRectangle&quot; Fill=&quot;&#123;StaticResource PrimaryColor&#125;&quot; /&gt; &lt;/control:DropShadowPanel&gt; &lt;/Grid&gt;&lt;/ControlTemplate&gt; 这样就可以兼顾两种格式化的优点。 2.4 排序 如果元素有多个属性，要找到它的主要属性（通常是 Name 和 Grid.Row）需要颇费一番功夫。XAML Styler 根据一个可设定的规则自动将元素的各个属性排序，这个规则如下： 12345678910111213&quot;AttributeOrderingRuleGroups&quot;: [ &quot;x:Class&quot;, &quot;xmlns, xmlns:x&quot;, &quot;xmlns:*&quot;, &quot;x:Key, Key, x:Name, Name, x:Uid, Uid, Title&quot;, &quot;Grid.Row, Grid.RowSpan, Grid.Column, Grid.ColumnSpan, Canvas.Left, Canvas.Top, Canvas.Right, Canvas.Bottom&quot;, &quot;Width, Height, MinWidth, MinHeight, MaxWidth, MaxHeight&quot;, &quot;Margin, Padding, HorizontalAlignment, VerticalAlignment, HorizontalContentAlignment, VerticalContentAlignment, Panel.ZIndex&quot;, &quot;*:*, *&quot;, &quot;PageSource, PageIndex, Offset, Color, TargetName, Property, Value, StartPoint, EndPoint&quot;, &quot;mc:Ignorable, d:IsDataSource, d:LayoutOverrides, d:IsStaticText&quot;, &quot;Storyboard.*, From, To, Duration&quot;], 排序结果大致如下： 123456789&lt;Button x:Name=&quot;Show&quot; Grid.Row=&quot;1&quot; Padding=&quot;40,20&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Background=&quot;#00aef1&quot; Content=&quot;Show&quot; Foreground=&quot;White&quot; Style=&quot;&#123;StaticResource BubbleButtonStyle&#125;&quot; /&gt; 2.5 项目级使用 最后，就算自己做好了格式化，团队中的其它成员使用了不同的格式化标准也会引起很多问题。针对这个问题 Xaml Styler 也提供了解决方案。 在项目的根目录创建一个名为“Settings.XamlStyler”的文件，内容参考这个网址：https://github.com/Xavalon/XamlStyler/wiki/External-Configurations 中的 Default Configuration。有了这个配置文件，XAML Styler 就会根据它而不是全局配置进行格式化，作为项目的统一格式化标准。 2.6 ctrl+s 保存时的冲突问题解决 设置完这两个插件后，在实际使用的过程中可能会发现：在使用 ctrl + s 保存的时候会达不到效果 现象分析 在 xaml 中按 ctrl + s 保存的时候，仔细查看画面，会发现 xaml 文件被保存了两次，而且第一一闪而过的结果好像还是正确的，最初呈现的第二次保存解决却不对了， 原因分析 根据现象可以分析出来，不止一个插件触发了xaml 的保存操作，那个捣乱者是谁，很容易想到是 Format Document On Save 解决方法 从现象中我们看到，保存了两次导致解结果不对； 那么就有两个解决方案： 让 xaml styler 最后保存， 不然 Format Document On Save 保存 xaml； 方案 1 我们无法控制保存顺序，暂时无解； 方案 2 如果我们在设置中可以设置 不存在 xaml 文件就可以了，或许可行 打开 Format Document On Save 设置信息，我们仔细查看，有一个叫 Denied Extensions 的设置项，我们可以通过它设置不格式化 xaml 文件，设置后试了一些，依然达不到效果，查看那里除了问题，仔细看 Denied Extensions 设置项的说明发现： Denied Extensions 设置项，只有在 Allowed Extensions 设置项为空的情况下才能生效，于是赶紧删除试一下，果然成功了。","categories":[{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"VisualStudio","slug":"工具/VisualStudio","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/VisualStudio/"}],"tags":[{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/tags/VisualStudio/"},{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"使用 Windows Server 建立 Web Site 并关联 FTP Server","slug":"使用-Windows-Server-建立-Web-Site-并关联-FTP-Server","date":"2022-01-25T03:20:44.000Z","updated":"2022-01-25T03:41:16.430Z","comments":true,"path":"2022/01/25/使用-Windows-Server-建立-Web-Site-并关联-FTP-Server/","link":"","permalink":"https://buctllx.github.io/2022/01/25/%E4%BD%BF%E7%94%A8-Windows-Server-%E5%BB%BA%E7%AB%8B-Web-Site-%E5%B9%B6%E5%85%B3%E8%81%94-FTP-Server/","excerpt":"本文主要说明，如何在 windows server 中建立 web site，并关联 ftp 服务；最终达到的效果是，可以通过 https 链接访问 ftp 服务的所有内容； 系统环境：window server 2019","text":"本文主要说明，如何在 windows server 中建立 web site，并关联 ftp 服务；最终达到的效果是，可以通过 https 链接访问 ftp 服务的所有内容； 系统环境：window server 2019 1、开启系统必备的服务组件 2、新建 SSL 证书 3、建立 web site 并关联 FTP Server 4、其他设置 4.1 ftp 服务直通网络位置 4.2 web site 开启浏览文件目录结构的功能 4.3 web site 绑定 https 访问 参考资料：","categories":[{"name":"windwos","slug":"windwos","permalink":"https://buctllx.github.io/categories/windwos/"},{"name":"web site","slug":"windwos/web-site","permalink":"https://buctllx.github.io/categories/windwos/web-site/"},{"name":"ftp server","slug":"windwos/ftp-server","permalink":"https://buctllx.github.io/categories/windwos/ftp-server/"}],"tags":[{"name":"windwos","slug":"windwos","permalink":"https://buctllx.github.io/tags/windwos/"},{"name":"web site","slug":"web-site","permalink":"https://buctllx.github.io/tags/web-site/"},{"name":"ftp","slug":"ftp","permalink":"https://buctllx.github.io/tags/ftp/"}]},{"title":"Revit 构件参数体系说明","slug":"Revit-构件参数体系说明","date":"2022-01-20T10:45:52.000Z","updated":"2022-01-25T06:24:30.143Z","comments":true,"path":"2022/01/20/Revit-构件参数体系说明/","link":"","permalink":"https://buctllx.github.io/2022/01/20/Revit-%E6%9E%84%E4%BB%B6%E5%8F%82%E6%95%B0%E4%BD%93%E7%B3%BB%E8%AF%B4%E6%98%8E/","excerpt":"1、Revit 构件分类说明 从不同的维度 Revit 构件（图元）有不同的分类； 对用用户来说：最为熟悉的就是“项目浏览器”中“族”节点的三级分类： 这里主要介绍以下几种分类维度；","text":"1、Revit 构件分类说明 从不同的维度 Revit 构件（图元）有不同的分类； 对用用户来说：最为熟悉的就是“项目浏览器”中“族”节点的三级分类： 这里主要介绍以下几种分类维度； 1.1 常见的三级分类 三级分类，一般用于用户分类管理各种构件，方便用户快速检索使用； 每一级分类都有自己的参数，只不过用户经常关注的时：类型参数、实例参数而已 image-20220121142116181 1.1.1 一级分类 - 类别 英文名字也是 API 的名字：Category Category 是 Revit 软件内置的基础数据，不能被用户和开发者“增删改”，用户只有使用权限； 对于某个确定的 Revit 版本 Category 数量是固定的，只有在 Revit 版本的变化的时候 Category 才可能变化（一般是新增） Category 内部也是有联系的，具体变现为子类别 SubCategory，这一点一般用户是看不到的； 下面是 Revit API 暴露出来的所有的 Category，可以通过切花版本查看； Revit API BuiltInCategory Enumeration (revitapidocs.com) 经过个人统计 Category 发现： 总数：2000+ 一般项目中用到的：900左右 实际建模常用的：不超过100 1.1.2 二级分类 - 族 Family 在类别之下的二级分类； 所有添加到 Revit 项目中的图元都是使用族创建的。 族 在 Revit 中也分为多种类型，具有一定的可扩展性，但并不是所有的族都能扩展，后面 1.2 章节会说明 这里需要特殊说明的是：族并不是单一的构件，它是可以嵌套，复合的，从而生成更加复杂高级的族； 更多详细说明参见 Autodesk Revit 官方文档：帮助: Revit 族 (autodesk.com) 1.1.3 三级分类 - 类型 xxx_Type，FamilySymbol 一个族，可以有多个类型；一般叫：族类型； 类型是用户建模的时候必须指定的信息， 指定了类型，就只定了族和类别； 类型下面就是“图元”了，也可以叫构件；所谓图元，就是在模型视图中实实在在看到的对象，但被选中时，会高亮显示，并且会在“属性”窗口中显示图元的参数信息； “属性”窗口中显示的并不是图元所有的属性信息 1.2 按族类型分类 1.2.1 系统族 特点： Revit 软件内置的，所有的 rvt 文件都是一样的； 有限的； 用户不能自己添加 / 删除（Revit 升级的时候或许会新增）； 常见的系统族：墙，楼板、各种管线、屋顶、…… 1.2.2 载入族 特点： 以 rfa 文件的形式存在； 可以载入不同的 rvt 文件中复用； 用户可以自己新增或者删除； 常见的系统族：梁、柱、管件、管道附件、末端、家具、设备…… 1.2.3 内建族 特点： 只存在于某一个 rvt 文件内，不能被复用； 只包含一个类型且类型名称和族名称一样 用户可以自己新增或者删除； 可以随意指定，创建的时候只需要指定 类别，输入一个族名称，Revit 就会自动创建一个内建族 1.3 按 Category 类型分类 这种分类是按照 Category 的属性信息 Category Type 进行划分的 一般较少关注 1.3.1 模型类构件(模型族) 可以在三维视图中进行查看的； 例如：墙、梁、板、柱、…… 1.3.2 详图类构件(注释族) 在平面视图中进行辅助查看，不能在三维视图中看到； 例如：标记、尺寸标注、…… 1.3.3 分析类构件(分析族) Revit 中有一个单独的分析模块，分析族用来展示分析结果的 例如：分析墙、分析柱、…… 1.3.4 内部类构件(内部族) Revit 内部使用的； 用户一般不直接使用，通常起到辅助类的构件； 例如：结构连接处理程序、部件、…… 2、Revit 参数分类说明 Revit 参数也有多个分类的维度， 这里主要介绍以下几种分类维度 2.1 按作用的层级 作用层级包含了三级分类，在 1.1 中说明过，每一级都有自己的描述参数； 除了三级分类，这里补充说明了“项目参数”和“实例参数” 2.1.1 项目级参数 这里项目有别于建筑设计的项目，意思是 rvt 文件，Revit 默认一个 rvt 文件就是一个项目文件，rvt 文件级别的参数就是项目参数，不同的 rvt 文件可以定义不同数量的参数； 所有的项目参数集合在一起，叫做“项目信息”，也是一个 Category 类别 符合 Revit 添加参数的统一流程 除此之外还有一种特殊的项目参数叫“全局参数”，是 2016 R2 以后新增的，具体参见 2.2 2.1.2 族级参数 被用来描述族 Family 的相关信息； 一边较少使用，且不能增删改 image-20220121181936225 2.1.3 类型级参数 一个族一般有多个类型，一个类型之所以区别于另一个类型，就是因为类型参数的参数值不一样（如果一样，那么就可以认为是相同的类型，就没必要新建这个类型了） 为了描述族下面的多个类型，因此产生了类型参数； image-20220121182705093 2.1.4 实例级参数 视图中看到的每一个图元，都有自己的属性信息，这些属性信息都是通过实例参数描述的； 具体变现为：Revit “属性”窗口中看到的参数（上面截图，左侧部分） 2.2 按参数的定义 这种分类方式，只关心参数是如何定义的，不关心这个参数将会被用于描述哪个对象； 通过不同不同的定义方式，可以将参数分为以下几类； 2.2.1 内置参数 BuiltinParameter 在 Revit 中通过枚举的方式暴露出来，用户不能做任何修改； BuiltInParameter Enumeration (revitapidocs.com) 2.2.2 共享参数 用户通过共享参数文件定义； 一般情况下一个用户定义并使用一个共享参数文件，也可以做到多个用户使用同一个共享参数文件； 2.2.3 族参数 在编辑 rfa 文件过程中定义的参数； image-20220121185129566 根据创建方式的不同，还可以划分为： 共享参数 一般族参数 这类参数比较特殊，该类型的参数只能在族文件范围内定义， 简单来说就是，只能在编辑 rfa 文件的时候进行定义；且有效的使用范围只能在 rfa 文件内部； 这中参数是造成 revit 参数被滥用的一个原因 族参数，在族内部作用的层级，还可以划分为： 类型参数 实例参数； 参考：2.1 中的类型参数和实例参数； 2.2.4 全局参数 image-20220124162335058 全局参数是 Autodesk 在 Revit 2016 R2 版本（17 及其以后的版本都有）增加的内容，是继共享参数与项目参数之后新增加的一种参数。 全局参数特定于单个项目文件，但未像项目参数那样指定给类别。全局参数可以是简单值、来自表达式的值或使用其他全局参数从模型获取的值。 有点类似于族文件里的“一般族参数” 详细的使用方式和案例，参见官方文档：帮助: 全局参数 (autodesk.com) 3、Revit 参数管理体系 Revit 中的参数主要有两类： 常规参数 材质类参数 3.1 常规参数的定义管理体系 在 Revit 中所有的参数都必须先定义，然后才能被使用； 关于参数定义，Revit 有自己的一套管理体系； 下面截图是各种参数的定义截图 [共享参数定义][项目参数定义][项目参数使用共享参数定义][族参数定义] image-20220121145632974 image-20220121150553052 image-20220121151733095 image-20220121151930344 从上面的截图可以看出来，用于参数管理的主要有以下几个信息： 规程 参数类型 参数分组 参数分组方式 类型 or 实例 是否报告参数 这些信息，主要用于描述一个参数，方便 Revit 对参数进行管理； “参数定义”并不关注这个参数将会被用于描述什么对象，或者单位是什么；参数的 描述对象，单位信息，则是通过一种关联关系进行使用 因为： 一个参数的定义可以被用于描述一个或者多个对象，在给对象添加参数的时候，去选择已经定义好的参数就行了；【添加项目参数的后最右侧会有关联对象的选择】 一个参数可能没有单位或者有多个单位；具体选择哪个单位，在显示或者使用的时候确定就可以了，如下图所示； image-20220121174516331 3.2 材质类参数管理体系 材质类参数，因为涉及到渲染、显示，因此十分复杂；Autodesk 的很多建模软件使用的材质库都是独立的，并不共享； 因为材质相关的参数体系太过复杂，API暴露有是有限的，所以下面主要以介绍为主； 功能入口：管理 -&gt; 设置 -&gt; 材质 在这里用户可以自己创建、定义、编辑、修改与材质相关的各种信息； [土建材质 - 示例][机电材质 - 示例] image-20220124163727041 image-20220124163317836 从上面的截图看，材质信息主要包含以下几类信息： 标识 图形 外观 物理（可选） 热度（可选） 每一类，都包含若干参数，并且通过分组进行管理 3.3 通用参数值的管理 上面说完了参数定义，另外一个话题就是参数值； 3.3.1 通用参数(值)特点 因为存在这样一部分参数，他们对于参数值的填写是有一些基本要求的； 比如说：颜色，只能在 0 ~ 255 之间； 还有一类：提供一些基本的参数值，让用户进行选择；同时可以暴露一些参数值定义的接口，让用户可以先定义参数值，然后再选择参数值进行使用。 这类参数值都有一些特点： 有限 可枚举 比较常见、通用 跟其他参数或者对象有关联关系 这类参数，主要集中在 管理 -&gt; 设置 面板中 3.3.2 例子 （1）规程类参数： 规程参数各处都有用，参数值是 Revit 规定的有限的几个，与其他参数有关联，比如说：参数分组，子规程等 （2）建筑/空间 类型参数 image-20220124171308987 （3）机电 - 系统类型 参数 image-20220124170329124 （4）显示类参数(值) 填充样式 线样式 线宽 线型图案 材质资源 这些跟材质或者显示类的参数都有关系，主要影响的就是渲染显示。","categories":[{"name":"Revit","slug":"Revit","permalink":"https://buctllx.github.io/categories/Revit/"}],"tags":[{"name":"Revit","slug":"Revit","permalink":"https://buctllx.github.io/tags/Revit/"}]},{"title":"Hexo 集成 PicGo Github 图床","slug":"Hexo-集成-PicGo-Github-图床","date":"2022-01-20T10:15:23.000Z","updated":"2022-01-20T10:40:20.604Z","comments":true,"path":"2022/01/20/Hexo-集成-PicGo-Github-图床/","link":"","permalink":"https://buctllx.github.io/2022/01/20/Hexo-%E9%9B%86%E6%88%90-PicGo-Github-%E5%9B%BE%E5%BA%8A/","excerpt":"0、背景说明 博主原来使用七牛云图床，好处：10G 免费空间；坏处：域名有效期一个月；超出一个月就没法使用了； 因而转向了其他图床，发现 PicGo 中支持的图床有 Github，觉得是一个不错的选择 使用 Github 图床的好处： 没有域名限制； 仓库虽然空间有限（1G），但是满了可以再新建一个仓库，因此相当于无限 有人说慢，但是可以设置加速 稳定，不用担心挂了或者失效","text":"0、背景说明 博主原来使用七牛云图床，好处：10G 免费空间；坏处：域名有效期一个月；超出一个月就没法使用了； 因而转向了其他图床，发现 PicGo 中支持的图床有 Github，觉得是一个不错的选择 使用 Github 图床的好处： 没有域名限制； 仓库虽然空间有限（1G），但是满了可以再新建一个仓库，因此相当于无限 有人说慢，但是可以设置加速 稳定，不用担心挂了或者失效 参考： MarkDown、Hexo博客、Coding托管、GitHub做图床、CDN加速 - 段十三 - 博客园 (cnblogs.com) 1、新建一个仓库 名字自定义，例如：pic_bed 选择 Public 勾选初始化复选框： Initialize this repository with a README 点击 Create repository 创建成功 New personal access token (github.com) 配置图床的时候要用： Note下面的文本框内容自定义 下面很多复选框，只需要勾选 repo 也就是第一个复选框 最下面点击Generate token即可生成 下面要用，如果忘记了可以在重新生成 2、安装配置 PicGo 下载安装，这里不再说明， 安装后启动 PicGo，找到 Github 图床，如下图所示： image-20220120182829709 填写第一步中创建的 仓库名，分支名，以及 Token 然后“确定”，并设置为默认图床即可 3、配置 JsDeliv，给图片镶上加速器 比如在GitHub的图片路径是：https://github.com/user/pic_bed/img/test_image.png 拼接链接方法1：https://cdn.jsdelivr.net/gh/user/pic_bed@latest/img/test_image.png 拼接链接方法2：https://cdn.jsdelivr.net/gh/user/pic_bed/img/test_image.png 将方法1和方法2拼接起来的链接前缀输入到上图第5步的自定义域名中即可 拼接链接方法1：https://cdn.jsdelivr.net/gh/user/pic_bed@latest/ 拼接链接方法2：https://cdn.jsdelivr.net/gh/user/pic_bed/ 4、再 Typora 中选择 PicGo app 作为图片上传服务 Typora 设置关联七牛云图床 | ConorLuo 博客 (buctllx.github.io)","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"},{"name":"PicGo","slug":"Hexo/PicGo","permalink":"https://buctllx.github.io/categories/Hexo/PicGo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"},{"name":"PicGo","slug":"PicGo","permalink":"https://buctllx.github.io/tags/PicGo/"}]},{"title":"Windows Terminal 集成 Oh My Posh","slug":"Windows-Terminal-集成-Oh-My-Posh","date":"2021-12-29T03:52:56.000Z","updated":"2022-03-22T06:42:18.875Z","comments":true,"path":"2021/12/29/Windows-Terminal-集成-Oh-My-Posh/","link":"","permalink":"https://buctllx.github.io/2021/12/29/Windows-Terminal-%E9%9B%86%E6%88%90-Oh-My-Posh/","excerpt":"1. 准备安装环境 Windows Termianl, PowerShell 都可以从 Microsoft Store 中下载 Windows Terminal (Windows 自带) PowerShell 具体安装这里不做详细说明","text":"1. 准备安装环境 Windows Termianl, PowerShell 都可以从 Microsoft Store 中下载 Windows Terminal (Windows 自带) PowerShell 具体安装这里不做详细说明 2. 安装 Oh My Posh 这里推荐去 Oh My Posh 官方网站查看最新的安装方法； 网上的大部分教程，存在时效性问题，因为 Oh My Posh 是不断更新的，不同时间不同版本的安装方法可能不一样 因此搜索到的二手安装教程不一定使用目前安装的你 Home | Oh My Posh Introduction | Oh My Posh 2.1 参考文档： 将美化进行到底，使用 Oh My Posh 把 PowerShell 做成 oh-my-zsh 的样子 - walterlv Making Windows Terminal look awesome with oh-my-posh and new fonts. (zimmergren.net) 2.2 可能使用到的命令 1234567891011121314# 查看已经安装的模块Get-InstalledModule# 当前用户安装一个模块 （-Verbose 参数显示细节）全局使用 AllUsers Install-Module oh-my-posh -Scope CurrentUser -Verbose# 导入加载一个模块 （-Verbose 参数显示细节）Import-Module oh-my-posh -Verbose# 卸载一个模块Uninstall-Module -Name oh-my-posh# 查看 PowerShell 安装源 GalleryGet-PSRepository 参考链接： Install-Module (PowerShellGet) - PowerShell | Microsoft Docs Get-PSRepository (PowerShellGet) - PowerShell | Microsoft Docs PowerShell Gallery | Home 2.3 字体选择 官方推荐 Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp; fonts patcher 下载自定后安装方法： 解压、进入字体目录、全选、右键、安装 即可 3. Posh-Git 安装 dahlbyk/posh-git: A PowerShell environment for Git (github.com) Posh-Git 提供了强大的 tab 补全功能， 并针对提示符进行了增强；可以在 Terminal 中使用 官方文档安装方法： Git - Git 在 PowerShell 中使用 Git (git-scm.com) 1Install-Module posh-git -Scope CurrentUser -Force 这里不做详细说明","categories":[{"name":"Termianl","slug":"Termianl","permalink":"https://buctllx.github.io/categories/Termianl/"},{"name":"PowerShell","slug":"Termianl/PowerShell","permalink":"https://buctllx.github.io/categories/Termianl/PowerShell/"}],"tags":[{"name":"Termianl,PowerShell,Oh-My-Posh","slug":"Termianl-PowerShell-Oh-My-Posh","permalink":"https://buctllx.github.io/tags/Termianl-PowerShell-Oh-My-Posh/"}]},{"title":"Hexo Next Theme 使用问题总结","slug":"Hexo-Next-Theme-使用问题总结","date":"2021-12-21T09:36:03.000Z","updated":"2021-12-22T03:35:02.306Z","comments":true,"path":"2021/12/21/Hexo-Next-Theme-使用问题总结/","link":"","permalink":"https://buctllx.github.io/2021/12/21/Hexo-Next-Theme-%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"两个路径说明： site root directory：博客站点根目录 theme root directory：博客主题根目录 后面说明问题会一直沿用这中叫法； 1. 部署后“搜索”功能无法使用 原因 使用了最新的 master 版本，master 分支是主题作者的开发分支，每周都会更新，当时不稳定","text":"两个路径说明： site root directory：博客站点根目录 theme root directory：博客主题根目录 后面说明问题会一直沿用这中叫法； 1. 部署后“搜索”功能无法使用 原因 使用了最新的 master 版本，master 分支是主题作者的开发分支，每周都会更新，当时不稳定 解决方法 拉去稳定版本的分支，主要看最新的 Tag 参考 Issues 链接：https://github.com/hexojs/hexo/issues/4654 2. 替换图片资源路径 主题涉及到的，各种图片资源都是可以替换的， **替换路径：theme root directory* 为了显示效果，注意替换的图片最好是对应像素的，而且不易过大，图片类型可以自己修改 可替换图片说明： 图片名称 含义 avatar 博主图像 favicon-16x16-next 网站图标 16x16 像素 favicon-32x32-next 网站图标 32x32 像素 logo log apple-touch-icon-next 触摸图标 alipay 支付宝收款二维码 weixin 微信收款二维码 3. 增加自定义的“标签”，“分类”页面 默认安装好的 next 主题，是没有“标签”，“分类”页面的； 需要使用者自己新增页面： 新增方法：以“标签”也为例说明： 使用 hexo 命令新建 tags.md页面 12# cd site root directoryhexo new page tags 打开 tags.md 并修改页面类型 type 信息 123title: Tagsdate: 2021-12-22 12:00:00type: tags 修改主题配置文件 12345# cd next/_config.ymlmenu: home: / || fa fa-home archives: /archives/ || fa fa-archive tags: /tags/ || fa fa-tags 4. 开启首页文章部分显示 next 主题默认的是将你的文章全篇显示在自己的首页上，这就会导致一个问题，首页各个文章太长了不利于翻阅 想要让文章部分显示，并出现“阅读全文的按钮”，只需要在个人的文章 Markdown 源文件中添加一行代码就行 1&lt;!--more--&gt; 具体位置，自己确定，在自己想要显示的文章部分下面加上即可只在首页显示所需的文章部分。 参考文档： Custom Pages | NexT (theme-next.js.org) 创建分类页面 · iissnan/hexo-theme-next Wiki (github.com) Hexo + Theme Next -- 写作 | Knner.Wang's Blog","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"},{"name":"Hexo Theme","slug":"Hexo/Hexo-Theme","permalink":"https://buctllx.github.io/categories/Hexo/Hexo-Theme/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"},{"name":"Theme","slug":"Theme","permalink":"https://buctllx.github.io/tags/Theme/"}]},{"title":"ElasticSearch 操作异常总结","slug":"ElasticSearch-操作异常总结","date":"2021-12-15T09:41:01.000Z","updated":"2021-12-22T10:33:37.292Z","comments":true,"path":"2021/12/15/ElasticSearch-操作异常总结/","link":"","permalink":"https://buctllx.github.io/2021/12/15/ElasticSearch-%E6%93%8D%E4%BD%9C%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/","excerpt":"1. Index 写入数据 FORBIDDEN 问题 1.1 问题描述 在使用七牛云的 Logkit 往 ElasticSearch 发送数据的时候出现了以下异常信息； 123456789101112# SendError: bulk failed with last error&#123; &quot;_index&quot;:&quot;dev_cbim_tool_log&quot;, &quot;_type&quot;:&quot;cbim_tool_log&quot;, &quot;_id&quot;:&quot;UhoDvX0B7FSmwLI_OPym&quot;, &quot;status&quot;:403, &quot;error&quot;:&#123; &quot;type&quot;:&quot;cluster_block_exception&quot;, &quot;reason&quot;:&quot;blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];&quot; &#125;&#125;# failDatas size : 33 其核心异常提示是：[FORBIDDEN/12/index read-only / allow delete (api)]","text":"1. Index 写入数据 FORBIDDEN 问题 1.1 问题描述 在使用七牛云的 Logkit 往 ElasticSearch 发送数据的时候出现了以下异常信息； 123456789101112# SendError: bulk failed with last error&#123; &quot;_index&quot;:&quot;dev_cbim_tool_log&quot;, &quot;_type&quot;:&quot;cbim_tool_log&quot;, &quot;_id&quot;:&quot;UhoDvX0B7FSmwLI_OPym&quot;, &quot;status&quot;:403, &quot;error&quot;:&#123; &quot;type&quot;:&quot;cluster_block_exception&quot;, &quot;reason&quot;:&quot;blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];&quot; &#125;&#125;# failDatas size : 33 其核心异常提示是：[FORBIDDEN/12/index read-only / allow delete (api)] 1.2 原因分析 从字面意思看，ES 禁止数据写入； 联想到最近服务器发生的一系列问题，一切都能解释的通了； 最近发现：ES 集群的一个节点挂了（主要是因为服务器的磁盘坏了）； 在这样的情况下，触发了 ES 的保护机制，因此出现了上面的情况； 1.3 解决方法 1curl -XPUT -H &quot;Content-Type: application/json&quot; http://localhost:9200/_all/_settings -d &#x27;&#123;&quot;index.blocks.read_only_allow_delete&quot;: null&#125;&#x27; 参考链接：[如何修复 ElasticSearch FORBIDDEN/12/index read-only / allow delete （api）] – TechOverflow 2. ElasticSearch 启动参数问题 通过 docker 启动 es 的时候，相关参数设置跟 es 的镜像版本有关； 这里主要说明常见的各种 es 设置问题 2.1 unknown setting [discovery.seed_hosts] 产生背景 使用2019年的老脚本启动 es 的 docker 实例； 注：笔者是 2021.12.15 pull 最新的 es 镜像启动实例的，启动实例使用的参数是 2019 年底时的； 原因 2019 年底的 es 镜像和 2021 年的镜像文件参数设置不一致， 可以通过 dock inspect elasticsearch 查看 解决方法 使用下面的配置替代 1discovery.zen.ping.unicast.hosts: [&quot;192.168.10.11:9300&quot;,&quot;192.168.10.12:9300&quot;,&quot;192.168.10.13:9300&quot;] 注意：启动脚本，最好跟 docker 镜像配套使用 类似的问题 unknown setting [cluster.initial_master_nodes] 2.2 ES 缓存设置 默认设置：ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" 启动的时候可以加 -e 指定参数 1-e ES_JAVA_OPTS=&quot;-Xms1g -Xmx1g&quot; 设置过大可能导致本机缓存不够，启动时有如下错误提示： max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 解决方法：修改 centos 系统的缓存设置 1234567# 1. open and edit confvi /etc/sysctl.conf# 2. add at last vm.max_map_count=262144# 3. apply/sbin/sysctl -p 3. ElasticSearch 集群状态排查 Elasticsearch 集群故障排查及修复指南_铭毅天下（公众号同名）-CSDN博客 4. ES 索引 primary shard is unassigned 解决方法 12345678910111213POST /_cluster/reroute&#123; &quot;commands&quot; : [ &#123; &quot;allocate_stale_primary&quot; : &#123; &quot;index&quot; : &quot;.monitoring-kibana-6-2021.12.17&quot;, &quot;shard&quot; : 0, &quot;node&quot; : &quot;es-node-2&quot;, &quot;accept_data_loss&quot; : true &#125; &#125; ]&#125; [ES 遇到 unassigned shard如何处理？_weixin_34050519的博客-CSDN博客](https://blog.csdn.net/weixin_34050519/article/details/85936609) 解决elasticsearch分片unassigned的3个方法_dlm_bk的博客-CSDN博客_es分片unassigned","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://buctllx.github.io/categories/ElasticSearch/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://buctllx.github.io/tags/ElasticSearch/"},{"name":"ES","slug":"ES","permalink":"https://buctllx.github.io/tags/ES/"}]},{"title":"Typora 设置关联七牛云图床","slug":"Typora-设置关联七牛云图床","date":"2021-12-06T06:46:25.000Z","updated":"2021-12-22T03:34:21.566Z","comments":true,"path":"2021/12/06/Typora-设置关联七牛云图床/","link":"","permalink":"https://buctllx.github.io/2021/12/06/Typora-%E8%AE%BE%E7%BD%AE%E5%85%B3%E8%81%94%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A/","excerpt":"1. 七牛云存储环境准备 1.1 注册 七牛云官网：七牛云 - 国内领先的企业级云服务商 (qiniu.com) 注册流程不在这里详细说明； 说一下注意事项： 注册后，需要实名认证 个人认证 即可","text":"1. 七牛云存储环境准备 1.1 注册 七牛云官网：七牛云 - 国内领先的企业级云服务商 (qiniu.com) 注册流程不在这里详细说明； 说一下注意事项： 注册后，需要实名认证 个人认证 即可 1.2 新建图床存储空间 登录后，通过“管理控制台”进入管理页面； 点击“对象存储 Kodo”； 点击“空间管理” -&gt; “新建空间” 进行图床空间创建； 如下图所示，设置完相关参数，即可创建一个图床存储空间； image-20211207135828755 注意事项： 访问权限选择“公开” 存储区域一般选择“距离自己比较近的”，并且不同区域有不同的代号，后面会用到 2. PicGo 安装 PicGo 有两种类型； PicGo App（应用程序） PicGo-Core（命令行版本） 2.1 安装 2.1.1 图形界面版本 PicGo图形 选择对应系统的安装包安装即可 2.1.2 命令行版本 PicGo-core 没有nodejs环境，使用typora一键安装即可 本机有nodjs环境，直接npm全局安装 123npm install picgo -g# oryarn global add picgo 插件安装 picgo-plugin-web-uploader 这是一款可以上传自定义图床的插件 1picgo install web-uploader 2.2 配置 关于存储区域的填写跟在七牛云上新建空间的地理位置有关； 具体参考：存储区域_产品简介_对象存储 - 七牛开发者中心 (qiniu.com) image-20211206144124515 2.2.1 图形版直接图形界面配置 参考配置 image-20211208133520184 2.2.2 图形版直接图形界面配置 参考配置文件 123456789101112131415161718&#123; &quot;picBed&quot;: &#123; &quot;uploader&quot;: &quot;qi_niu&quot;, &quot;current&quot;: &quot;qi_niu&quot;, &quot;qi_niu&quot;: &#123; &quot;accessKey&quot;: &quot;you-access-key&quot;, &quot;secretKey&quot;: &quot;you-secret-key&quot;, &quot;bucket&quot;: &quot;blog-pic-resp&quot;, &quot;url&quot;: &quot;http://you-url&quot;, &quot;area&quot;: &quot;z1&quot;, &quot;options&quot;: &quot;&quot;, &quot;path&quot;: &quot;&quot; &#125; &#125;, &quot;picgoPlugins&quot;: &#123; &quot;picgo-plugin-web-uploader&quot;: true &#125;&#125; 3. Typora 图片存储设置 设置入口：设置 - 偏好设置 - 图像； 如下图所示： image-20211207102745086 image-20211207102901759 插入图片时：选择：上传图片； 上传服务设定 上传服务：选择：PicGo（app） PicGo 路径：选择：自己安装时候的路径 当上述两大项设置完毕后，点击：“验证图片上传选项” 设置成功后，会出现“验证成功”的提示，如下图： 如果你的主题设置是 Onedark 一类的黑色主题，这个提示可能会不明显，需要仔细查看才能看到； image-20211207103956991 image-20211207104327148","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://buctllx.github.io/categories/Markdown/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://buctllx.github.io/tags/PicGo/"},{"name":"Typora","slug":"Typora","permalink":"https://buctllx.github.io/tags/Typora/"}]},{"title":"Git fetch 同时更新子模块","slug":"Git-fetch-同时更新子模块","date":"2021-12-02T10:25:13.000Z","updated":"2021-12-22T03:34:02.662Z","comments":true,"path":"2021/12/02/Git-fetch-同时更新子模块/","link":"","permalink":"https://buctllx.github.io/2021/12/02/Git-fetch-%E5%90%8C%E6%97%B6%E6%9B%B4%E6%96%B0%E5%AD%90%E6%A8%A1%E5%9D%97/","excerpt":"1. 问题描述 默认情况，git checkout; git fetch 如果子模块 submodule 的版本不一致， git 是不会自动更新子模块；","text":"1. 问题描述 默认情况，git checkout; git fetch 如果子模块 submodule 的版本不一致， git 是不会自动更新子模块； 2. 传统解决方法： cd submodules 文件夹； git checkout / fetch； 3. 高级解决方法： 在全局进行 Git 设置： 1 git config --global submodule.recurse true 设置 submodule.recurse true 后，不仅仅 git checkout 会自动切换子模块，git fetch / pull 也会自动拉取子模块的更新 注意：这个设置对用户机器上安装的 git 版本有要求，详见下面说明 在发行说明中提到了这一点：https://github.com/git/git/commit/e1104a5ee539408b81566066aaa6963cb87d5cd6#diff-c24776ff22455a30fbb78e378b7df0b0R139 submodule.recurse 选项已添加到 git 2.14","categories":[{"name":"Git 相关","slug":"Git-相关","permalink":"https://buctllx.github.io/categories/Git-%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://buctllx.github.io/tags/Git/"}]},{"title":"WPF 在 Trigger 中修改 Button Content 注意事项","slug":"WPF-在-Trigger-中修改-Button-Content-注意事项","date":"2021-12-02T08:52:58.000Z","updated":"2021-12-22T03:34:31.422Z","comments":true,"path":"2021/12/02/WPF-在-Trigger-中修改-Button-Content-注意事项/","link":"","permalink":"https://buctllx.github.io/2021/12/02/WPF-%E5%9C%A8-Trigger-%E4%B8%AD%E4%BF%AE%E6%94%B9-Button-Content-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"1. 问题描述 xaml 代码块如下： 12345678910111213&lt;Button Content=&quot;333&quot;&gt; &lt;Button.Style&gt; &lt;Style TargetType=&quot;Button&quot;&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;70&quot;/&gt; &lt;Setter Property=&quot;Height&quot; Value=&quot;27&quot;/&gt; &lt;Style.Triggers&gt; &lt;DataTrigger Binding=&quot;&#123;Binding ElementName=listBox, Path=SelectedIndex&#125;&quot; Value=&quot;2&quot;&gt; &lt;Setter Property=&quot;Content&quot; Value=&quot;three&quot; /&gt; &lt;/DataTrigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/Button.Style&gt; &lt;/Button&gt; 运行后，触发 DataTrigger 发现 Button 的 Content 没有变化","text":"1. 问题描述 xaml 代码块如下： 12345678910111213&lt;Button Content=&quot;333&quot;&gt; &lt;Button.Style&gt; &lt;Style TargetType=&quot;Button&quot;&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;70&quot;/&gt; &lt;Setter Property=&quot;Height&quot; Value=&quot;27&quot;/&gt; &lt;Style.Triggers&gt; &lt;DataTrigger Binding=&quot;&#123;Binding ElementName=listBox, Path=SelectedIndex&#125;&quot; Value=&quot;2&quot;&gt; &lt;Setter Property=&quot;Content&quot; Value=&quot;three&quot; /&gt; &lt;/DataTrigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/Button.Style&gt; &lt;/Button&gt; 运行后，触发 DataTrigger 发现 Button 的 Content 没有变化 2. 原因和解决方法 原因：定义 Button 的时候直接指定 Content 相当于定死了 Button 的 Content ，所以在 Style 的 Trigger 中就无法修改了； 注意： 这个时候如果指定有默认的 Button Style，默认样式也会失效；原因是重写了 Style； 解决方案：将 Content 的默认值，写进 Button.Style，如下所示： 1234567891011121314&lt;Button&gt; &lt;Button.Style&gt; &lt;Style TargetType=&quot;Button&quot;&gt; &lt;Setter Property=&quot;Content&quot; Value=&quot;333&quot;/&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;70&quot;/&gt; &lt;Setter Property=&quot;Height&quot; Value=&quot;27&quot;/&gt; &lt;Style.Triggers&gt; &lt;DataTrigger Binding=&quot;&#123;Binding ElementName=listBox, Path=SelectedIndex&#125;&quot; Value=&quot;2&quot;&gt; &lt;Setter Property=&quot;Content&quot; Value=&quot;three&quot; /&gt; &lt;/DataTrigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/Button.Style&gt; &lt;/Button&gt;","categories":[{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/categories/WPF/"}],"tags":[{"name":".Net","slug":"Net","permalink":"https://buctllx.github.io/tags/Net/"},{"name":"C#","slug":"C","permalink":"https://buctllx.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/tags/WPF/"},{"name":"Style","slug":"Style","permalink":"https://buctllx.github.io/tags/Style/"}]},{"title":"wpf control window 范围内默认样式对第一个控件无效","slug":"wpf-control-window-范围内默认样式对第一个控件无效","date":"2021-12-02T07:12:32.000Z","updated":"2021-12-22T03:42:14.493Z","comments":true,"path":"2021/12/02/wpf-control-window-范围内默认样式对第一个控件无效/","link":"","permalink":"https://buctllx.github.io/2021/12/02/wpf-control-window-%E8%8C%83%E5%9B%B4%E5%86%85%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%E5%AF%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%8E%A7%E4%BB%B6%E6%97%A0%E6%95%88/","excerpt":"1、问题描述 wpf 页面设计中，有时候在 xaml 文件 Resource 中指定 window 范围的默认 control style，但是却发现对第一个控件不起作用，具体如下：","text":"1、问题描述 wpf 页面设计中，有时候在 xaml 文件 Resource 中指定 window 范围的默认 control style，但是却发现对第一个控件不起作用，具体如下： 1234567891011121314151617181920212223242526&lt;Window x:Class=&quot;TestApp.TestWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;TestWindow&quot; Height=&quot;400&quot; Width=&quot;500&quot; WindowStyle=&quot;None&quot; WindowState=&quot;Maximized&quot;&gt; &lt;Window.Resources&gt; &lt;ResourceDictionary&gt; &lt;ResourceDictionary.MergedDictionaries&gt; &lt;ResourceDictionary Source=&quot;Resources/AllResources.xaml&quot;/&gt; &lt;ResourceDictionary&gt; &lt;Style TargetType=&quot;&#123;x:Type Button&#125;&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;100&quot;/&gt; &lt;/Style&gt; &lt;/ResourceDictionary&gt; &lt;/ResourceDictionary.MergedDictionaries&gt; &lt;/ResourceDictionary&gt; &lt;/Window.Resources&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Column=&quot;0&quot; Content=&quot;1&quot; Name=&quot;Button1&quot;/&gt; &lt;Button Grid.Column=&quot;1&quot; Content=&quot;2&quot; Name=&quot;Button2&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; button1 的 FontSize 并不是 100；但是 button2 却没问题； 通常我们使用下面的代码是没问题的； 12345678910111213141516171819&lt;Window x:Class=&quot;TestApp.TestWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;TestWindow&quot; Height=&quot;400&quot; Width=&quot;500&quot; WindowStyle=&quot;None&quot; WindowState=&quot;Maximized&quot;&gt; &lt;Window.Resources&gt; &lt;Style TargetType=&quot;&#123;x:Type Button&#125;&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;100&quot;/&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Column=&quot;0&quot; Content=&quot;1&quot; Name=&quot;Button1&quot;/&gt; &lt;Button Grid.Column=&quot;1&quot; Content=&quot;2&quot; Name=&quot;Button2&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; 2、原因和解决方法 2.1 原因 因为把 Button 默认样式放在了 ResourceDictionary.MergedDictionaries 内部的ResourceDictionary 内了，这样在解析引用样式的时候会跳过第一个元素； 2.2 解决方案 将 style 提到 ResourceDictionary.MergedDictionaries 之外 123456789101112131415161718&lt;Window.Resources&gt; &lt;ResourceDictionary&gt; &lt;ResourceDictionary.MergedDictionaries&gt; &lt;ResourceDictionary Source=&quot;Resources/AllResources.xaml&quot;/&gt; &lt;/ResourceDictionary.MergedDictionaries&gt; &lt;Style TargetType=&quot;&#123;x:Type Button&#125;&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;100&quot;/&gt; &lt;/Style&gt; &lt;/ResourceDictionary&gt;&lt;/Window.Resources&gt;&lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Column=&quot;0&quot; Content=&quot;1&quot; Name=&quot;Button1&quot;/&gt; &lt;Button Grid.Column=&quot;1&quot; Content=&quot;2&quot; Name=&quot;Button2&quot;/&gt;&lt;/Grid&gt; 参考链接：resources - WPF doesn't apply style to first element - Stack Overflow","categories":[{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/categories/WPF/"}],"tags":[{"name":".Net","slug":"Net","permalink":"https://buctllx.github.io/tags/Net/"},{"name":"C#","slug":"C","permalink":"https://buctllx.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/tags/WPF/"},{"name":"Style","slug":"Style","permalink":"https://buctllx.github.io/tags/Style/"}]},{"title":"Fist Blog","slug":"test-my-site","date":"2020-04-12T15:31:00.000Z","updated":"2022-03-17T01:46:37.447Z","comments":true,"path":"2020/04/12/test-my-site/","link":"","permalink":"https://buctllx.github.io/2020/04/12/test-my-site/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"}]},{"title":"Hello Hexo","slug":"hello-world","date":"2020-04-12T10:25:00.000Z","updated":"2022-03-16T10:34:54.800Z","comments":true,"path":"2020/04/12/hello-world/","link":"","permalink":"https://buctllx.github.io/2020/04/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"}]}],"categories":[{"name":"network","slug":"network","permalink":"https://buctllx.github.io/categories/network/"},{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Nginx","slug":"工具/Nginx","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/Nginx/"},{"name":"MVVM","slug":"工具/MVVM","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/MVVM/"},{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/categories/WPF/"},{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/categories/VisualStudio/"},{"name":"VisualStudio","slug":"工具/VisualStudio","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/VisualStudio/"},{"name":"windwos","slug":"windwos","permalink":"https://buctllx.github.io/categories/windwos/"},{"name":"web site","slug":"windwos/web-site","permalink":"https://buctllx.github.io/categories/windwos/web-site/"},{"name":"ftp server","slug":"windwos/ftp-server","permalink":"https://buctllx.github.io/categories/windwos/ftp-server/"},{"name":"Revit","slug":"Revit","permalink":"https://buctllx.github.io/categories/Revit/"},{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"},{"name":"PicGo","slug":"Hexo/PicGo","permalink":"https://buctllx.github.io/categories/Hexo/PicGo/"},{"name":"Termianl","slug":"Termianl","permalink":"https://buctllx.github.io/categories/Termianl/"},{"name":"PowerShell","slug":"Termianl/PowerShell","permalink":"https://buctllx.github.io/categories/Termianl/PowerShell/"},{"name":"Hexo Theme","slug":"Hexo/Hexo-Theme","permalink":"https://buctllx.github.io/categories/Hexo/Hexo-Theme/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://buctllx.github.io/categories/ElasticSearch/"},{"name":"Markdown","slug":"Markdown","permalink":"https://buctllx.github.io/categories/Markdown/"},{"name":"Git 相关","slug":"Git-相关","permalink":"https://buctllx.github.io/categories/Git-%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"network","slug":"network","permalink":"https://buctllx.github.io/tags/network/"},{"name":"Nginx","slug":"Nginx","permalink":"https://buctllx.github.io/tags/Nginx/"},{"name":"FileBrowsern","slug":"FileBrowsern","permalink":"https://buctllx.github.io/tags/FileBrowsern/"},{"name":"MVVM","slug":"MVVM","permalink":"https://buctllx.github.io/tags/MVVM/"},{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/tags/WPF/"},{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/tags/VisualStudio/"},{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"windwos","slug":"windwos","permalink":"https://buctllx.github.io/tags/windwos/"},{"name":"web site","slug":"web-site","permalink":"https://buctllx.github.io/tags/web-site/"},{"name":"ftp","slug":"ftp","permalink":"https://buctllx.github.io/tags/ftp/"},{"name":"Revit","slug":"Revit","permalink":"https://buctllx.github.io/tags/Revit/"},{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"},{"name":"PicGo","slug":"PicGo","permalink":"https://buctllx.github.io/tags/PicGo/"},{"name":"Termianl,PowerShell,Oh-My-Posh","slug":"Termianl-PowerShell-Oh-My-Posh","permalink":"https://buctllx.github.io/tags/Termianl-PowerShell-Oh-My-Posh/"},{"name":"Theme","slug":"Theme","permalink":"https://buctllx.github.io/tags/Theme/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://buctllx.github.io/tags/ElasticSearch/"},{"name":"ES","slug":"ES","permalink":"https://buctllx.github.io/tags/ES/"},{"name":"Typora","slug":"Typora","permalink":"https://buctllx.github.io/tags/Typora/"},{"name":"Git","slug":"Git","permalink":"https://buctllx.github.io/tags/Git/"},{"name":".Net","slug":"Net","permalink":"https://buctllx.github.io/tags/Net/"},{"name":"C#","slug":"C","permalink":"https://buctllx.github.io/tags/C/"},{"name":"Style","slug":"Style","permalink":"https://buctllx.github.io/tags/Style/"}]}