{"meta":{"title":"ConorLuo 博客","subtitle":"胆小认生，不易相处","description":"北京化工大学10级，从事工程建设行业开发，擅长.Net, Python。此为博客一枚。","author":"ConorLuo","url":"https://buctllx.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-12-20T05:54:39.000Z","updated":"2021-12-20T06:01:52.896Z","comments":false,"path":"tags/index.html","permalink":"https://buctllx.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-12-20T05:59:49.000Z","updated":"2021-12-20T06:01:59.580Z","comments":false,"path":"categories/index.html","permalink":"https://buctllx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库范式","slug":"数据库范式","date":"2023-03-07T08:18:40.000Z","updated":"2023-03-17T03:01:57.522Z","comments":true,"path":"2023/03/07/数据库范式/","link":"","permalink":"https://buctllx.github.io/2023/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/","excerpt":"国内绝大多数院校用的王珊的《数据库系统概论》这本教材，某些方面并没有给出很详细很明确的解释，与实际应用联系不那么紧密。本文将结合应用案例，介绍数据库方式的基本知识。","text":"国内绝大多数院校用的王珊的《数据库系统概论》这本教材，某些方面并没有给出很详细很明确的解释，与实际应用联系不那么紧密。本文将结合应用案例，介绍数据库方式的基本知识。 什么是数据库范式 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 范式来自英文Normal form，简称 NF。要想设计—个好的关系，必须使关系满足一定的约束条件，此约束已经形成了规范，分成几个等级，一级比一级要求得严格。满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入(insert)、删除(delete)和更新(update)操作异常。 按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩~~实际上你可以把它粗略地理解为： 一张数据表的表结构所符合的某种设计标准的级别。 就像家里装修买建材，最环保的是E0级，其次是E1级，还有E2级等等。 数据库范式也分为1NF，2NF，3NF，BCNF，4NF，5NF。一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。 数据库范式分类 目前关系数据库有六种范式： 第一范式（1NF） 第二范式（2NF） 第三范式（3NF） 巴斯-科德范式（BCNF） 第四范式(4NF） 第五范式（5NF，又称完美范式） 满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般来说，数据库只需满足第三范式(3NF）就行了。 数据库三大范式剖析 第一范式（1NF） 第一范式（1NF）的定义为：符合 1NF 关系中的每个属性都不可再分。 实际上，1NF是所有关系型数据库的最基本要求，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在RDBMS中已经存在的数据表，一定是符合1NF的。 第一范式强调每一列都是不可分割的原子数据项。 说到原子这个词，肯定有小伙伴就先到了原子性问题，其实这么想也是没有错的。那就让我带你们去剖析一下第一范式。 首先，我用Excel表格模拟数据库中的表，并在表中填入了一些数据。如下， [表 1] 学号 姓名 系名/系主任 课程名称 分数 1 张三 计算机 / 高主任 C 90 1 张三 计算机 / 高主任 Python 100 2 李四 计算机 / 高主任 Java 98 2 李四 计算机 / 高主任 C++ 95 3 王五 管理系 / 刘主任 会计 88 3 王五 管理系 / 刘主任 酒店管理 90 当看到系名/系主任这一列数据的时候感觉这并不合符我们数据库的设计理念，因为它完全可以拆分为两列的。 其实每一个人的思想中的已经有了这个范式要求的概念，只是你并不知道这个概念叫做第一范式。 表1 显然不遵循第一范式，那我们就把它修改一下，让其遵循第一范式的要求。如下， [表 2] 学号 姓名 系名 系主任 课程名称 分数 1 张三 计算机 高主任 C 90 1 张三 计算机 高主任 Python 100 2 李四 计算机 高主任 Java 98 2 李四 计算机 高主任 C++ 95 3 王五 管理系 刘主任 会计 88 3 王五 管理系 刘主任 酒店管理 90 我们再看看表2，依然存在一些问题： 每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——数据冗余过大 假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——插入异常 注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。 注２：码：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）。 假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——删除异常 假如张三转系到法律系，那么为了保证数据库中数据的一致性，需要修改两条记录中系与系主任的数据。——修改异常。 正因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。 第二范式（2NF） 第二范式（2NF）在关系理论中的严格定义这里就不多介绍，只需要了解2NF对1NF进行了哪些改进即可。其改进是， 2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。 接下来对这句话中涉及到的四个概念——“函数依赖”、“码”、“非主属性”、与“部分函数依赖”进行一下解释。 函数依赖 我们可以这么理解（但并不是特别严格的定义）：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。 也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。 例如，对于表3中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说姓名函数依赖于学号，写作 学号 → 姓名。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。表中其他的函数依赖关系还有如： 系名 → 系主任 学号 → 系主任 （学号，课名） → 分数 但以下函数依赖关系则不成立： 学号 → 课名 学号 → 分数 课名 → 系主任 （学号，课名） → 姓名 从“函数依赖”这个概念展开，还会有三个概念： 完全函数依赖 在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作：\\(X \\stackrel{F}{\\rightarrow} Y\\)。 例如： \\(学号 \\stackrel{F}{\\rightarrow} 姓名\\) \\((学号，课名) \\stackrel{F}{\\rightarrow} 分数\\)（注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定） 部分函数依赖 假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 ：\\(X \\stackrel{P}{\\rightarrow} Y\\)。 例如： \\((学号，课名) \\stackrel{P}{\\rightarrow} 姓名\\) 传递函数依赖 假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （感谢 @百达指出的错误，这里改为：『Y 不包含于 X，且 X 不函数依赖于 Y』这个前提），那么我们就称 Z 传递函数依赖于 X ，记作 ：\\(X \\stackrel{T}{\\rightarrow} Z\\)。 码 设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为候选码，简称为码。 在实际中我们通常可以理解为：假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为主码） 例如： 对于表3，（学号、课名）这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况） 非主属性 包含在任何一个码中的属性成为主属性。 例如： 对于表3，主属性就有两个，学号 与 课名。 终于可以回过来看2NF了。首先，我们需要判断，表3是否符合2NF的要求？ 根据2NF的定义，判断的依据实际上就是看数据表中是否存在非主属性对于码的部分函数依赖。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。判断的方法是： 第一步：找出数据表中所有的码。 第二步：根据第一步所得到的码，找出所有的主属性。 第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。 第四步：查看是否存在非主属性对码的部分函数依赖。 对于表3，根据前面所说的四步，我们可以这么做： 第一步： 查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。 查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。 …… 查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。 看起来很麻烦是吧，但是这里有一个诀窍，就是假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“完全函数依赖”）。 图4表示了表中所有的函数依赖关系： img 图4 这一步完成以后，可以得到，表3的码只有一个，就是（学号、课名）。 第二步： 主属性有两个：学号 与 课名 第三步： 非主属性有四个：姓名、系名、系主任、分数 第四步： 对于（学号，课名） → 姓名，有 学号 → 姓名，存在非主属性 姓名 对码（学号，课名）的部分函数依赖。 对于（学号，课名） → 系名，有 学号 → 系名，存在非主属性 系名 对码（学号，课名）的部分函数依赖。 对于（学号，课名） → 系主任，有 学号 → 系主任，存在非主属性 对码（学号，课名）的部分函数依赖。 所以表3存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。 为了让表3符合2NF的要求，我们必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“。模式分解的方法不是唯一的，以下是其中一种方法： 选课（学号，课名，分数） 学生（学号，姓名，系名，系主任） 我们先来判断以下，选课表与学生表，是否符合了2NF的要求？ 对于选课表，其码是（学号，课名），主属性是学号和课名，非主属性是分数，学号确定，并不能唯一确定分数，课名确定，也不能唯一确定分数，所以不存在非主属性分数对于码 （学号，课名）的部分函数依赖，所以此表符合2NF的要求。 对于学生表，其码是学号，主属性是学号，非主属性是姓名、系名和系主任，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。 图5表示了模式分解以后的新的函数依赖关系 img 图5 下面表示了表3模式分解以后新的数据 [学生选课表][专业学生表] 学号 课程名称 分数 1 C 90 1 Python 100 2 Java 98 2 C++ 95 3 会计 88 3 酒店管理 90 学号 姓名 系名 系主任 1 张三 计算机 高主任 1 张三 计算机 高主任 2 李四 计算机 高主任 2 李四 计算机 高主任 3 王五 管理系 刘主任 3 王五 管理系 刘主任 （这里还涉及到一个如何进行模式分解才是正确的知识点，先不介绍了） 现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？ 李小明转系到法律系 只需要修改一次李小明对应的系的值即可。——有改进 数据冗余是否减少了？ 学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进 删除某个系中所有的学生记录 该系的信息仍然全部丢失。——无改进 插入一个尚无学生的新系的信息。 因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进 所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性系主任对于码学号的传递函数依赖。为了能进一步解决这些问题，我们还需要将符合2NF要求的数据表改进为符合3NF的要求。 第三范式（3NF） 第三范式（3NF） 3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。 接下来我们看看表3中的设计，是否符合 3NF 的要求。 对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。 对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性系主任对于码学号的传递函数依赖，所以学生表的设计，不符合3NF的要求。。 为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式： 选课（学号，课名，分数） 学生（学号，姓名，系名） 系（系名，系主任） 对于选课表，符合3NF的要求，之前已经分析过了。 对于学生表，码为学号，主属性为学号，非主属性为系名，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。 对于系表，码为系名，主属性为系名，非主属性为系主任，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。。 新的函数依赖关系如图6 img 图6 新的数据表如表4 [学生选课表][学生系表][系表] 学号 课程名称 分数 1 C 90 1 Python 100 2 Java 98 2 C++ 95 3 会计 88 3 酒店管理 90 学号 姓名 系名 1 张三 计算机 1 张三 计算机 2 李四 计算机 2 李四 计算机 3 王五 管理系 3 王五 管理系 系名 系主任 计算机 高主任 计算机 高主任 计算机 高主任 计算机 高主任 管理系 刘主任 管理系 刘主任 现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？ 删除某个系中所有的学生记录 该系的信息不会丢失。——有改进 插入一个尚无学生的新系的信息。 因为系表与学生表目前是独立的两张表，所以不影响。——有改进 数据冗余更加少了。——有改进 结论 由此可见，符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。 BCNF 范式 要了解 BCNF 范式，那么先看这样一个问题： 若： 某公司有若干个仓库； 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作； 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。 那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？ 答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量 码：（管理员，物品名），（仓库名，物品名） 主属性：仓库名、管理员、物品名 非主属性：数量 ∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。 基于此关系模式的关系（具体的数据）可能如下表所示： 仓库名 管理员 物品名 数量 上海仓 张三 iPhone 7 30 上海仓 张三 iPad Air 40 北京仓 李四 iPhone 8 50 北京仓 李四 iPad Mini 60 好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作： 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。 如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。 从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。 造成此问题的原因：存在着主属性对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。 解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。 仓库（仓库名，管理员） 库存（仓库名，物品名，数量） 这样，之前的插入异常，修改异常与删除异常的问题就被解决了。 以上就是关于 BCNF 的解释。 参考： 如何理解关系型数据库的常见设计范式？ - 知乎 (zhihu.com) 函数依赖","categories":[{"name":"DB","slug":"DB","permalink":"https://buctllx.github.io/categories/DB/"},{"name":"基础知识","slug":"DB/基础知识","permalink":"https://buctllx.github.io/categories/DB/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://buctllx.github.io/tags/DB/"}]},{"title":"数据库基础知识","slug":"数据库基础知识","date":"2023-01-31T03:40:55.000Z","updated":"2023-03-07T08:17:37.479Z","comments":true,"path":"2023/01/31/数据库基础知识/","link":"","permalink":"https://buctllx.github.io/2023/01/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"每个工程师都应该了解的：数据库知识 数据库和编程语言一样，同样是软件工程师们的必争之地。今天我就和大家聊一些数据库相关的知识。 Uber 发表过一篇文章，宣布他们从 PostgreSQL 转到 MySQL 了。文章的内容很好，同时还科普了一些数据库索引和复制的基本常识。当时，我转给了一个朋友，朋友看了之后说：“哦，他们 2013 年才发了一篇文章说他们从 MySQL 转到 PostgreSQL 。”","text":"每个工程师都应该了解的：数据库知识 数据库和编程语言一样，同样是软件工程师们的必争之地。今天我就和大家聊一些数据库相关的知识。 Uber 发表过一篇文章，宣布他们从 PostgreSQL 转到 MySQL 了。文章的内容很好，同时还科普了一些数据库索引和复制的基本常识。当时，我转给了一个朋友，朋友看了之后说：“哦，他们 2013 年才发了一篇文章说他们从 MySQL 转到 PostgreSQL 。” 我找来朋友提到的那篇旧文，读过之后，大概理解了两篇转型文章背后的原因。 作为两大主流开源数据库，MySQL 和 PostgreSQL 的 “战争” 从未停止，虽然硝烟不如编程语言那么浓烈，但也是你来我往，剑影刀光。 如果去 Quora 或者 Stack Overflow 上搜索 MySQL V.S. PostgreSQL 这样的关键字，会出现一大堆帖子，大家各执一词众说纷纭，我的感觉则是：两者各有各的优势和使用场景，并不存在一种数据库对另一种压倒性优势。 对于大部分程序员来说，公司用哪个数据库，基本无需你去决定。加入一个公司的时候，除非是创业公司，或者你是 CTO、VP、总监级别的，否则大部分的技术选型早已应该尘埃落定。 尤其是数据库，一旦选择，再迁移的代价非常大。因此，除非有颠覆性的优势或者难以克服的问题，很少有公司会去费时费力做这种大的迁移。 不论是技术选型还是技术转型，其中不可忽略的因素是：你的工程师更容易驾驭哪一种技术，或者有话语权的决策者们倾向于哪一种技术。这一点其实和程序语言的选型有异曲同工之处。 类似 Uber 两次高调转型的事情，在我曾经工作过的 Square 公司也发生过。 Square 最早使用的是 MySQL，到了 2012 年，由于 PostgreSQL 的各种优势越来越突出 —— 比如对地理空间（Geospatial）数据和搜索的支持，当时几位资深工程师也开始大力倡导，很多新的服务就尝试性地使用 PostgreSQL。 那时候，公司的架构是 MySQL 和 PostgreSQL 并存的。对于我而言，这就有机会学习、掌握和比较两种不同的技术。 在我来看，两者各有特点，有些技术实现在 MySQL 里更方便一点，另一些则反之。无论哪种数据存储方式，总有方案可以解决问题，并没有觉得非要哪一种才行。 一个公司如果数据库从来不出问题，那一定是因为没有业务量或者流量。所有技术的选型和设计，都有它的应用场景，除去那些让人开心的案例，剩下的毫无疑问就是坑。 如何尽可能地避开这些坑，如何在出现问题的时候可以用最快的速度去修复，这些都是至关重要的因素。 大部分工程师并不是数据库专家，在 Square 公司两种数据库并存的期间，PostgreSQL 的牛人寥寥无几，但是 MySQL 却有几个专家是极为靠谱的。对我们而言 ，PostgreSQL 和 MySQL 的相对优势，都比不过出问题的时候有人救火和解惑来的重要。 另外，一个公司维系两套同类的数据库系统本身就是个负担，因为这些原因，那些使用 PostgreSQL 的服务慢慢就转成了 MySQL 。 我们支付类的技术工作需要强事务和一致性的支持，所以 NoSQL 类型的数据库用得比较少，主要使用的是 MySQL 或者 PostgreSQL。由于在工作中常常与数据库打交道，我也逐渐了解到不少相关的知识和技术，但是线上真的出了问题，我还是没有把握自己去搞定。 好在，每个公司都会有一些专攻数据库的大牛，这种专门的职位便是 DBA，有的中小创业公司没有专职 DBA，数据库便由做运维的人维护。我和几位这样的牛人私交甚好，加之平时自己处理起系统中出现的相关问题，也会常常请教他们，一来二去就知道了很多有趣的数据库知识。 对数据库专家我一向是敬佩的态度，他们的价值不可小觑。公司只要稍具规模，如果数据库这块做不好，基本也就没什么可玩的了。数据库可以说是互联网公司最宝贵的资产，这块不出问题也罢，一出问题，即是见血封喉，服务直接宕机。 关于数据库，最常见的问题都有哪些呢？ 第一个是选型 因为每个公司的业务不同，数据库系统的应用场景不一样，选型也会不尽相同，但可以肯定的是，没有哪个系统一定是最好的。 比如做支付业务一定要强事务性、一致性的支持，很多社交平台更多时候需要的是高可用；有的业务写操作特别重，有的业务更重要的是读操作；有的业务可能只关心最近几天的数据，于是可以容忍老数据读写的低效，有的却要频频访问历史数据，需要读写的高效；有的业务可以通过加索引解决查询效率，有的却只能通过加缓存等等。 这就是为什么很多公司会选择多个数据库系统并存，通过不同的技术和架构给予相关的业务场景最优支持。如果一旦选型失误，便不会有频频踩坑一说，因为这基本就算直接掉进了坑里。 第二个是数据库相关的架构 什么意思呢？这里的架构包括数据库上层的缓存系统设计，程序语言对数据库连接的处理，代理层（Proxy Layer）的功能，以及和二进制日志（Binlog）等相关的数据管道（Data Pipeline）的搭建。当然，其中也包括了数据库系统的分区、备份等的具体设计。 很多公司早期所有的表都在一个数据库里面，因为各种连接池（Connection Pool）和吞吐量（Throughput）的限制，基本没法做扩展。能够合理地设计数据库表的分离，把数据相关的放在一起，不那么相关或甚至不相关的放在另一个数据库里。这些看起来很简单的做法，很多时候却可以很大程度上缓解可扩展的问题。 第三个，也是我们平时遇到最多问题的：人为错误 再好的系统，使用姿势不对也是枉然，更何况并不是所有的工程师都是数据库专家，所以人为的错误是最常出现的问题。 人为错误分成两种。 一种是操作数据库时犯的错误。另一种是程序员在程序里或者脚本里犯的错误。 操作数据库时犯的错误的概率比较低，但危害却最大。几乎所有的公司都会有类似的传奇时间，我听过的就有三种误操作的版本。 第一种是工程师无意或有意，“不小心” 删掉了数据库核心表中所有的数据。这不是段子，在 Facebook 就曾经发生过类似的事情，当事人还是我的一个朋友，好在后来恢复了，这事儿便也成了他的工程师历史上光辉的一笔。 第二种工程师在线修改表结构（ online schema change ）的时候，不小心一步误操作，结果数据库被锁（ Lock ）长达几个小时，该公司网站也就挂了好几个小时。 第三种是听国内一个大公司的朋友说的，细节还已经无法还原。只记得听说他们的两台服务器，在做主从切换的时候，拔错了一个电源插头，然后……就没有下文了。 程序员在程序里或者脚本里犯的错误就很常见了。 举个简单的例子，我们知道 Ruby on Rails 对数据库的操作基本是通过 Active Record 来完成的。Active Record 可以通过一个数据库连接池来限制每个应用到数据库的连接。 如果某一个程序或者脚本查询没有索引的数据，导致全表扫描，再加上一些网页服务器（Web Server）的并行访问，经常会有整个数据库的所有链接被占用的情况，连终止查询（Kill Query ）都没法执行，只能人肉去做一些类似重启的物理操作。还有更常见的，就是程序里的 N+1 查询问题。面对这类问题，可以使用数据库的连接查询功能，比如 left outer join 来避免 N+1 的问题。 最后一个是数据库访问瓶颈 只要是数据库，就有吞吐量的限制，而数据库访问瓶颈便是自然流量增长或者流量突增造成的。只要你的业务在增长，总有一天数据库访问就会达到一个上限。在这个预警到来前，你需要做各种垂直或水平扩展来提升这个上限，或者，你可以通过缓存和其他机制来对访问量进行分流，这里面可以做的工作就多了。 流量的突增一般是类似分布式拒绝服务（DDoS）或市场活动带来的，也可能是因为某个黑天鹅事件造成的，这些原因都很难预料。 如果是有计划的市场活动，就需要提前做好各种战斗准备。如果是恶意攻击，那就只能靠各种防御工程，如 IP 阻塞（IP Blocking）或者第三方的高防系统挡掉这些流量来保证数据库的正常工作。 研发过程中，有哪些与数据库相关的问题呢？ 我们以 MySQL 为例，讲讲日常开发中应该注意的，与数据库相关的问题。 索引 创建索引通常是为了提高常用查询语句的性能，将某些列以特定的数据结构（常见的如 B-Tree）有序存储起来。维持这样的一个数据结构在写数据的时候会有一些系统开销 （Overhead）。但如果查询确实是高频的，那么这样的系统开销就很划算。在建表时需要考虑所有可能的高频查询，另一方面，忌讳过度地“为未来设计 ”(Design for the Future)，也就是加一堆可能根本不常用的索引，反而增加了写数据时候的成本和负担。 索引另一个常见的用途就是保证某一列或者某几列的组合是唯一的（ Unique ），这也称为唯一性索引（Unique Indexing），在写业务逻辑代码的时候会常常用到。 比如你有一个用户表（ User Table )，你想让所有用户（ User ）的电子邮件都是唯一的，这个时候用唯一索引（ Unique Indexing ）就很方便。不过唯一索引（ Unique Indexing ）和可选列（ Optional Column ）组合在一起的时候，也有很多需要注意的地方。 比如，你想对列 X 做唯一索引（Unique Index Column X），过了一段时间，也许有些情况下列 X（Column X）并不唯一，我们便把索引改成了对列 X 和列 Y 作唯一索引（ Unique Index Column X + Column Y），但是列 Y（Column Y）是 Nullable 的。 这个时候会出现什么情况呢？ 你会有多条记录，有着一样的 X 值，以及 Null 的 Y 值。很意外对吧，原因就是 Null 在数据库里常常解释为 “不确定” 而不是空。 事务支持 还有一个比较重要的问题就是数据库的事务支持（Transactional Support）。简单说来，就是利用数据库本身提供的事务性，来封装一系列需要同时完成的动作。 比如在一段事务里面，先执行 X，再执行 Y (Transaction do X；Y；end)，如果 X 和 Y 都是数据库写操作，那要么两个写操作都成功，要么都失败。也就是说，对数据库的改动会统一把事务所做的修改提交到数据库（ Commit），而提交（ Commit ）前的任何错误都会触发所有更新回滚到开始的状态（ Rollback ）或引发不正常进程的终止 （ Abort ）。 虽然正确使用事务支持（ Transactional Support ）会很方便，但是也常常见到过度使用让代码变得很脆弱甚至是出现 Bug 的情况。 常见的几种情况如下。 事务（Transaction ）中封装的代码逻辑太长太复杂，甚至调用了别的函数。很多时候，很难去推理当执行中抛出异常的话，到底哪些会回滚，哪些会产生遗留影响。 事务中封装了与数据库改动无关的逻辑。 事务中有不可逆的操作，例如发送电子邮件给用户，发布（Publish）到一个 Job 队列（Queue）等。这种情况会导致系统的不一致。比如，一个写操作被回滚了，但这条数据相关的 Job 还是被加入到队列了，就会引发错误。 事务中包括了在不同数据库里面的事务，也就是分布式事务，这需要单独处理。 事务中嵌套了事务，不同情况可能会有不同的结果，如果没搞清楚，就可能出现意外的行为。 更多情况就不一一列举了，但过度使用事务支持往往会让逻辑变得不必要的复杂。 数据库锁 数据库会出现 Race Condition，我们常常把 Race Condition 叫做竞争条件，是指多个进程或者线程并发访问和操作同一数据，且执行结果与访问发生的特定顺序有关的现象。 如何解决竞争条件（ Race Condition ）呢？常见的方法是使用各种锁机制来确保行为的可预测性和正确性。根据实际情况的不同，加锁的方式会不一样。 常见的有乐观锁定（ Optimistic Locking ）和悲观锁定（ Pessimistic Locking）。总的说来，前者在对性能要求比较高的系统里更为常见。在实际应用中，很多系统都会自己实现锁定（ Locking ）机制。 缓存和主从机制 为了提高性能，我们会为数据库增加缓存（ Caching ）和主从（ Master - Slave ）等机制，这有时候会引起数据的不一致性。常见的情况是，如果系统默认是在从节点（ Slave ）读数据，那么一些刚刚更新到主节点（ Master ）的数据在读的时候就有可能读不到。这个情况在使用一些数据关联 （Association）的时候更容易读不到。Rails 的 Active Record 数据关联 （Association），就很容易出现这一类的问题。 今天跟大家介绍了不少数据库相关的基础知识，如果你是个软件工程师，想必这些内容都已经耳熟能详，我们来总结一下。 本文从 MySQL 和 PostgreSQL 的迁移和选型入手，介绍了数据库的技术特点和选型问题。在我眼里，没有更好的技术，只有更适合的技术。 数据库领域会碰到哪些问题呢？我为大家介绍了数据库选择、数据库相关的架构问题、人为失误的问题，还有数据库遭遇流量瓶颈以及相关的应对方式。 几乎每个工程师在编程的时候都会和数据库打交道，研发过程中我们应该注意什么问题呢？在这个章节我们讲了索引、事务支持、数据库锁、缓存和主从机制。 文中每个点都可以深入展开，独自梳理，最终形成系统的知识储备。因为篇幅所限，不能涉及所有的技术细节，文中提到的内容都是我在工作中遇到过的问题和实战经验，希望对你有帮助。 如果你有不同的想法，更好的观点，请在留言中告诉我，互通有无，一起成长。 参考链接：https://eng.uber.com/mysql-migration/","categories":[{"name":"DB","slug":"DB","permalink":"https://buctllx.github.io/categories/DB/"},{"name":"基础知识","slug":"DB/基础知识","permalink":"https://buctllx.github.io/categories/DB/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://buctllx.github.io/tags/DB/"}]},{"title":"MongoDB 索引","slug":"MongoDB-索引","date":"2022-07-18T07:27:15.000Z","updated":"2023-01-31T05:42:00.935Z","comments":true,"path":"2022/07/18/MongoDB-索引/","link":"","permalink":"https://buctllx.github.io/2022/07/18/MongoDB-%E7%B4%A2%E5%BC%95/","excerpt":"","text":"MongoDB 索引 在 MongoDB 中设置索引，主要是为了增加查询效率； 没有设置索引，MongoDB 在查询数据的时候执行的是：扫描整个集合 Collection，在数据量不大的时候没有问题，一旦数据量增加到一定程度后，查询耗时就会很高，导致查询效率变低。 简单索引 123456789# 1. 方法createIndex()# 2. 样例（单字段索引）db.collection.createIndex(keys, options)testdb.student.createIndex(&#123;&quot;code&quot;:1&#125;)# 3. 设置使用多个字段创建索引（关系型数据库中称作：联合索引）db.col.createIndex(&#123;&quot;id&quot;:1,&quot;code&quot;:-1&#125;) 在嵌入字段上创建索引 您可以对嵌入文档中的字段创建索引，就像可以为文档中的顶级字段编制索引一样。嵌入字段上的索引不同于嵌入文档上的索引，后者包括索引中嵌入文档的最大索引大小的完整内容。相反，嵌入字段上的索引允许您使用“点表示法”来自省嵌入的文档。 请考虑一个名为 的集合，该集合保存类似于以下示例文档的文档：records 12345&#123; &quot;_id&quot;: ObjectId(&quot;570c04a4ad233577f97dc459&quot;), &quot;score&quot;: 1034, &quot;location&quot;: &#123; state: &quot;NY&quot;, city: &quot;New York&quot; &#125;&#125; 以下操作将在字段上创建索引：location.state 1db.records.createIndex( &#123; &quot;location.state&quot;: 1 &#125; ) 创建的索引将支持在字段上选择的查询，如下所示：location.state 12db.records.find( &#123; &quot;location.state&quot;: &quot;CA&quot; &#125; )db.records.find( &#123; &quot;location.city&quot;: &quot;Albany&quot;, &quot;location.state&quot;: &quot;NY&quot; &#125; ) 在嵌入文档上创建索引 还可以在整个嵌入文档上创建索引。 请考虑一个名为 record 的集合，该集合保存类似于以下示例文档的文档：records 12345&#123; &quot;_id&quot;: ObjectId(&quot;570c04a4ad233577f97dc459&quot;), &quot;score&quot;: 1034, &quot;location&quot;: &#123; state: &quot;NY&quot;, city: &quot;New York&quot; &#125;&#125; 该字段是嵌入的文档，包含嵌入的字段和 。以下命令在整个字段上创建索引：location city state location 1db.records.createIndex( &#123; location: 1 &#125; ) 以下查询可以使用字段上的索引：location 1db.records.find( &#123; location: &#123; city: &quot;New York&quot;, state: &quot;NY&quot; &#125; &#125; ) 注意 尽管查询可以使用索引，但结果集不包括上面的示例文档。对嵌入的文档执行相等匹配时，字段顺序很重要，嵌入的文档必须完全匹配。有关查询嵌入文档的详细信息，请参阅查询嵌入文档。 其他注意事项 在索引生成期间，应用程序可能会遇到性能降低的问题，包括对集合的有限读/写访问权限。有关索引生成过程的详细信息，请参阅填充集合上的索引生成，包括复制环境中的索引生成部分。 某些驱动程序可能指定索引，使用而不是用作规范。这对生成的索引没有任何影响。NumberLong(1)``1 高级索引","categories":[{"name":"DB","slug":"DB","permalink":"https://buctllx.github.io/categories/DB/"},{"name":"MongoDB","slug":"DB/MongoDB","permalink":"https://buctllx.github.io/categories/DB/MongoDB/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://buctllx.github.io/tags/DB/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://buctllx.github.io/tags/MongoDB/"}]},{"title":"AEC Ifc 结构学习","slug":"AEC-Ifc-结构学习","date":"2022-04-14T09:05:20.000Z","updated":"2022-04-14T11:17:47.245Z","comments":true,"path":"2022/04/14/AEC-Ifc-结构学习/","link":"","permalink":"https://buctllx.github.io/2022/04/14/AEC-Ifc-%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/","excerpt":"[AEC（建筑、工程和施工行业）_百度百科 (baidu.com)](https://baike.baidu.com/item/AEC/22376679?fr=aladdin) Industry Foundation Classes (IFC) - buildingSMART Technical IFC 文件是一种开放的、非专有的文件格式，国际标准 ISO 16739，可用于在设计、施工、运行和维护阶段，在所有图形和不同软件开发的各种应用程序之间交换和共享数据房屋，而无需它们支持本机（专有）文件。","text":"[AEC（建筑、工程和施工行业）_百度百科 (baidu.com)](https://baike.baidu.com/item/AEC/22376679?fr=aladdin) Industry Foundation Classes (IFC) - buildingSMART Technical IFC 文件是一种开放的、非专有的文件格式，国际标准 ISO 16739，可用于在设计、施工、运行和维护阶段，在所有图形和不同软件开发的各种应用程序之间交换和共享数据房屋，而无需它们支持本机（专有）文件。 1 IFC 简介 Industry Foundation Classes (IFC) - buildingSMART Technical BuildingSmart 官方网站已经给出了英文版的定义和说明；这里简单翻译一下： IFC 架构以一种标准换的数据模型去组织数据 这些数据包含：人员、实体、属性、特征、关系、过程、抽象概念等 简单来说：就是以计算机编程面向对象的方法去定义了一套数据结构 IFC 可以定义建筑物、制成品、机械/电气系统的物理组成部分；同时也能定义：抽象的结构分析模型、能源分析模型、成本分解、工作计划等等。通过这套架构规范还可以描述如何使用设施和安装、如何构建、以及如何操作。 当然，IFC 不是一次就定义好的，它的定义是一个不断完善发展的过程，因此，存在多个版本。 主流的有：IFC2x3 和 IFC4 这里可以看到所有的版本定义：IFC Schema Specifications - buildingSMART Technical 1.1 IFC 可以用来做什么 简单来说有两点 数据交换 文件数据归档 1.2 谁来使用 前面说了 IFC 是使用计算机面向对象的方式定义的一套数据结构； 因此不难看出，IFC 的使用者肯定和软件开发相关，事实也是这样的。使用 IFC 的就是那些各种各样的软件公司开发的各种软件。每个软件都有自己的数据格式，但是一旦涉及到数据交换或者传递，他们都会选择一种通用的标准格式，这个格式就是 IFC。 Software Implementations - buildingSMART Technical 这里列出了使用 IFC 的各种软件。 1.3 IFC 文件格式 IFC Formats - buildingSMART Technical IFC 文件只是广义上的一种统称，实际上，按照不同的数据格式可以划分成不同的文件格式。 简单来说：IFC 只是定义了一套数据结构，至于如何去描述这套数据结构可以使用不同的数据格式，比如说：xml，json，等。至于如何去选择，通常有以下几个方面的考虑： 软件的支持度 可扩展性 可读性 数据量是否很大 1.3.1 Official 官方的 Format Extension MIME Type Text Indexed Size Summary STEP Physical File (SPF) .ifc application/x-step Yes No 100% STEP 物理格式（SPF 或 IFC-SPF）是 IFC 在实践中使用最广泛的格式，它是列出的可以作为文本读取的格式中最紧凑的格式。 IFC-SPF 基于用于 EXPRESS 数据模型的明文表示的 ISO 标准 ISO 10303-21 Extensible Markup Language (XML) .ifcXML application/xml Yes No 113% 可扩展标记语言 (XML) 提供了增强的可读性并从广泛的软件工具中受益。 ifcXML 基于用于以 XML 格式 ISO 10303-28 表示 STEP 数据的 ISO 标准 ISO 10303-28 ZIP .ifcZIP application/zip No No 17% IFC 数据可能嵌入在 ZIP 文件中。嵌入的数据可以编码为 SPF 或 XML，其中生成的大小通常是可比较的。 Terse RDF Triple Language (Turtle) .ttl based on ifcOWL text/turtle Yes No 1372% More info on: ifcOWL Resource Description Framework (RDF/XML) .rdf based on ifcOWL application/rdf+xml Yes No 816% More info on: ifcOWL 1.3.2 临时/候选的 Format Extension MIME Type Text Indexed Size Summary JSON .json application/json Yes No 148% JSON 通过广泛的软件工具提供增强的可读性和优势。 Hierarchical Data Format (HDF) .hdf application/x-hdf No Yes n/a HDF5 可以将 IFC 数据存储在分层数据库中，从而提供对工程数据的高性能访问。 HDF 基于用于 STEP 数据表示的 ISO 标准 ISO 10303-26 1.3.3 实验/不受支持的 Format Extension MIME Type Text Indexed Size Summary SQLite .sqlite application/x-sqlite3 No Yes n/a SQLite 可以将 IFC 数据存储在关系数据库中，该数据库提供对大型模型中数据的索引访问，并受益于广泛的软件工具。 1.4 如何打开 IFC 文件 从上面可以看出，IFC 文件有多种格式。可以分为：文本类和非文本类； 如果你只是想看看数据，那么针对文本类的，你可以使用任何文本编辑器查看即可； 非文本类的就需要借助专业的软件来查看，比如说：专业的设计软件，或者数据库软件等； 2 IFC 数据结构说明 因为 IFC 定义了很庞大的一套数据架构，这里仅仅挑选与建筑设计相关的核心主要的数据结构定义进行说明 其他的如果有兴趣可以在官方文档查看 IFC Schema Specifications - buildingSMART Technical 同时为了便于说明，本文以 IFC2x3 版本进行说明。 Start Page of IFC2x3 Final Documentation (buildingsmart.org) IFC 数据定义基于 3 个基本概念：他们的父类都是 IFCRoot（一个抽象类） IfcObjectDefinition 定义实体本身（对象） IfcRelationship 定义实体之间的关系 IfcPropertyDefinition 定义与实体相关的属性。 image-20220414182909999 IfcRoot 是底层的抽象类，不能直接实例化， 他包含了一些基本信息： 名称 类型 说明 GlobalId IfcGloballyUniqueId 软件系统内部的全局唯一 Id OwnerHistory IfcOwnerHistory 分配有关该对象的当前所有权的信息，包括拥有参与者，应用程序，本地标识和捕获的有关对象最近更改的信息，注意：仅存储最后一次修改。 Name OPTIONAL IfcLabel; 名称 Description OPTIONAL IfcText; 描述说明 2.1 IfcObjectDefinition image-20220414184453314 这是 IFC 实体对象的基类，UML 类图如上； 主要定义了两类信息：实体和实体类型 IfcObject IfcTypeObject 2.1.1 IfcObject 包含了7个子类 image-20220414184923892 IfcActor 定义了所有参与施工过程中的角色。它可以轻松识别参与者，并包含姓名、地址、组织和角色等信息 IfcControl 是控制或限制一般产品、过程或资源使用的所有概念的抽象概括。因此，它代表了设计约束。例如，在这个类中，我们可以包含影响项目规划的元素 IfcGroup 是任意群的推广。组是对象的逻辑集合，它没有自己的位置，也不能包含自己的形状表示。因此，一个群是一个拓扑聚合。例如，我们可以将一组结构框架的元素关联到一个组中，这些元素根据特定方向翘曲。 IfcProcess 代表随时间发生的活动，事件和程序。在IfcProcess 被定义为一个单一的活动或事件 IfcResource 包含表示成本、计划和其他过程中使用资产的影响所需的信息。例如，出于成本估算的目的，目前未在 IFC 中建模的建筑设备（如车辆或土方机械）可被视为 IfcResource. IfcProduct 包括可以涉及一种几何/空间上下文的任何实体。当每个实体分配了几何表示时，它在空间中都有一个特定的位置。这种表示可以相对于其他实体来表达，但它肯定会相对于项目坐标系进行引用。除了真实的实体，IfcProduct 还包括非物理元素，例如网格、注释、结构动作。 IfcProject 定义了一个项目 与建模直接相关的其实只有：IfcProduct、IfcGroup、IfcProject；其中最主要的两个概念是前两个，我们这里主要说明； 2.1.1.1 IfcProduct 这里我们只介绍红框里的核心数据定义 image-20220414190000756 IfcElement 基本对象（具有物理形体的） IfcBuildingElement 建筑对象实体定义 IfcWall IfcWallStandardCase（基本墙） IfcDoor …… IfcBeam IfcGrid 轴网信息（定位使用） IfcPort 端口信息 IfcSpatialStructureElement（空间对象） 建筑空间 楼层空间 场地 一般空间 2.1.1.2 IfcGroup IfcGroup 定义了一组对象逻辑上的集合；他没有自己的位置、几何形体信息； image-20220414191115155 从上面的信息可以看出：一些系统可以形成一个组，一些分析模型可以形成一个组，一些空间 Space 可以形成一个区域 Zone 等等 2.1.2 IfcTypeObject IfcTypeObject 主要用于描述 IfcObject 的类型信息，基本继承结构和 IfcObject 非常类似 image-20220414190933933","categories":[{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"IFC","slug":"工具/IFC","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/IFC/"}],"tags":[{"name":"IFC","slug":"IFC","permalink":"https://buctllx.github.io/tags/IFC/"},{"name":"BIM","slug":"BIM","permalink":"https://buctllx.github.io/tags/BIM/"}]},{"title":"Maven 使用方法","slug":"Maven-使用方法","date":"2022-03-29T05:29:13.000Z","updated":"2022-03-29T10:09:36.645Z","comments":true,"path":"2022/03/29/Maven-使用方法/","link":"","permalink":"https://buctllx.github.io/2022/03/29/Maven-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"Maven是一个 Java 项目管理和构建的工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是 Java 项目不可缺少的工具。 本文主要介绍 Java 包管理工具 Maven 的一些使用方法，主要参考了下面的一些资料。 Maven基础 - 廖雪峰的官方网站 (liaoxuefeng.com)","text":"Maven是一个 Java 项目管理和构建的工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是 Java 项目不可缺少的工具。 本文主要介绍 Java 包管理工具 Maven 的一些使用方法，主要参考了下面的一些资料。 Maven基础 - 廖雪峰的官方网站 (liaoxuefeng.com) 在 Java 开发过程中，很多时候我们会用到第三方封装好了的功能模块，这些功能都是以 jar 包的形式存在的，首先，我们需要确定引入哪些依赖包。例如，如果我们需要用到 commons logging，我们就必须把 commons logging 的 jar 包放入classpath。如果我们还需要 log4j，就需要把 log4j 相关的 jar 包都放到 classpath 中。这些就是最简单的依赖包的管理。现实使用过程中远比这要复杂，因为 log4j 可能有依赖了其他的 jar 包，或者有多个 jar 包都依赖某个 jar 包，甚至有不同的版本的要求； 因此仅仅靠人为管理这些 jar 包，在项目开发中也是一件复杂、繁琐、耗时的事情，这时候就需要有一个工具，帮我们管理这些 jar 包，因此 Maven 就出现了。 Maven就是是专门为Java项目打造的管理和构建工具，它的主要功能有： 提供了一套标准化的项目结构； 提供了一套标准化的构建流程（编译，测试，打包，发布……）； 提供了一套依赖管理机制。 从上面可以看出来：Maven 不仅仅是包管理的那么简单，他还可以定义我们 Java 项目的文件结构，甚至干预自动化构建的过程。下面我们会一一展开来讲。 1. Maven 安装 要安装 Maven，可以从 Maven 官网 下载最新的Maven 3.6.x，然后在本地解压，设置几个环境变量： 12M2_HOME=/path/to/maven-3.6.xPATH=$PATH:$M2_HOME/bin Windows可以把%M2_HOME%\\bin添加到系统Path变量中。 然后，打开命令行窗口，输入mvn -version，应该看到Maven的版本信息： 123456789101112131415┌────────────────────────────────────────────────────────┐│Command Prompt - □ x │├────────────────────────────────────────────────────────┤│Microsoft Windows [Version 10.0.0] ││(c) 2015 Microsoft Corporation. All rights reserved. ││ ││C:\\&gt; mvn -version ││Apache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918...) ││Maven home: C:\\Users\\liaoxuefeng\\maven ││Java version: ... ││... ││C:\\&gt; _ ││ ││ │└────────────────────────────────────────────────────────┘ 如果提示命令未找到，说明系统PATH路径有误，需要修复后再运行。 1.1 IDEA 中的 Maven 在 IDEA 的设置中搜索 Maven 可以看到以下设置信息： image-20220329140137485 这里我们看出来，新版的 IDEA 默认包含了 Maven 工具，具体路径和用户的安装路径有关，这里列出来我的安装路径： 12D:\\Program Files\\JetBrains\\IntelliJ IDEA 2021.3.3\\plugins\\maven\\lib\\maven3\\binD:\\Program Files\\JetBrains\\IntelliJ IDEA 2021.3.3\\plugins\\maven\\lib\\maven3\\conf\\settings.xml 2. Maven 项目结构 一个使用 Maven 管理的普通的 Java 项目，它的目录结构默认如下： 12345678910a-maven-project├── pom.xml├── src│ ├── main│ │ ├── java│ │ └── resources│ └── test│ ├── java│ └── resources└── target a-maven-project是项目名（项目的根目录）， pom.xml是项目描述文件 src/main/java是存放Java源码的目录， src/main/resources是存放资源文件的目录， src/test/java是存放测试源码的目录， src/test/resources是存放测试资源的目录， target目录里存放的是最后，所有编译、打包生成的文件 这些就是一个Maven项目的标准目录结构。所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven就可以正常使用。 这里先说明，最重要的是 pom.xml 文件，后面我们会重点介绍。 3. pom.xml 文件说明 POM 全称是 Project Object Model，即项目对象模型。 pom.xml 文件以 xml 的形式描述项目的信息，包括项目名称、版本、项目id、项目的依赖关系、编译环境、持续集成、项目团队、贡献管理、生成报表等等。总之，它包含了所有的项目 信息。 我们再来看一个最简单的项目描述pom.xml文件，它的内容长得像下面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- lookup parent from repository --&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;ifc_file_parser&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;ifc_file_parser&lt;/name&gt; &lt;description&gt;ifc_file_parser&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;mysql&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt;&lt;!-- &lt;scope&gt;runtime&lt;/scope&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; modelVersion 描述这个POM文件是遵从哪个版本的项目描述符。 groupId 针对一个项目的普遍唯一识别符。通常用一个完全正确的包的名字来与其他项目的类似名字来进行区分（比如：org.apache.maven)。 artifactId 在给定groupID 的group里面为artifact 指定的标识符是唯一的 ， artifact 代表的是被制作或者被一个project应用的组件(产出物)。 version 当前项目产生的 artifact 的版本 以上4个元素缺一不可，其中 groupId、artifactId、version 是描述依赖的项目唯一标志。 3.1 基本信息 在 project 节点内部，一般用于描述项目的名称，id，版本，等基础信息，如下: 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;ifc_file_parser&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;ifc_file_parser&lt;/name&gt; &lt;description&gt;ifc_file_parser&lt;/description &lt;name&gt;...&lt;/name&gt; &lt;description&gt;...&lt;/description&gt; &lt;url&gt;...&lt;/url&gt; &lt;inceptionYear&gt;...&lt;/inceptionYear&gt; &lt;licenses&gt;...&lt;/licenses&gt; &lt;organization&gt;...&lt;/organization&gt; &lt;developers&gt;...&lt;/developers&gt; &lt;contributors&gt;...&lt;/contributors&gt; &lt;/project&gt; 3.2 继承信息（模块管理） 在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法： 在 pom 文件中，可以通过 标签描述项目的继承信息，这样可以把多个项目相同部分的描述信息放在一起作为公共基础描述 pom 文件；然后在其他子项目的 pom 文件中通过 标签继承 公共通用的项目设置信息。 具体操作如下： 1234567891011 ┌ ─ ─ ─ ─ ─ ─ ┐ ┌─────────┐ │ │Module A │ │ └─────────┘┌──────────────┐ split │ ┌─────────┐ ││Single Project│───────&gt; │Module B │└──────────────┘ │ └─────────┘ │ ┌─────────┐ │ │Module C │ │ └─────────┘ └ ─ ─ ─ ─ ─ ─ ┘ 对于Maven工程来说，原来是一个大项目： 123single-project├── pom.xml└── src 现在可以分拆成3个模块： 12345678910mutiple-project├── module-a│ ├── pom.xml│ └── src├── module-b│ ├── pom.xml│ └── src└── module-c ├── pom.xml └── src Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的pom.xml。例如，模块A的pom.xml： 模块A`pom.xml`文件模块B`pom.xml`文件12345678910111213141516171819202122232425262728293031323334353637383940&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;module-a&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;module-a&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;12345678910111213141516171819202122232425262728293031323334353637383940&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;module-b&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;module-b&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 可以看出来，模块A和模块B的pom.xml高度相似，因此，我们可以提取出共同部分作为parent： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;parent&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 注意到 parent pom.xml 中的&lt;packaging&gt;是pom而不是jar，因为parent本身不含任何Java代码。编写parent的pom.xml只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下： 12345678910111213multiple-project├── pom.xml├── parent│ └── pom.xml├── module-a│ ├── pom.xml│ └── src├── module-b│ ├── pom.xml│ └── src└── module-c ├── pom.xml └── src 这样模块A就可以简化为： 12345678910111213141516&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;parent&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;module-a&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;module-a&lt;/name&gt;&lt;/project&gt; 如果想看项目(父或子)的完全的pom结构，可以运行： 1mvn help:effective-pom 模块B、模块C都可以直接从parent继承，大幅简化了pom.xml的编写。 如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B： 12345678...&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;module-b&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 最后，在编译的时候，需要在根目录创建一个pom.xml统一编译： 123456789101112131415161718&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt; &lt;artifactId&gt;build&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;build&lt;/name&gt; &lt;modules&gt; &lt;module&gt;parent&lt;/module&gt; &lt;module&gt;module-a&lt;/module&gt; &lt;module&gt;module-b&lt;/module&gt; &lt;module&gt;module-c&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 这样，在根目录执行mvn clean package时，Maven 根据项目根目录的pom.xml找到包括parent在内的共4个&lt;module&gt;，一次性全部编译。 3.3 依赖管理 如果我们的项目依赖第三方的jar包，例如commons logging， 那么问题来了：commons logging发布的jar包在哪下载？ 如果我们还希望依赖log4j，那么使用log4j需要哪些jar包？ 类似的依赖还包括：JUnit，JavaMail，MySQL驱动等等， 一个可行的方法是通过搜索引擎搜索到项目的官网，然后手动下载zip包，解压，放入classpath。 但是，这个过程非常繁琐。 Maven 通过 pom 文件的 标签，解决了依赖管理问题。 例如，我们的项目依赖abc这个jar包，而abc又依赖xyz这个jar包： 12345678910111213┌──────────────┐│Sample Project│└──────────────┘ │ ▼┌──────────────┐│ abc │└──────────────┘ │ ▼┌──────────────┐│ xyz │└──────────────┘ 当我们声明了abc的依赖时，Maven 自动把abc和xyz都加入了我们的项目依赖，不需要我们自己去研究abc是否需要依赖xyz。 因此，Maven 的第一个作用就是解决依赖管理。我们声明了自己的项目需要abc，Maven会自动导入abc的 jar 包，再判断出abc需要xyz，又会自动导入xyz的jar包，这样，最终我们的项目会依赖abc和xyz两个jar包。 我们来看一个复杂依赖示例： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 当我们声明一个spring-boot-starter-web依赖时，Maven会自动解析并判断最终需要大概二三十个其他依赖： 1234567891011121314151617181920212223spring-boot-starter-web spring-boot-starter spring-boot sprint-boot-autoconfigure spring-boot-starter-logging logback-classic logback-core slf4j-api jcl-over-slf4j slf4j-api jul-to-slf4j slf4j-api log4j-over-slf4j slf4j-api spring-core snakeyaml spring-boot-starter-tomcat tomcat-embed-core tomcat-embed-el tomcat-embed-websocket tomcat-embed-core jackson-databind ... 如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。 3.3.1 依赖关系 Maven 定义了几种依赖关系，通过 标签描述，分别是 compile test runtime provided scope 说明 示例 compile 编译时需要用到该jar包（默认） commons-logging test 编译 Test 时需要用到该jar包 junit runtime 编译时不需要，但运行时需要用到 mysql provided 编译时需要用到，但运行时由 JDK 或某个服务器提供 servlet-api 3.3.1.1 compile 依赖 最常用的一致依赖，Maven会把这种类型的依赖直接放入 classpath。 3.3.1.2 test 依赖 表示仅在测试时使用，正常运行时并不需要。最常用的test依赖就是 JUnit： 123456&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 3.3.1.3 runtime 依赖 表示编译时不需要，但运行时需要。最典型的runtime依赖是 JDBC 驱动，例如 MySQL 驱动： 123456&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 3.3.1.4 provided 依赖 表示编译时需要，但运行时不需要。最典型的provided依赖是 Servlet API，编译的时候需要，但是运行时，Servlet 服务器内置了相关的 jar，所以运行期不需要： 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3.3.2 从何处下载所需的依赖 最后一个问题是，Maven如何知道从何处下载所需的依赖？也就是相关的 jar包？ 答案是Maven维护了一个中央仓库（repo1.maven.org） 所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。 Maven并不会每次都从中央仓库下载 jar 包。一个 jar 包一旦被下载过，就会被 Maven 自动缓存在本地目录（用户主目录的.m2目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。 3.3.3 唯一ID 对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包： groupId：属于组织的名称，类似Java的包名； artifactId：该jar包自身的名称，类似Java的类名； version：该jar包的版本。 通过上述3个变量，即可唯一确定某个 jar 包。Maven 通过对jar包进行 PGP 签名确保任何一个 jar 包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。 因此，某个 jar 包一旦被 Maven 下载过，即可永久地安全缓存在本地。 注：只有以-SNAPSHOT结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的 Maven repo，公开发布的版本不允许出现SNAPSHOT。 3.3.4 Maven 依赖镜像 除了可以从 Maven 的中央仓库下载外，还可以从 Maven 的镜像仓库下载。如果访问 Maven 的中央仓库非常慢，我们可以选择一个速度较快的 Maven 的镜像仓库。Maven 镜像仓库定期从中央仓库同步： 123456789 slow ┌───────────────────┐ ┌─────────────&gt;│Maven Central Repo.│ │ └───────────────────┘ │ │ │ │sync │ ▼┌───────┐ fast ┌───────────────────┐│ User │─────────&gt;│Maven Mirror Repo. │└───────┘ └───────────────────┘ 中国区用户可以使用阿里云提供的 Maven 镜像仓库。使用 Maven 镜像仓库需要一个配置，在用户主目录下进入.m2目录，创建一个settings.xml配置文件，内容如下： 1234567891011&lt;settings&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;!-- 国内推荐阿里云的Maven镜像 --&gt; &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 配置镜像仓库后，Maven的下载速度就会非常快。 3.3.5 搜索第三方组件 最后一个问题：如果我们要引用一个第三方组件，比如okhttp，如何确切地获得它的groupId、artifactId和version？方法是通过 search.maven.org 搜索关键字，找到对应的组件后，直接复制： copy-maven 3.3.6 包依赖相关命令行 在命令中，进入到pom.xml所在目录，输入以下命令： 1$ mvn clean package 如果一切顺利，即可在target目录下获得编译后自动打包的 jar。 3.3.7 在 IDE 中使用 Maven 几乎所有的 IDE 都内置了对 Maven 的支持。在 IDEA，Eclipse 中，可以直接创建或导入Maven 项目。如果导入后的 Maven 项目有错误，可以尝试选择项目后点击右键，选择 Maven - Update Project... 更新： update-maven-project 3.3.7 Maven 包依赖仓库分类 3.3.7.1 中央仓库 其实我们使用的大多数第三方模块都是这个用法，例如，我们使用 commons logging、log4j 这些第三方模块，就是第三方模块的开发者自己把编译好的 jar 包发布到Maven的中央仓库中。 3.3.7.2 私有仓库 私有仓库是指公司内部如果不希望把源码和 jar 包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的~/.m2/settings.xml中配置好，使用方式和中央仓位没有任何区别。 3.3.7.3 本地仓库 本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。 但是我们不推荐把自己的模块安装到 Maven 的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。 更好的方法是使用模块化编译，在编译的时候，告诉 Maven 几个模块之间存在依赖关系，需要一块编译，Maven 就会自动按依赖顺序编译这些模块。 3.4 Build 构建流程 使用 maven 构建的项目均可以直接使用 maven build 完成项目的编译测试打包，无需额外配置 Maven 是通过 pom.xml 来描述执行任务的，其中的 标签描述了如何来编译及打包项目，而具体的编译和打包工作是通过在 标签中配置的 标签来完成。当然 标签配置不是必须的，默认情况下，Maven 会绑定以下几个插件来完成基本操作。 要想了解 build 的执行过程，先得了解构建流程和插件 3.4.1 构建流程 Maven 的 pom.xml 文件同时定义了一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。 使用 Maven 时，我们首先要了解什么是 Maven 的生命周期（lifecycle）。 Maven 的生命周期由一系列阶段（phase）构成; Maven 通过 lifecycle、phase 和 goal 来提供标准的构建流程。 最常用的构建命令是指定 phase，然后让 Maven 执行到指定的 phase： mvn clean mvn clean compile mvn clean test mvn clean package 通常情况，我们总是执行 phase 默认绑定的 goal，因此不必指定 goal。 3.4.1.1 内置的生命周期 default 为例，它包含以下 phase： 1234567891011121314151617181920212223- validate- initialize- generate-sources- process-sources- generate-resources- process-resources- compile- process-classes- generate-test-sources- process-test-sources- generate-test-resources- process-test-resources- test-compile- process-test-classes- test- prepare-package- package- pre-integration-test- integration-test- post-integration-test- verify- install- deploy 如果我们运行mvn package，Maven 就会执行default生命周期，它会从开始一直运行到package这个phase为止： validate ... package 如果我们运行mvn compile，Maven也会执行default生命周期，但这次它只会运行到compile，即以下几个phase： validate ... compile 3.4.1.2 常用的生命周期是 clean Maven 另一个常用的生命周期是 clean，它会包含3个 phase： 123- pre-clean- clean （注意这个clean不是 lifecycle 而是 phase）- post-clean 所以，我们使用mvn这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase。 3.4.1.3 指定多个 phase 更复杂的例子是指定多个phase，例如，运行mvn clean package，Maven先执行clean生命周期并运行到clean这个phase，然后执行default生命周期并运行到package这个phase，实际执行的phase如下： 12345678- 1. clean lifecycle - pre-clean - clean （注意这个clean是phase） - 2. default lifecycle - validate - ... - package 3.4.1.4 常用的命令 在实际开发过程中，经常使用的命令有： 1234567891011# 清理所有生成的class和jar；mvn clean# 先清理，再执行到`compile`；mvn clean compile# 先清理，再执行到`test`，因为执行`test`前必须执行`compile`，所以这里不必指定`compile`；mvn clean test# 先清理，再执行到`package`mvn clean package 大多数 phase 在执行过程中，因为我们通常没有在 pom.xml 中配置相关的设置，所以这些 phase 什么事情都不做。 经常用到的phase其实只有几个： clean：清理 compile：编译 test：运行测试 package：打包 3.4.1.4 Goal 执行一个 phase 又会触发一个或多个 goal： 执行的 Phase 对应执行的 Goal compile compiler: compile test compiler: testCompile surefire: test goal 的命名总是abc:xyz这种形式。 看到这里，相信大家对 lifecycle、phase 和 goal 已经明白了吧？ 其实我们类比一下就明白了： lifecycle 相当于 Java 的 package，它包含一个或多个 phase； phase 相当于 Java 的 class，它包含一个或多个 goal； goal 相当于 class 的 method，它其实才是真正干活的。 大多数情况，我们只要指定phase，就默认执行这些 phase 默认绑定的 goal，只有少数情况，我们可以直接指定运行一个 goal，例如，启动 Tomcat 服务器： 1mvn tomcat:run 3.4.2 plugin 插件使用 我们在前面介绍了 Maven 的 lifecycle，phase 和 goal 使用Maven构建项目就是执行 lifecycle，执行到指定的 phase 为止。每个 phase 会执行自己默认的一个或多个 goal。goal 是最小任务单元。 我们以compile这个phase为例，如果执行： 1mvn compile Maven 将执行compile这个 phase，这个phase会调用compiler插件执行关联的compiler:compile这个 goal。 实际上：执行每个 phase，都是通过某个插件（plugin）来执行的。 Maven 本身其实并不知道如何执行compile，它只是负责找到对应的compiler插件，然后执行默认的compiler:compile这个 goal 来完成编译。 所以，使用 Maven，实际上就是配置好需要使用的插件，然后通过 phase 调用它们。 Maven已经内置了一些常用的标准插件： plugin 插件名称 对应执行的 phase clean clean compiler compile surefire test jar package 如果标准插件无法满足需求，我们还可以使用自定义插件。使用自定义插件的时候，需要声明。 例如，使用maven-shade-plugin可以创建一个可执行的 jar，要使用这个插件，需要在pom.xml中声明它，如下： 1234567891011121314151617181920212223&lt;project&gt; ... &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; ... &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 自定义插件往往需要一些配置，例如，maven-shade-plugin需要指定 Java 程序的入口，它的配置是： 1234567&lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;mainClass&gt;com.itranswarp.learnjava.Main&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt;&lt;/configuration&gt; 注意，Maven 自带的标准插件例如compiler是无需声明的，只有引入其它的插件才需要声明。 下面列举了一些常用的插件： maven-shade-plugin：打包所有依赖包并生成可执行jar； cobertura-maven-plugin：生成单元测试覆盖率报告； findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。 4. 使用 mvnw mvnw是 Maven Wrapper 的缩写。 因为我们安装 Maven 时，默认情况下，系统所有项目都会使用全局安装的这个 Maven 版本。 但是，对于某些项目来说，它可能必须使用某个特定的 Maven 版本，这个时候，就可以使用 Maven Wrapper，它可以负责给这个特定的项目安装指定版本的 Maven，而其他项目不受影响。 简单地说，Maven Wrapper 就是给一个项目提供一个独立的，指定版本的 Maven 给它使用。 这有点类似于 Python 的虚拟环境 4.1 安装 Maven Wrapper 安装Maven Wrapper最简单的方式是在项目的根目录（即pom.xml所在的目录）下运行安装命令： 1mvn -N io.takari:maven:0.7.6:wrapper 它会自动使用最新版本的Maven。注意0.7.6是Maven Wrapper的版本。最新的Maven Wrapper版本可以去官方网站查看。 如果要指定使用的Maven版本，使用下面的安装命令指定版本，例如3.3.3： 1mvn -N io.takari:maven:0.7.6:wrapper -Dmaven=3.3.3 安装后，查看项目结构： 12345678910111213141516my-project├── .mvn│ └── wrapper│ ├── MavenWrapperDownloader.java│ ├── maven-wrapper.jar│ └── maven-wrapper.properties├── mvnw├── mvnw.cmd├── pom.xml└── src ├── main │ ├── java │ └── resources └── test ├── java └── resources 发现多了mvnw、mvnw.cmd和.mvn目录，我们只需要把mvn命令改成mvnw就可以使用跟项目关联的Maven。例如： 1mvnw clean package 在Linux或macOS下运行时需要加上./： 1./mvnw clean package Maven Wrapper 的另一个作用是把项目的mvnw、mvnw.cmd和.mvn提交到版本库中，可以使所有开发人员使用统一的Maven版本。 5. 发布 Artifact 当我们使用commons-logging这些第三方开源库的时候，我们实际上是通过 Maven 自动下载它的 jar包，并根据其pom.xml解析依赖，自动把相关依赖包都下载后加入到 classpath。 那么问题来了：当我们自己写了一个牛逼的开源库时，非常希望别人也能使用，总不能直接放个 jar 包的链接让别人下载吧？ 如果我们把自己的开源库放到Maven的repo中，那么，别人只需按标准引用groupId:artifactId:version，即可自动下载 jar 包以及相关依赖。 因此，本节我们介绍如何发布一个库到Maven的repo中。 把自己的库发布到 Maven 的 repo 中有好几种方法，我们介绍3种最常用的方法。 5.1 以静态文件发布 如果我们观察一个中央仓库的Artifact结构，例如Commons Math，它的groupId是org.apache.commons，artifactId 是commons-math3，以版本3.6.1为例，发布在中央仓库的文件夹路径就是https://repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/，在此文件夹下，commons-math3-3.6.1.jar就是发布的jar包，commons-math3-3.6.1.pom就是它的pom.xml描述文件，commons-math3-3.6.1-sources.jar是源代码，commons-math3-3.6.1-javadoc.jar是文档。其它以.asc、.md5、.sha1结尾的文件分别是 GPG 签名、MD5 摘要和SHA-1 摘要。 我们只要按照这种目录结构组织文件，它就是一个有效的 Maven 仓库。 我们以广受好评的开源项目 how-to-become-rich 为例，先创建 Maven 工程目录结构如下： 1234567891011how-to-become-rich├── maven-repo &lt;-- Maven本地文件仓库├── pom.xml &lt;-- 项目文件├── src│ ├── main│ │ ├── java &lt;-- 源码目录│ │ └── resources &lt;-- 资源目录│ └── test│ ├── java &lt;-- 测试源码目录│ └── resources &lt;-- 测试资源目录└── target &lt;-- 编译输出目录 在pom.xml中添加如下内容： 123456789101112131415161718192021222324252627282930313233343536373839&lt;project ...&gt; ... &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;local-repo-release&lt;/id&gt; &lt;name&gt;GitHub Release&lt;/name&gt; &lt;url&gt;file://$&#123;project.basedir&#125;/maven-repo&lt;/url&gt; &lt;/repository&gt; &lt;/distributionManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-javadocs&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 注意到&lt;distributionManagement&gt;，它指示了发布的软件包的位置，这里的&lt;url&gt;是项目根目录下的maven-repo目录，在&lt;build&gt;中定义的两个插件maven-source-plugin和maven-javadoc-plugin分别用来创建源码和 javadoc，如果不想发布源码，可以把对应的插件去掉。 我们直接在项目根目录下运行Maven命令mvn clean package deploy，如果一切顺利，我们就可以在maven-repo目录下找到部署后的所有文件如下： 123456789101112131415161718192021maven-repo└── com └── itranswarp └── rich └── how-to-become-rich ├── 1.0.0 │ ├── how-to-become-rich-1.0.0-javadoc.jar │ ├── how-to-become-rich-1.0.0-javadoc.jar.md5 │ ├── how-to-become-rich-1.0.0-javadoc.jar.sha1 │ ├── how-to-become-rich-1.0.0-sources.jar │ ├── how-to-become-rich-1.0.0-sources.jar.md5 │ ├── how-to-become-rich-1.0.0-sources.jar.sha1 │ ├── how-to-become-rich-1.0.0.jar │ ├── how-to-become-rich-1.0.0.jar.md5 │ ├── how-to-become-rich-1.0.0.jar.sha1 │ ├── how-to-become-rich-1.0.0.pom │ ├── how-to-become-rich-1.0.0.pom.md5 │ └── how-to-become-rich-1.0.0.pom.sha1 ├── maven-metadata.xml ├── maven-metadata.xml.md5 └── maven-metadata.xml.sha1 最后一步，是把这个工程推到 GitHub上，并选择Settings-GitHub Pages，选择master branch启用Pages服务： enable-github-pages 这样，把全部内容推送至 GitHub 后，即可作为静态网站访问 Maven 的 repo，它的地址是https://michaelliao.github.io/how-to-become-rich/maven-repo/。版本1.0.0对应的jar包地址是： 1https://michaelliao.github.io/how-to-become-rich/maven-repo/com/itranswarp/rich/how-to-become-rich/1.0.0/how-to-become-rich-1.0.0.jar 现在，如果其他人希望引用这个Maven包，我们可以告知如下依赖即可： 12345&lt;dependency&gt; &lt;groupId&gt;com.itranswarp.rich&lt;/groupId&gt; &lt;artifactId&gt;how-to-become-rich&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; 但是，除了正常导入依赖外，对方还需要再添加一个&lt;repository&gt;的声明，即使用方完整的pom.xml如下： 1234567891011121314151617181920212223242526272829303132&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;example&lt;/groupId&gt; &lt;artifactId&gt;how-to-become-rich-usage&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;github-rich-repo&lt;/id&gt; &lt;name&gt;The Maven Repository on Github&lt;/name&gt; &lt;url&gt;https://michaelliao.github.io/how-to-become-rich/maven-repo/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.itranswarp.rich&lt;/groupId&gt; &lt;artifactId&gt;how-to-become-rich&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 在&lt;repository&gt;中，我们必须声明发布的Maven的repo地址，其中&lt;id&gt;和&lt;name&gt;可以任意填写，&lt;url&gt;填入GitHub Pages提供的地址+/maven-repo/后缀。现在，即可正常引用这个库并编写代码如下： 12Millionaire millionaire = new Millionaire();System.out.println(millionaire.howToBecomeRich()); 有的童鞋会问，为什么使用commons-logging等第三方库时，并不需要声明repo地址？这是因为这些库都是发布到Maven中央仓库的，发布到中央仓库后，不需要告诉Maven仓库地址，因为它知道中央仓库的地址默认是 https://repo1.maven.org/maven2/，也可以通过~/.m2/settings.xml指定一个代理仓库地址以替代中央仓库来提高速度（参考依赖管理的Maven镜像）。 因为 GitHub Pages 并不会把我们发布的 Maven 包同步到中央仓库，所以自然使用方必须手动添加一个我们提供的仓库地址。 此外，通过 GitHub Pages 发布 Maven repo 时需要注意一点，即不要改动已发布的版本。因为Maven的仓库是不允许修改任何版本的，对一个库进行修改的唯一方法是发布一个新版本。但是通过静态文件的方式发布 repo，实际上我们是可以修改 jar 文件的，但最好遵守规范，不要修改已发布版本。 5.2 通过 Nexus 发布到中央仓库 有的童鞋会问，能不能把自己的开源库发布到 Maven 的中央仓库，这样用户就不需要声明 repo 地址，可以直接引用，显得更专业。 当然可以，但我们不能直接发布到Maven中央仓库，而是通过曲线救国的方式，发布到central.sonatype.org，它会定期自动同步到 Maven 的中央仓库。Nexus 是一个支持 Maven 仓库的软件，由 Sonatype 开发，有免费版和专业版两个版本，很多大公司内部都使用 Nexus 作为自己的私有Maven仓库，而这个 central.sonatype.org 相当于面向开源的一个Nexus公共服务。 所以，第一步是在 central.sonatype.org 上注册一个账号，注册链接非常隐蔽，可以自己先找找，找半小时没找到点 这里 查看攻略。 如果注册顺利并审核通过，会得到一个登录账号，然后，通过这个页面一步一步操作就可以成功地将自己的 Artifact 发布到 Nexus 上，再耐心等待几个小时后，你的 Artifact 就会出现在Maven的中央仓库中。 这里简单提一下发布重点与难点： 必须正确创建 GPG 签名，Linux 和 Mac 下推荐使用 gnupg2； 必须在~/.m2/settings.xml中配置好登录用户名和口令，以及 GPG 口令： 12345678910111213141516171819202122&lt;settings ...&gt; ... &lt;servers&gt; &lt;server&gt; &lt;id&gt;ossrh&lt;/id&gt; &lt;username&gt;OSSRH-USERNAME&lt;/username&gt; &lt;password&gt;OSSRH-PASSWORD&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;ossrh&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;gpg.executable&gt;gpg2&lt;/gpg.executable&gt; &lt;gpg.passphrase&gt;GPG-PASSWORD&lt;/gpg.passphrase&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/settings&gt; 在待发布的 Artifact 的pom.xml中添加 OSS 的 Maven repo 地址，以及maven-jar-plugin、maven-source-plugin、maven-javadoc-plugin、maven-gpg-plugin、nexus-staging-maven-plugin： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;project ...&gt; ... &lt;distributionManagement&gt; &lt;snapshotRepository&gt; &lt;id&gt;ossrh&lt;/id&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;repository&gt; &lt;id&gt;ossrh&lt;/id&gt; &lt;name&gt;Nexus Release Repository&lt;/name&gt; &lt;url&gt;http://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt; &lt;/repository&gt; &lt;/distributionManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;goal&gt;test-jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-javadocs&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;additionalOption&gt; &lt;additionalOption&gt;-Xdoclint:none&lt;/additionalOption&gt; &lt;/additionalOption&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;sign-artifacts&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;sign&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.sonatype.plugins&lt;/groupId&gt; &lt;artifactId&gt;nexus-staging-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.6.3&lt;/version&gt; &lt;extensions&gt;true&lt;/extensions&gt; &lt;configuration&gt; &lt;serverId&gt;ossrh&lt;/serverId&gt; &lt;nexusUrl&gt;https://oss.sonatype.org/&lt;/nexusUrl&gt; &lt;autoReleaseAfterClose&gt;true&lt;/autoReleaseAfterClose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 最后执行命令mvn clean package deploy即可发布至 central.sonatype.org。 此方法前期需要复杂的申请账号和项目的流程，后期需要安装调试GPG，但只要跑通流程，后续发布都只需要一行命令。 5.3 发布到私有仓库 通过nexus-staging-maven-plugin除了可以发布到 central.sonatype.org 外，也可以发布到私有仓库，例如，公司内部自己搭建的Nexus服务器。 如果没有私有 Nexus 服务器，还可以发布到 GitHub Packages。GitHub Packages是 GitHub 提供的仓库服务，支持 Maven、NPM、Docker 等。使用 GitHub Packages 时，无论是发布Artifact，还是引用已发布的 Artifact，都需要明确的授权 Token，因此，GitHub Packages 只能作为私有仓库使用。 在发布前，我们必须首先登录后在用户的Settings-Developer settings-Personal access tokens中创建两个Token，一个用于发布，一个用于使用。发布Artifact的Token必须有repo、write:packages和read:packages权限： token-scopes 使用 Artifact 的Token只需要read:packages权限。 在发布端，把 GitHub 的用户名和发布Token写入~/.m2/settings.xml配置中： 12345678910&lt;settings ...&gt; ... &lt;servers&gt; &lt;server&gt; &lt;id&gt;github-release&lt;/id&gt; &lt;username&gt;GITHUB-USERNAME&lt;/username&gt; &lt;password&gt;f052...c21f&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt;&lt;/settings&gt; 然后，在需要发布的 Artifact 的pom.xml中，添加一个&lt;repository&gt;声明： 12345678910&lt;project ...&gt; ... &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;github-release&lt;/id&gt; &lt;name&gt;GitHub Release&lt;/name&gt; &lt;url&gt;https://maven.pkg.github.com/michaelliao/complex&lt;/url&gt; &lt;/repository&gt; &lt;/distributionManagement&gt;&lt;/project&gt; 注意到&lt;id&gt;和~/.m2/settings.xml配置中的&lt;id&gt;要保持一致，因为发布时Maven根据id找到用于登录的用户名和Token，才能成功上传文件到GitHub。我们直接通过命令mvn clean package deploy部署，成功后，在GitHub用户页面可以看到该Artifact： github-packages 完整的配置请参考 complex 项目，这是一个非常简单的支持复数运算的库。 使用该Artifact时，因为GitHub的Package只能作为私有仓库使用，所以除了在使用方的pom.xml中声明&lt;repository&gt;外： 12345678910111213141516171819&lt;project ...&gt; ... &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;github-release&lt;/id&gt; &lt;name&gt;GitHub Release&lt;/name&gt; &lt;url&gt;https://maven.pkg.github.com/michaelliao/complex&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.itranswarp&lt;/groupId&gt; &lt;artifactId&gt;complex&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ...&lt;/project&gt; 还需要把有读权限的Token配置到~/.m2/settings.xml文件中。","categories":[{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Maven","slug":"工具/Maven","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://buctllx.github.io/tags/Maven/"}]},{"title":"计算机网络基础","slug":"计算机网络基础","date":"2022-03-25T10:21:59.000Z","updated":"2022-03-29T05:27:56.710Z","comments":true,"path":"2022/03/25/计算机网络基础/","link":"","permalink":"https://buctllx.github.io/2022/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","excerpt":"本文以科普的性质说明计算机网络是一个什么样的东西，顺便回顾一下自己大学计算机网络的基本知识","text":"本文以科普的性质说明计算机网络是一个什么样的东西，顺便回顾一下自己大学计算机网络的基本知识 自从互联网诞生以来，现在基本上绝大多数的程序都是网络程序或者跟网络有关，很少有单机版的程序了。 计算机网络本质上就是：多个计算机（网络设置）连载一起，像一张网一样，彼此可以直接或者间接的相互通信；世界上所有的电脑（网络设备）同通过这张网联系在一起，就是计算机网络，通俗讲就是互联网。 网络编程，就是在计算机网络（互联网）中实现两台或者多台计算机之间的数据通信。 网络编程按照编程语言的不同又可以划分成不同是编程实现方式，但是他们用到的原理和协议都是一致的。 1. 网络基础知识 主要介绍，IP 地址，域名，网络模型等基本知识 1.1 IP 地址 在互联网中，一个 IP 地址用于唯一标识一个网络接口（Network Interface）。 一台联入互联网的计算机肯定有一个 IP 地址，但也可能有多个 IP 地址。 IP 地址分为 IPv4 和 IPv6 两种。 IPv4 采用32位地址，类似 192.168.10.1， 而 IPv6 采用128位地址，类似 2001:0DA8:100A:0000:0000:1020:F2F3:1428。 \\[ \\begin{flalign} &amp; IPv4 \\,\\, 地址总共有\\,\\, 2^{32}个，而\\,\\,IPv6 \\,\\, 地址则总共有\\,\\, 2^{128} 个（大约340万亿亿亿亿）&amp; \\end{flalign} \\] IPv4 的地址目前已耗尽，而 IPv6 的地址是根本用不完的。 IP 地址又分为公网 IP 地址和内网 IP 地址。公网 IP 地址可以直接被访问，内网 IP 地址只能在内网访问。内网 IP 地址类似于： 192.168.x.x 10.x.x.x 有一个特殊的 IP 地址，称之为本机地址，它总是127.0.0.1。 IPv4 地址实际上是一个32位整数。例如： 1231707762444 = 0x65ca630c = 65 ca 63 0c = 101.202.99.12 如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址127.0.0.1，还有一个 IP 地址，例如101.202.99.12，可以通过这个 IP 地址接入网络。 如果一台计算机有两块网卡，那么除了本机地址，它可以有两个 IP 地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个 IP 地址，分别接入不同的网络，让网络之间连接起来。 如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的 IP 地址前段是相同的，也就是网络号是相同的。网络号是 IP 地址通过子网掩码过滤后得到的。例如： 某台计算机的 IP 是101.202.99.2，子网掩码是255.255.255.0，那么计算该计算机的网络号是： 123IP = 101.202.99.2Mask = 255.255.255.0Network = IP &amp; Mask = 101.202.99.0 每台计算机都需要正确配置 IP 地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。 网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。 所以，一台计算机的一个网卡会有3个关键配置： IP 地址，例如：10.80.2.24 子网掩码，例如：255.255.255.0 网关的 IP 地址，例如：10.80.2.254 image-20220325191123462 1.2 域名 因为直接记忆 IP 地址非常困难，所以我们通常使用域名访问某个特定的服务。 域名解析服务器 DNS 负责把域名翻译成对应的 IP，客户端再根据 IP 地址访问服务器。 用nslookup可以查看域名对应的 IP 地址： 1234567891011121314$ nslookup buctllx.github.ioServer: bogonAddress: 10.80.253.253Non-authoritative answer:Name: buctllx.github.ioAddresses: 2606:50c0:8002::153 2606:50c0:8001::153 2606:50c0:8000::153 2606:50c0:8003::153 185.199.110.153 185.199.109.153 185.199.111.153 185.199.108.153 有一个特殊的本机域名localhost，它对应的 IP 地址总是本机地址127.0.0.1。 1.3 网络模型 由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是： 应用层，提供应用程序之间的通信； 表示层：处理数据格式，加解密等等； 会话层：负责建立和维护会话； 传输层：负责提供端到端的可靠传输； 网络层：负责根据目标地址选择路由来传输数据； 链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。 互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型： OSI TCP/IP 应用层 应用层 表示层 会话层 传输层 传输层 网络层 IP层 链路层 网络接口层 物理层 2. 常用网络协议 虽然大家现在对互联网很熟悉，但是计算机网络的出现比互联网要早很多。 计算机为了联网，就必须规定通信协议，早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容，这就好比一群人有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同的语言之间就不行了。 为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议簇（Internet Protocol Suite）就是通用协议标准。Internet是由inter和net两个单词组合起来的，原意就是连接“网络”的网络，有了Internet，任何私有网络，只要支持这个协议，就可以联入互联网。 UDP 协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为 UDP 协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。 选择 UDP 协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择 UDP 协议。 2.1 TCP/IP 协议 因为互联网协议包含了上百种协议标准，但是最重要的两个协议是 TCP 和 IP 协议，所以，大家把互联网的协议简称 TCP/IP 协议。 网络通信的时候，双方必须知道对方的标识，好比发邮件必须知道对方的邮件地址。 互联网上每个计算机的唯一标识就是 IP 地址。如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个 IP 地址，所以，IP地址对应的实际上是计算机的网络接口，通常是网卡。 IP 协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过 IP 包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个 IP 包转发出去。IP 包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。 IP 协议是一个分组交换，它不保证可靠传输。 而 TCP 协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。 TCP 协议是建立在 IP 协议之上的，简单地说，IP 协议只负责发数据包，不保证顺序和正确性，而 TCP 协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。 TCP协议会通过握手建立连接，然后，对每个 IP 包编号，确保对方按顺序收到，如果包丢掉了，就自动重发；传输完后还需要断开连接。 TCP 协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。 TCP 协议也是应用最广泛的协议，许多高级协议都是建立在 TCP 协议之上的，例如 HTTP、SMTP 等。 一个 TCP 报文除了包含要传输的数据外，还包含源 IP 地址和目标 IP 地址，源端口和目标端口。 端口有什么作用？在两台计算机通信时，只发 IP 地址是不够的，因为同一台计算机上跑着多个网络程序。一个 TCP 报文来了之后，到底是交给浏览器还是 QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的 IP地址和各自的端口号。 一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。 2.2 UDP 协议 TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对 TCP，UDP 则是面向无连接的协议。 使用 UDP 协议时，不需要建立连接，只需要知道对方的 IP 地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。 缺点：传输数据不可靠 优点：速度快，对于不要求可靠到达的数据，就可以使用 UDP 协议。 此外，服务器绑定 UDP 端口和 TCP 端口互不冲突，也就是说，UDP 的 80 端口与 TCP 的 80 端口可以各自绑定。 2.3 HTTP 协议 在 Web 应用中，服务器把网页传给浏览器，实际上就是把网页的 HTML 代码发送给浏览器，让浏览器显示出来。 而浏览器和服务器之间的传输协议是 HTTP，所以： HTML 是一种用来定义网页的文本，会 HTML，就可以编写网页； HTTP 是在网络上传输 HTML 的协议，用于浏览器和服务器的通信。 在举例子之前，我们需要安装 Google 的 Chrome 浏览器。或者 Microsoft 的 Edge 浏览器。本质上都是基于 Chromium 内核的浏览器 为什么要使用 Chromium 内核的浏览器而不是 IE 呢？因为 IE 实在是太慢了，并且，IE 对于开发和调试 Web 应用程序完全是一点用也没有。 我们需要在浏览器很方便地调试我们的 Web 应用，而 Chromium 提供了一套完整地调试工具，非常适合 Web 开发。 安装好 Chromium 内核的浏览器后，打开浏览器，按 F12，就可以显示开发者工具： image-20220325193907204 Elements显示网页的结构，Network显示浏览器和服务器的通信。我们点Network，确保第一个小红灯亮着，Chrome就会记录所有浏览器和服务器之间的通信： 当我们在地址栏输入www.sina.com.cn时，浏览器将显示新浪的首页。在这个过程中，浏览器都干了哪些事情呢？通过Network的记录，我们就可以知道。在Network中，定位到第一条记录，点击，右侧将显示Request Headers，点击右侧的view source，我们就可以看到浏览器发给新浪服务器的请求： 最主要的头两行分析如下，第一行： 1GET / HTTP/1.1 GET表示一个读取请求，将从服务器获得网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。目前HTTP协议的版本就是1.1，但是大部分服务器也支持1.0版本，主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接，以加快传输速度。 从第二行开始，每一行都类似于Xxx: abcdefg： 1Host: www.sina.com.cn 表示请求的域名是www.sina.com.cn。如果一台服务器有多个网站，服务器就需要通过Host来区分浏览器请求的是哪个网站。 继续往下找到Response Headers，点击view source，显示服务器返回的原始响应数据： HTTP响应分为Header和Body两部分（Body是可选项），我们在Network中看到的Header最重要的几行如下： 1200 OK 200表示一个成功的响应，后面的OK是说明。失败的响应有404 Not Found：网页不存在，500 Internal Server Error：服务器内部出错，等等。 1Content-Type: text/html Content-Type指示响应的内容，这里是text/html表示HTML网页。请注意，浏览器就是依靠Content-Type来判断响应的内容是网页还是图片，是视频还是音乐。浏览器并不靠URL来判断响应的内容，所以，即使URL是http://example.com/abc.jpg，它也不一定就是图片。 HTTP响应的Body就是HTML源码，我们在菜单栏选择“视图”，“开发者”，“查看网页源码”就可以在浏览器中直接查看HTML源码： 当浏览器读取到新浪首页的HTML源码后，它会解析HTML，显示页面，然后，根据HTML里面的各种链接，再发送HTTP请求给新浪服务器，拿到相应的图片、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出一个完整的页面。所以我们在Network下面能看到很多额外的HTTP请求。 2.3.1 HTTP 请求 跟踪了新浪的首页，我们来总结一下HTTP请求的流程： 步骤1：浏览器首先向服务器发送HTTP请求，请求包括： 方法：GET还是POST，GET仅请求资源，POST会附带用户数据； 路径：/full/url/path； 域名：由Host头指定：Host: www.sina.com.cn 以及其他相关的Header； 如果是POST，那么请求还包括一个Body，包含用户数据。 步骤2：服务器向浏览器返回HTTP响应，响应包括： 响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误； 响应类型：由Content-Type指定，例如：Content-Type: text/html;charset=utf-8表示响应类型是HTML文本，并且编码是UTF-8，Content-Type: image/jpeg表示响应类型是JPEG格式的图片； 以及其他相关的Header； 通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。 步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。 Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP响应中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。 HTTP协议同时具备极强的扩展性，虽然浏览器请求的是http://www.sina.com.cn/的首页，但是新浪在HTML中可以链入其他服务器的资源，比如&lt;img src=\"http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png\"&gt;，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称“三达不溜”（WWW）。 2.3.2 HTTP 格式 每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。 HTTP协议是一种文本协议，所以，它的格式也非常简单。HTTP GET请求的格式： 1234GET /path HTTP/1.1Header1: Value1Header2: Value2Header3: Value3 每个Header一行一个，换行符是\\r\\n。 HTTP POST请求的格式： 123456POST /path HTTP/1.1Header1: Value1Header2: Value2Header3: Value3body data goes here... 当遇到连续两个\\r\\n时，Header部分结束，后面的数据全部是Body。 HTTP响应的格式： 123456200 OKHeader1: Value1Header2: Value2Header3: Value3body data goes here... HTTP响应如果包含body，也是通过\\r\\n\\r\\n来分隔的。请再次注意，Body的数据类型由Content-Type头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。 当存在Content-Encoding时，Body数据是被压缩的，最常见的压缩方式是gzip，所以，看到Content-Encoding: gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。 要详细了解HTTP协议，推荐“HTTP: The Definitive Guide”一书，非常不错，有中文译本： HTTP权威指南 参考文档： 网络编程基础 - 廖雪峰的官方网站 (liaoxuefeng.com) HTTP协议简介 - 廖雪峰的官方网站 (liaoxuefeng.com)","categories":[{"name":"network","slug":"network","permalink":"https://buctllx.github.io/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"https://buctllx.github.io/tags/network/"}]},{"title":"Nginx 反向代理 FileBrowser","slug":"Nginx-反向代理-FileBrowser","date":"2022-03-23T10:47:42.000Z","updated":"2022-03-25T11:15:50.177Z","comments":true,"path":"2022/03/23/Nginx-反向代理-FileBrowser/","link":"","permalink":"https://buctllx.github.io/2022/03/23/Nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-FileBrowser/","excerpt":"本文主要说明如果使用 Nginx 方向代理已经启动的 FileBrowser 服务。","text":"本文主要说明如果使用 Nginx 方向代理已经启动的 FileBrowser 服务。 1. 准备工作 开始本文的主要内容前，默认已经做好了以下准备工作 使用 linux 系统，比如 centos； 已安装并启动 nginx 服务 已安装并启动 filebrowser 服务 2. 有关 FileBrowser 的配置 如果不知道已经启动的 filebrowser 服务的相关配置，可以通过以下命令查看 123# 1. 查看 filebrowser 服务的进程 (可以看到启动命令的相关参数，比如说配置文件，数据库文件等)ps -ef |grep filebrowserpstree -ap |grep filebrowser image-20220323190406153 123456789101112# 2. 导出 filebrowser 的配置信息cd /etc/filebrowser # 首先进入包含 filebrowser 可执行文件的目录filebrowser config cat # 临时查看filebrowser config export config.json # 导出 filebrowser 配置信息到 config.json 文件# 如果存在多个 db 可以通过 -d 参数导出指定数据库中存储的配置信息(其他命令也是如此，后面不在重复说明举例)filebrowser -d /etc/filebrowser/filebrowser.db config export config.json# 可能用到的其他命令filebrowser users update admin -p admin # 更新 admin 用户的密码为 adminfilebrowser config set --port 18080 # 重新设置端口信息 以下 json 信息是我用到的配置 123456789101112131415&#123; &quot;port&quot;: 18080, &quot;root&quot;:&quot;/data/file&quot;, &quot;database&quot;:&quot;/etc/filebrowser/filebrowser.db&quot;, &quot;log&quot;:&quot;/etc/filebrowser/log.log&quot;, &quot;plugin&quot;: &quot;&quot;, &quot;baseURL&quot;: &quot;/files&quot;, &quot;allowCommands&quot;: true, &quot;allowEdit&quot;: true, &quot;allowNew&quot;: true, &quot;commands&quot;: [ &quot;ls&quot;, &quot;df&quot; ]&#125; 需要注意的问题： baseURL 配置项的值在后面 nginx 的配置中要使用到，一定要记录下来；如果没有设置，默认值是 files， 强烈建议设置一下； 使用 vi 或者 vim 写 json 配置文件的时候一定要注意，缩进符号是 空格，而且不能和 tab 混合用；尤其是从网页上面复制 json 文本的时候一定要确保是空格（有些网页上的缩进是 tab，但是默认空白看不到） 如果在 filebrowser 启动后通过 ui 设置了一些操作，或者添加了一些用户，那么通过上面的命名可能获取不到最新的配置信息，或者出现 timeout 的问题，这时候需要关闭 filebrowser 服务，然后通过 -d 参数执行 db 就可以了； 3. 在 Nginx 中配置 FileBrowser 服务 核心配置如下： 12345678910111213server &#123; listen 80; server_name ai.cbim.com 10.80.253.133; access_log /var/logs/nginx/filebrowser.access.log; # file browser url location ^~ /files/ &#123; proxy_pass http://127.0.0.1:18080/; proxy_set_header Host $proxy_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 新增或者修改完 nginx 的配置文件后，可以使用下面的命令测试 / 重新载入配置 12345# 测试 配置文件的语法是否正确nginx -t# 重新载入修改后的 配置文件nginx -s reload 最后就可以通过设定的域名或者 IP 访问 filebrowser 了 image-20220323195000831 需要注意的问题： server_name 不要和 nginx/conf.d 中其他的配置文件中的 server_name 重复，否则可能被忽略； location 后面的匹配项，一定要和 前面 filebrowser 配置文件中的 baseURL 配置项保持一致，否则无法代理成功； location 的具体匹配规则视情况而定，我这里通过 ^~ 匹配以 files 开头的所有 api；^~ 如果删除，而又没有其他 location 匹配规则，同样会导致代理失败，无法访问 filebrowser 最后访问的时候，如果是局域网域名，访问前最好关掉 vpn 或者其他一类的代理软件，否则也可能会访问失败； 4. 相关参考资料： nginx documentation filebrowser/filebrowser: 📂 Web File Browser (github.com) Welcome - File Browser file browser介绍 - shanyu20 - 博客园 (cnblogs.com) timeout on commands that connect to a locked database · Issue #627 · filebrowser/filebrowser (github.com) Usable configuration for executing command behind NGINX. · Issue #549 · filebrowser/filebrowser (github.com)","categories":[{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Nginx","slug":"工具/Nginx","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://buctllx.github.io/tags/Nginx/"},{"name":"FileBrowsern","slug":"FileBrowsern","permalink":"https://buctllx.github.io/tags/FileBrowsern/"}]},{"title":"Microsoft.Toolkit.Mvvm 使用记录","slug":"Microsoft-Toolkit-Mvvm-使用记录","date":"2022-03-16T02:22:18.000Z","updated":"2022-03-16T03:33:24.722Z","comments":true,"path":"2022/03/16/Microsoft-Toolkit-Mvvm-使用记录/","link":"","permalink":"https://buctllx.github.io/2022/03/16/Microsoft-Toolkit-Mvvm-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"1. Microsoft.Toolkit.Mvvm 介绍 模型-视图-视图模型 (MVVM) 是用于解耦 UI 代码和非 UI 代码的 UI 体系结构设计模式。 借助 MVVM，可以在 XAML 中以声明方式定义 UI，并使用数据绑定标记将 UI 链接到包含数据和命令的其他层。 MVVM 最早是 Microsoft 提出来的，但是官方一直没有提供框架；很多人会说 Prism 框架，但是 Prism 已经出走了，而且比较臃肿；至于 MVVMLight 也很久没有更新了，直到 2020 年 Windows Community Toolkit 开源了一套 MVVM 框架 Microsoft.Toolkit.Mvvm。","text":"1. Microsoft.Toolkit.Mvvm 介绍 模型-视图-视图模型 (MVVM) 是用于解耦 UI 代码和非 UI 代码的 UI 体系结构设计模式。 借助 MVVM，可以在 XAML 中以声明方式定义 UI，并使用数据绑定标记将 UI 链接到包含数据和命令的其他层。 MVVM 最早是 Microsoft 提出来的，但是官方一直没有提供框架；很多人会说 Prism 框架，但是 Prism 已经出走了，而且比较臃肿；至于 MVVMLight 也很久没有更新了，直到 2020 年 Windows Community Toolkit 开源了一套 MVVM 框架 Microsoft.Toolkit.Mvvm。 Windows Community Toolkit 除了提供开源框架，也贴心的在文档中提供了，基本的使用案例，以及从其他 MVVM 框架迁移到 Microsoft.Toolkit.Mvvm 框架的说明文档。 官方文档：Introduction to the MVVM Toolkit - Windows Community Toolkit | Microsoft Docs [WPF] 使用 MVVM Toolkit 构建 MVVM 程序 - dino.c - 博客园 (cnblogs.com) MVVM Toolkit 延续了 MVVMLight 的风格，是一个轻量级的组件，而且它基于 .NET Standard 2.0，可用于UWP, WinForms, WPF, Xamarin, Uno 等多个平台。相比它的前身 MVVMLight，它有以下特点： 更高：版本号更高，一出手就是 7.0。 更快：速度更快，MVVM Toolkit 从一开始就以高性能为实现目标。 更强：后台更强，MVVM Toolkit 的全称是 'Microsoft.Toolkit.Mvvm'，根正苗红。 2. 各个组件说明 前面说到 MVVM Toolkit 延续了 MVVMLight 的风格，因此他们大部分的组件都是相同的 2.1 ObservableObject ObservableObject 实现了 INotifyPropertyChanged 和INotifyPropertyChanging，并触发 PropertyChanged 和 PropertyChanging 事件。 12345678910public class User : ObservableObject&#123; private string name; public string Name &#123; get =&gt; name; set =&gt; SetProperty(ref name, value); &#125;&#125; 在这段示例代码中，如果 name 和 value 的值不同，首先触发 PropertyChanging 事件，然后触发 PropertyChanged。 2.2 RelayCommand RelayCommand 和 RelayCommand&lt;T&gt; 实现了 ICommand 接口，INotifyPropertyChanged 和 ICommand 是 MVVM 模式的基础。下面的代码使用 ObservableObject 和 RelayCommand 展示一个基本的 ViewModel： 12345678910111213141516171819public class MyViewModel : ObservableObject&#123; public MyViewModel() &#123; IncrementCounterCommand = new RelayCommand(IncrementCounter); &#125; private int counter; public int Counter &#123; get =&gt; counter; private set =&gt; SetProperty(ref counter, value); &#125; public ICommand IncrementCounterCommand &#123; get; &#125; private void IncrementCounter() =&gt; Counter++;&#125; 1234567891011121314&lt;Page x:Class=&quot;MyApp.Views.MyPage&quot; xmlns:viewModels=&quot;using:MyApp.ViewModels&quot;&gt; &lt;Page.DataContext&gt; &lt;viewModels:MyViewModel x:Name=&quot;ViewModel&quot;/&gt; &lt;/Page.DataContext&gt; &lt;StackPanel Spacing=&quot;8&quot;&gt; &lt;TextBlock Text=&quot;&#123;x:Bind ViewModel.Counter, Mode=OneWay&#125;&quot;/&gt; &lt;Button Content=&quot;Click me!&quot; Command=&quot;&#123;x:Bind ViewModel.IncrementCounterCommand&#125;&quot;/&gt; &lt;/StackPanel&gt;&lt;/Page&gt; 在这段示例里 IncrementCounterCommand 包装了 IncrementCounter 函数提供给 Button 绑定。IncrementCounter 函数更改 Counter 的值并通过 PropertyChanged 事件通知绑定的 TextBlock。 2.3 AsyncRelayCommand AsyncRelayCommand 和 AsyncRelayCommand&lt;T&gt; 也实现了 ICommand，不过它们支持异步操作，提供的 ExecutionTask 和 IsRunning 两个属性对监视任务运行状态十分有用。 例如这个 ViewModel： 12345678910111213public MyViewModel()&#123; DownloadTextCommand = new AsyncRelayCommand(DownloadTextAsync);&#125;public IAsyncRelayCommand DownloadTextCommand &#123; get; &#125;private async Task&lt;string&gt; DownloadTextAsync()&#123; await Task.Delay(3000); // Simulate a web request return &quot;Hello world!&quot;;&#125; 使用相关的 UI 代码： 123456789101112131415161718&lt;Page.Resources&gt; &lt;converters:TaskResultConverter x:Key=&quot;TaskResultConverter&quot;/&gt;&lt;/Page.Resources&gt;&lt;StackPanel Spacing=&quot;8&quot;&gt; &lt;TextBlock&gt; &lt;Run Text=&quot;Task status:&quot;/&gt; &lt;Run Text=&quot;&#123;x:Bind ViewModel.DownloadTextCommand.ExecutionTask.Status, Mode=OneWay&#125;&quot;/&gt; &lt;LineBreak/&gt; &lt;Run Text=&quot;Result:&quot;/&gt; &lt;Run Text=&quot;&#123;x:Bind ViewModel.DownloadTextCommand.ExecutionTask, Converter=&#123;StaticResource TaskResultConverter&#125;, Mode=OneWay&#125;&quot;/&gt; &lt;/TextBlock&gt; &lt;Button Content=&quot;Click me!&quot; Command=&quot;&#123;x:Bind ViewModel.DownloadTextCommand&#125;&quot;/&gt; &lt;muxc:ProgressRing HorizontalAlignment=&quot;Left&quot; IsActive=&quot;&#123;x:Bind ViewModel.DownloadTextCommand.IsRunning, Mode=OneWay&#125;&quot;/&gt;&lt;/StackPanel&gt; 点击 Button 后 DownloadTextAsync 开始运行，在 UI 上 TextBlock 和 ProgressRing 绑定到 ExecutionTask 和 IsRunning 并显示任务运行状态，最后通过 TaskResultConverter 显示任务结果。 2.4 Messenger 对于主要目的是松耦合的 MVVM 框架，提供一个用于消息交换的系统十分有必要。MVVM Toolkit 中用于消息交换的核心是 WeakReferenceMessenger 类。 123456789101112131415161718// Create a messagepublic class LoggedInUserChangedMessage : ValueChangedMessage&lt;User&gt;&#123; public LoggedInUserChangedMessage(User user) : base(user) &#123; &#125;&#125;// Register a message in some moduleWeakReferenceMessenger.Default.Register&lt;LoggedInUserChangedMessage&gt;(this, (r, m) =&gt;&#123; // Handle the message here, with r being the recipient and m being the // input messenger. Using the recipient passed as input makes it so that // the lambda expression doesn&#x27;t capture &quot;this&quot;, improving performance.&#125;);// Send a message from some other moduleWeakReferenceMessenger.Default.Send(new LoggedInUserChangedMessage(user)); 正如这段代码所示，WeakReferenceMessenger 主要通过 Register 和 Send 进行信息交换，它的使用方式类似于 MVVMLight 的 messenger 类。MVVM Toolkit 另外还提供了一个 StrongReferenceMessenger 类，更多使用方法可以参考这篇 文档。Messenger 功能强大且简单易用，但也由于误用会带来风险而引发了一些争议，有必要更详细地理解它的原理和用法以避免它带来的其它风险，这篇文章只是简单地介绍一下它的用法。 2.5 ObservableRecipient ObservableRecipient 继承了 ObservableObject 并支持从 Messenger 接收信息，可通过 IsActive 属性激活或停用。它可以用作 ViewModel 的基类，事实上它的作用基本上相遇于 MVVMLight 中的 ViewModelBase ： 1234567public class MyViewModel : ObservableRecipient, IRecipient&lt;LoggedInUserRequestMessage&gt;&#123; public void Receive(LoggedInUserRequestMessage message) &#123; // Handle the message here &#125;&#125; 2.6 ViewModelLocator 在 MVVMLight 中，很多人使用 ViewModelLocator，然后在 xaml 中 binding View 的 DataContext，但是到了 Microsoft.Toolkit.Mvvm 中，却没有默认提供，这里根据官方的 Ioc 迁移说明，给出一个 WPF 应用程序的 ViewModelLocator 的实现方式。 需要的 Package 12&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;6.0.0&quot; /&gt;&lt;PackageReference Include=&quot;Microsoft.Toolkit.Mvvm&quot; Version=&quot;7.1.2&quot; /&gt; ViewModelLocator.cs 代码文件如下 12345678910111213141516171819202122232425262728293031323334using Microsoft.Extensions.DependencyInjection;using Microsoft.Toolkit.Mvvm.DependencyInjection;using System;internal class ViewModelLocator&#123; public ViewModelLocator() &#123; ConfigureServices(); &#125; /// &lt;summary&gt; /// Configures the services for the application. /// &lt;/summary&gt; private IServiceProvider ConfigureServices() &#123; var services = new ServiceCollection(); // Services // services.AddSingleton&lt;IContactsService, ContactsService&gt;(); // services.AddSingleton&lt;IPhoneService, PhoneService&gt;(); // Viewmodels services.AddTransient&lt;MainViewModel&gt;(); var serviceProvider = services.BuildServiceProvider(); Ioc.Default.ConfigureServices(serviceProvider); return serviceProvider; &#125; public MainViewModel? MainVM &#123; get &#123; return Ioc.Default.GetService&lt;MainViewModel&gt;(); &#125; &#125;&#125; App.xaml 添加以下资源 123&lt;Application.Resources&gt; &lt;local:ViewModelLocator x:Key=&quot;Locator&quot; /&gt;&lt;/Application.Resources&gt; 在 View xaml 中的使用方法 123&lt;Window x:Class=&quot;Test.MainWindow&quot; DataContext=&quot;&#123;Binding Source=&#123;StaticResource Locator&#125;, Path=MainVM&#125;&quot;&lt;/Window&gt; 这样即可实现 MVVMLight 中 Locator 的效果。 3. The 性能 MVVM Toolkit 在开发过程中为了追求卓越的性能做了很多努力，例如提供一个 StrongReferenceMessenger 类，性能如上图所示地有了大幅提升。又例如下面这篇文章所介绍的： MVVM Toolkit Preview 3 &amp; The Journey of an API 有兴趣的话可以通过源码详细了解一下。","categories":[{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"MVVM","slug":"工具/MVVM","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/MVVM/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"https://buctllx.github.io/tags/MVVM/"}]},{"title":"WPF 窗口控件默认键盘焦点设置","slug":"WPF-窗口控件默认键盘焦点设置","date":"2022-03-14T06:10:52.000Z","updated":"2022-03-14T07:15:21.083Z","comments":true,"path":"2022/03/14/WPF-窗口控件默认键盘焦点设置/","link":"","permalink":"https://buctllx.github.io/2022/03/14/WPF-%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E9%BB%98%E8%AE%A4%E9%94%AE%E7%9B%98%E7%84%A6%E7%82%B9%E8%AE%BE%E7%BD%AE/","excerpt":"大家经常能够看到 WPF 窗口加载显示后，用户按 Tab 键，就会有一个控价获得焦点，如果这个控件是 Button，那么表现为：在 Button 文本周围有个虚线框；如果是 TextBox，那么表现为：在 TextBox 内部会有光标在闪烁。那么如何在 View 加载后设置默认显示这个效果，本文将会说明。 image-20220314142837858","text":"大家经常能够看到 WPF 窗口加载显示后，用户按 Tab 键，就会有一个控价获得焦点，如果这个控件是 Button，那么表现为：在 Button 文本周围有个虚线框；如果是 TextBox，那么表现为：在 TextBox 内部会有光标在闪烁。那么如何在 View 加载后设置默认显示这个效果，本文将会说明。 image-20220314142837858 一、关于 焦点 的 基本知识 焦点概述 - WPF .NET Framework | Microsoft Docs 为控件中的焦点设置样式以及 FocusVisualStyle - WPF .NET Framework | Microsoft Docs 两种焦点： 键盘焦点 逻辑焦点 这里有一段话明确说明了虚线框是键盘焦点的由来 Focus visual styles act only when the focus action was initiated by the keyboard. Any mouse action or programmatic focus change disables the mode for focus visual styles. 意思是：虚线框这种焦点效果，只能通过按 Tab 键进行触发 二、实现方案 明白了焦点效果产生的缘由，我们就可以思考如何实现 这里主要介绍如下实现方式； 2.1 模拟按键实现 既然只能通过按 Tab 键触发产生想要的效果，最直接的方法就是： 在 View 加载后，通过编码实现模拟用户按键到达想要的键盘焦点效果； 具体实现方式编码，可以通过 PInvoke SendInput 实现， 也可以使用封装好的第三方包，NuGet Gallery | InputSimulator 1.0.4 缺点： 要提前计算好要按几次才能达到指定的控件； 2.2 重写键盘焦点样式 在第一章节中了解了：想要的样式是通过那种 Style 控制产生的，那么我们就可以重新实现一种新的样式，默认显示我们想要的效果。 确定： 复杂，需要重写想过控件的样式 2.3 辅助方法实现 通过反射的方法，调用 ShowFocusVisual Internal 方法实现。 笔者用的就是这种方法，因为我的需要没有复杂的样式要求，只需要显示默认的键盘焦点样式即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public sealed class KeyboardHelper&#123; private static KeyboardHelper _Instance; private readonly PropertyInfo _AlwaysShowFocusVisual; private readonly MethodInfo _ShowFocusVisual; // Explicit static constructor to tell C# compiler // not to mark type as beforefieldinit static KeyboardHelper() &#123; &#125; private KeyboardHelper() &#123; var type = typeof(KeyboardNavigation); _AlwaysShowFocusVisual = type.GetProperty(&quot;AlwaysShowFocusVisual&quot;, BindingFlags.NonPublic | BindingFlags.Static); _ShowFocusVisual = type.GetMethod(&quot;ShowFocusVisual&quot;, BindingFlags.NonPublic | BindingFlags.Static); &#125; internal static KeyboardHelper Instance =&gt; _Instance ?? (_Instance = new KeyboardHelper()); internal void ShowFocusVisualInternal() &#123; _ShowFocusVisual.Invoke(null, null); &#125; internal bool AlwaysShowFocusVisualInternal &#123; get &#123; return (bool)_AlwaysShowFocusVisual.GetValue(null, null); &#125; set &#123; _AlwaysShowFocusVisual.SetValue(null, value, null); &#125; &#125; public static void Focus(UIElement element) &#123; element?.Dispatcher.BeginInvoke(DispatcherPriority.Background, new Action(() =&gt; &#123; var keybHack = KeyboardHelper.Instance; var oldValue = keybHack.AlwaysShowFocusVisualInternal; keybHack.AlwaysShowFocusVisualInternal = true; try &#123; Keyboard.Focus(element); keybHack.ShowFocusVisualInternal(); &#125; finally &#123; keybHack.AlwaysShowFocusVisualInternal = oldValue; &#125; &#125;)); &#125;&#125; 使用方法: 在构造方法中的 InitializeComponent 方法 或者 Loaded 后添加下方代码即可 1KeyboardHelper.Focus(this.OkBtn); // Button Name 缺点： 需要使用控件 Name； 三、总结 这第二章节中介绍了三种方法，大家可以根据自己的需要，选择合适的方法 笔者采用的是 2.3 ，目前没有发现什么问题； 参考链接： WPF Button to have Keyboard focus (dotted border around) during the startup or activation of window - Stack Overflow wpf - How to make CheckBox focus border appear when calling CheckBox.Focus()? - Stack Overflow","categories":[{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/categories/WPF/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/tags/WPF/"}]},{"title":"Visual Studio *.sln file 编辑 bug 记录","slug":"Visual-Studio-sln-file-编辑-bug-记录","date":"2022-03-03T05:47:03.000Z","updated":"2022-03-03T06:39:52.649Z","comments":true,"path":"2022/03/03/Visual-Studio-sln-file-编辑-bug-记录/","link":"","permalink":"https://buctllx.github.io/2022/03/03/Visual-Studio-sln-file-%E7%BC%96%E8%BE%91-bug-%E8%AE%B0%E5%BD%95/","excerpt":"sln 是 Visual Studio 20xx 自动创建的解决方案文件，里面存放了有关解决方案的设置信息，以及有关解决方案下项目文件的组织、结构、配置信息； 一般情况下，我们都是通过 Visual Studio 的可视化操作 对 sln 文件间接进行编辑修改的，但是有时候为了提高效果，需要手动进行编辑操作； 这里主要记录手动编辑 sln 文件遇到的问题：","text":"sln 是 Visual Studio 20xx 自动创建的解决方案文件，里面存放了有关解决方案的设置信息，以及有关解决方案下项目文件的组织、结构、配置信息； 一般情况下，我们都是通过 Visual Studio 的可视化操作 对 sln 文件间接进行编辑修改的，但是有时候为了提高效果，需要手动进行编辑操作； 这里主要记录手动编辑 sln 文件遇到的问题： 0. 有关 sln 文件的介绍 这里假设读者对 sln 文件有一定了解，因此不在详细说明，主要用来说明遇到的问题 有关 sln 文件可以参考官方文档：解决方案 (。Sln) 文件 - Visual Studio (Windows) | Microsoft Docs 理解 Visual Studio 解决方案文件格式（.sln） - walterlv 1. sln 修改后不起效的 bug 软件环境：visual studio 2022，sublime 3 1.1 问题描述 使用 sublime 打开 sln 文件，然后编辑 GlobalSection(SolutionConfigurationPlatforms) = preSolution 信息，如下图所示： image-20220303141026555 红框里面是新增的内容； 修改后保存，然后再 visual studio 中重新载入，发现：新增的解决方案配置项，并没有出现，如下图所示： image-20220303141324034 注：一开始编辑，全部没有出现，这里为了说明问题，故意显示 出 Release R21 Store，便于后面分析问题 1.2 问题分析 根据 1.1 中的现象发现，已经显示的配置项是 Release R21 Store，对应 sln 文件中的是 31 行，没有显示的是 32~40 行，这其中有什么区别不难发现。 唯一的区别是：31 行使用的 缩进是 tab 键，32~40 行使用的是空格 space； 注释：截图中的 —— 代表 Tab 键，…… 代表 Space 空格键 难道竟然是缩进符号的问题？？？ 通过验证发现：果然是缩进符号导致的 1.3 问题总结 产生问题的原因： 笔者再根据 githu 上一篇技术文档的介绍，进行 sln 文件的编辑修改，文档中建议使用编辑器打开手动修改，而且附加上了修改的内容，于是我便很轻易的点击 copy 按钮，进行复制、粘贴，发现没有任何效果。 浪费了半天的事件才发现是 缩进符号导致的， 而且还是在 Sublime 中选中状态下才能发现的 复制粘贴代码害死人，一定要注意。","categories":[{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/categories/VisualStudio/"}],"tags":[{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/tags/VisualStudio/"}]},{"title":"Visual Studio 代码格式化工具","slug":"Visual-Studio-代码格式化工具","date":"2022-03-01T07:43:28.000Z","updated":"2022-03-16T10:05:41.910Z","comments":true,"path":"2022/03/01/Visual-Studio-代码格式化工具/","link":"","permalink":"https://buctllx.github.io/2022/03/01/Visual-Studio-%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7/","excerpt":"Visual Studio 设置 - &gt; 选项 里面自身包含有部分代码格式化的功能，但是比较弱，面对复杂的项目代码，尤其是团队开发的时候，依然存在一些问题，不能够很好的规范，格式化项目代码；比如说 XAML 文件等。 本篇文章，结合 Visual Studio 的基础设置，同时配合 Visual Studio 扩展相关的代码格式化工具进行项目级别代码格式化规范的统一说明。","text":"Visual Studio 设置 - &gt; 选项 里面自身包含有部分代码格式化的功能，但是比较弱，面对复杂的项目代码，尤其是团队开发的时候，依然存在一些问题，不能够很好的规范，格式化项目代码；比如说 XAML 文件等。 本篇文章，结合 Visual Studio 的基础设置，同时配合 Visual Studio 扩展相关的代码格式化工具进行项目级别代码格式化规范的统一说明。 Visual Studio 代码格式化基础设置 vs 自带的文件格式化设置功能位于：工具 -&gt; 选项 -&gt; 文本编辑器 image-20220303115418833 在这里，既可以按照编程语言设置，也可以在“所有语言”中进行统一设置； 这里的设置都是一些基本的设置，比如说：行号，自动补全，缩进等； 以C#为例，在写代码的过程中一般只有在 补全 {} 的时候才会进行自动格式化，如果实在 {} 内部写代码，比如说缩进不对，没有加空格等，那么在保存的时候就不会自动格式化（除非使用了手动/快捷键格式化或者高级插件） 还有，在进行 XAML 开发的时候，由于其标签语言的特性，属性有时候会比较多，尤其实在团队开发的过程中，每个人都有自己的习惯，有些人喜欢一行写下去不带换行，有些喜欢加换行（换行的时候属性的数量也不同，极端的一个属性就换行，或者三五个属性后再换行），而且相同标签的空间在一起，属性的顺序也可能不一样，这就给代码的可读性增加了困难； 如何解决这些问题，下面将会结合高级工具进行说明； 1. Format Document On Save 扩展插件 主要用户解决，再保存代码的时候进行自动格式化； 保存操作支持 ctrl+s vs ide 中保存按钮 1.1 安装设置 插件链接：Format document on Save - Visual Studio Marketplace Elders/VSE-FormatDocumentOnSave: Visual Studio - Format Document on Save (github.com) 安装后，可以在 工具 -&gt; 选项 -&gt; Format Document On Save 中进行格式化的一些设置，操作； image-20220303120914539 设置项比较简单，也有注释，这里就不在一一说明了； 1.2 项目级使用 上面介绍的使用方法，可以满足一般个人的使用，但是在团队开发的过程中，每个人的设置可能不一样，如何解决这个问题能，这里就要使用到项目级的文件格式化配置 EditConfig。 项目级的文件格式化配置 EditConfig，不是针对某个人的；具有以下特点： 一个项目（sln）一个配置文件； 项目配置的优先级高于 工具 -&gt; 选项 -&gt; Format Document On Save 插件中的配置； 这样，有了EditorConfig 即便团队中的人员插件设置不一样，也能使用相同的格式化配置； 有关 EditorConfig 的详细信息可以查看链接，这里不详细说明了。 有了这个插件，可以很好的解决 99% 的代码格式问题，唯一例外的就是 xaml 文件不能格式化，这个会在下面单独说明。 2. XAML Styler 扩展插件 在 .Net 开发中，有一种特殊的代码文件：XAML，是前面讲的代码格式化插件所不能格式的； 而 XAML Styler 就是专门针对 xaml 文件进行格式化，这一点从名字上就能看出来。 参考链接：使用 XAML 格式化工具：XAML Styler - dino.c - 博客园 (cnblogs.com) 2.1 XAML 的问题 XAML 格式化主要的难题是下面几个： 如果所有属性都写在同一行，它太宽了很难看到后面的属性 如果每个属性单独一行，它又太长了很难看清楚它的结构 属性之间没有排序，重要属性的属性找起来很困难 团队没有统一的标准，不小心格式化一下代码的话全部都会变，CodeReview 烦死人 如果不想得过且过忍受上述这些问题的话，可以试试用 XAML Styler 这个工具，它正好解决了这些问题。 2.2 安装使用 XAML Styler 是一个 VisualStudio插件（也可用于其它 IDE），这是它在 Visual Studio Marketplace 和 Github 上的地址： XAML Styler - Visual Studio Marketplace Xavalon/XamlStyler: Visual Studio extension to help format your XAML source code (github.com) Home · Xavalon/XamlStyler Wiki (github.com) 在 VisualStudio 的管理扩展窗口中，输入 XamlStyle 搜索，点击“下载”然后关闭 VisualStudio 即可完成安装。 具体安装步骤不在这里说明了。 安装完成后重启 Visual Studio，可以在“选项”窗口中看到它的配置： 之后，每次在 XAML 编辑器中执行保存都会自动进行格式化操作。你也可以在 XAML 编辑器的右键菜单选择 Format XAML 或使用快捷键进行格式化。 2.3 关键格式化设置项说明 XAML 的格式主要有两种方式：所有属性放一行和每个属性单独一行。 如果选择所有属性放一行的时候，XAML 结构清晰，结构严谨，段落分明，而且文件也很短。 可是万一很多属性问题就出来了，一行 XAML 会变得很长。而且看看下面两个 ContentPresenter，同样都有 Margin 属性、HorizontalAlignment 属性，VerticalAlignment 属性，RecognizesAccessKey 属性，SnapsToDevicePixels 顺序ing，但你能看到第二个 ContentPresenter 后面偷偷塞了个 Margin 吗： 12Copy&lt;ContentPresenter Margin=&quot;&#123;TemplateBinding Padding&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot; SnapsToDevicePixels=&quot;&#123;TemplateBinding SnapsToDevicePixels&#125;&quot;/&gt;&lt;ContentPresenter Margin=&quot;&#123;TemplateBinding Padding&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot; SnapsToDevicePixels=&quot;&#123;TemplateBinding SnapsToDevicePixels&#125;&quot; Margin=&quot;40&quot;/&gt; 如果在 VisualStudio 中“文本编辑器-&gt;XAML-&gt;格式化-&gt;间距-&gt;特性间距”这个选项中选择了“将各个属性分别放置”： 格式化文档后上面的 XAML 就会变成这样： 1234567891011&lt;ContentPresenter Margin=&quot;&#123;TemplateBinding Padding&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot; SnapsToDevicePixels=&quot;&#123;TemplateBinding SnapsToDevicePixels&#125;&quot; /&gt;&lt;ContentPresenter Margin=&quot;&#123;TemplateBinding Padding&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot; SnapsToDevicePixels=&quot;&#123;TemplateBinding SnapsToDevicePixels&#125;&quot; Margin=&quot;40&quot; /&gt; 每个属性单独一行不仅不会看漏属性，而且编辑器本身也不会有横向和纵向两种方向的移动，只有从上到下的移动，这就舒服多了。 可是大部分情况下每个属性分行放置会破坏原本清晰的 XAML 层次结构，例如下面这种本来好好的 XAML: 123456&lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Normal&quot; /&gt;&lt;Setter Property=&quot;UseSystemFocusVisuals&quot; Value=&quot;True&quot; /&gt;&lt;Setter Property=&quot;FocusVisualMargin&quot; Value=&quot;-3&quot; /&gt;&lt;Setter Property=&quot;Height&quot; Value=&quot;50&quot; /&gt;&lt;Setter Property=&quot;Width&quot; Value=&quot;50&quot; /&gt;&lt;Setter Property=&quot;Maximum&quot; Value=&quot;1&quot; /&gt; 变成这样： 123456789101112&lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Normal&quot; /&gt;&lt;Setter Property=&quot;UseSystemFocusVisuals&quot; Value=&quot;True&quot; /&gt;&lt;Setter Property=&quot;FocusVisualMargin&quot; Value=&quot;-3&quot; /&gt;&lt;Setter Property=&quot;Height&quot; Value=&quot;50&quot; /&gt;&lt;Setter Property=&quot;Width&quot; Value=&quot;50&quot; /&gt;&lt;Setter Property=&quot;Maximum&quot; Value=&quot;1&quot; /&gt; 这种风格优雅得像诗歌 我偶尔称为豆瓣风 一行变两行 两行变四行 本来 一页看得完 的代码 变成 两页才看得完 也是够 麻烦的。 XAML Styler 很好地解决了这个问题，它通过 “Attribute tolerance” 属性控制每一行的容许的最多的属性数量，如果一个元素的属性数量少于设定值，那就放在一行，如果超过就所有属性单独一行。通常我将这个属性设置为 2，再配合 “Keep first attribute on same line = true” 的设置，可以做到下面这种格式化效果： 1234567891011121314151617&lt;SolidColorBrush x:Key=&quot;NormalTextColor&quot; Color=&quot;#2E2F33&quot; /&gt;&lt;SolidColorBrush x:Key=&quot;PrimaryColor&quot; Color=&quot;#FFED5B8C&quot; /&gt;&lt;SolidColorBrush x:Key=&quot;LineColor&quot; Color=&quot;#E1E1E1&quot; /&gt;&lt;SolidColorBrush x:Key=&quot;TransparentBackground&quot; Color=&quot;Transparent&quot; /&gt;&lt;ControlTemplate x:Key=&quot;CompletedTemplate&quot; TargetType=&quot;ContentControl&quot;&gt; &lt;Grid x:Name=&quot;CompletedElement&quot; Margin=&quot;-2&quot;&gt; &lt;control:DropShadowPanel HorizontalContentAlignment=&quot;Stretch&quot; VerticalContentAlignment=&quot;Stretch&quot; BlurRadius=&quot;8&quot; OffsetX=&quot;0&quot; OffsetY=&quot;0&quot; Color=&quot;#FFED5B8C&quot;&gt; &lt;Ellipse x:Name=&quot;CompletedRectangle&quot; Fill=&quot;&#123;StaticResource PrimaryColor&#125;&quot; /&gt; &lt;/control:DropShadowPanel&gt; &lt;/Grid&gt;&lt;/ControlTemplate&gt; 这样就可以兼顾两种格式化的优点。 2.4 排序 如果元素有多个属性，要找到它的主要属性（通常是 Name 和 Grid.Row）需要颇费一番功夫。XAML Styler 根据一个可设定的规则自动将元素的各个属性排序，这个规则如下： 12345678910111213&quot;AttributeOrderingRuleGroups&quot;: [ &quot;x:Class&quot;, &quot;xmlns, xmlns:x&quot;, &quot;xmlns:*&quot;, &quot;x:Key, Key, x:Name, Name, x:Uid, Uid, Title&quot;, &quot;Grid.Row, Grid.RowSpan, Grid.Column, Grid.ColumnSpan, Canvas.Left, Canvas.Top, Canvas.Right, Canvas.Bottom&quot;, &quot;Width, Height, MinWidth, MinHeight, MaxWidth, MaxHeight&quot;, &quot;Margin, Padding, HorizontalAlignment, VerticalAlignment, HorizontalContentAlignment, VerticalContentAlignment, Panel.ZIndex&quot;, &quot;*:*, *&quot;, &quot;PageSource, PageIndex, Offset, Color, TargetName, Property, Value, StartPoint, EndPoint&quot;, &quot;mc:Ignorable, d:IsDataSource, d:LayoutOverrides, d:IsStaticText&quot;, &quot;Storyboard.*, From, To, Duration&quot;], 排序结果大致如下： 123456789&lt;Button x:Name=&quot;Show&quot; Grid.Row=&quot;1&quot; Padding=&quot;40,20&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Background=&quot;#00aef1&quot; Content=&quot;Show&quot; Foreground=&quot;White&quot; Style=&quot;&#123;StaticResource BubbleButtonStyle&#125;&quot; /&gt; 2.5 项目级使用 最后，就算自己做好了格式化，团队中的其它成员使用了不同的格式化标准也会引起很多问题。针对这个问题 Xaml Styler 也提供了解决方案。 在项目的根目录创建一个名为“Settings.XamlStyler”的文件，内容参考这个网址：https://github.com/Xavalon/XamlStyler/wiki/External-Configurations 中的 Default Configuration。有了这个配置文件，XAML Styler 就会根据它而不是全局配置进行格式化，作为项目的统一格式化标准。 2.6 ctrl+s 保存时的冲突问题解决 设置完这两个插件后，在实际使用的过程中可能会发现：在使用 ctrl + s 保存的时候会达不到效果 现象分析 在 xaml 中按 ctrl + s 保存的时候，仔细查看画面，会发现 xaml 文件被保存了两次，而且第一一闪而过的结果好像还是正确的，最初呈现的第二次保存解决却不对了， 原因分析 根据现象可以分析出来，不止一个插件触发了xaml 的保存操作，那个捣乱者是谁，很容易想到是 Format Document On Save 解决方法 从现象中我们看到，保存了两次导致解结果不对； 那么就有两个解决方案： 让 xaml styler 最后保存， 不然 Format Document On Save 保存 xaml； 方案 1 我们无法控制保存顺序，暂时无解； 方案 2 如果我们在设置中可以设置 不存在 xaml 文件就可以了，或许可行 打开 Format Document On Save 设置信息，我们仔细查看，有一个叫 Denied Extensions 的设置项，我们可以通过它设置不格式化 xaml 文件，设置后试了一些，依然达不到效果，查看那里除了问题，仔细看 Denied Extensions 设置项的说明发现： Denied Extensions 设置项，只有在 Allowed Extensions 设置项为空的情况下才能生效，于是赶紧删除试一下，果然成功了。","categories":[{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"VisualStudio","slug":"工具/VisualStudio","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/VisualStudio/"}],"tags":[{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/tags/VisualStudio/"},{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"使用 Windows Server 建立 Web Site 并关联 FTP Server","slug":"使用-Windows-Server-建立-Web-Site-并关联-FTP-Server","date":"2022-01-25T03:20:44.000Z","updated":"2022-01-25T03:41:16.430Z","comments":true,"path":"2022/01/25/使用-Windows-Server-建立-Web-Site-并关联-FTP-Server/","link":"","permalink":"https://buctllx.github.io/2022/01/25/%E4%BD%BF%E7%94%A8-Windows-Server-%E5%BB%BA%E7%AB%8B-Web-Site-%E5%B9%B6%E5%85%B3%E8%81%94-FTP-Server/","excerpt":"本文主要说明，如何在 windows server 中建立 web site，并关联 ftp 服务；最终达到的效果是，可以通过 https 链接访问 ftp 服务的所有内容； 系统环境：window server 2019","text":"本文主要说明，如何在 windows server 中建立 web site，并关联 ftp 服务；最终达到的效果是，可以通过 https 链接访问 ftp 服务的所有内容； 系统环境：window server 2019 1、开启系统必备的服务组件 2、新建 SSL 证书 3、建立 web site 并关联 FTP Server 4、其他设置 4.1 ftp 服务直通网络位置 4.2 web site 开启浏览文件目录结构的功能 4.3 web site 绑定 https 访问 参考资料：","categories":[{"name":"windwos","slug":"windwos","permalink":"https://buctllx.github.io/categories/windwos/"},{"name":"web site","slug":"windwos/web-site","permalink":"https://buctllx.github.io/categories/windwos/web-site/"},{"name":"ftp server","slug":"windwos/ftp-server","permalink":"https://buctllx.github.io/categories/windwos/ftp-server/"}],"tags":[{"name":"windwos","slug":"windwos","permalink":"https://buctllx.github.io/tags/windwos/"},{"name":"web site","slug":"web-site","permalink":"https://buctllx.github.io/tags/web-site/"},{"name":"ftp","slug":"ftp","permalink":"https://buctllx.github.io/tags/ftp/"}]},{"title":"Revit 构件参数体系说明","slug":"Revit-构件参数体系说明","date":"2022-01-20T10:45:52.000Z","updated":"2022-01-25T06:24:30.143Z","comments":true,"path":"2022/01/20/Revit-构件参数体系说明/","link":"","permalink":"https://buctllx.github.io/2022/01/20/Revit-%E6%9E%84%E4%BB%B6%E5%8F%82%E6%95%B0%E4%BD%93%E7%B3%BB%E8%AF%B4%E6%98%8E/","excerpt":"1、Revit 构件分类说明 从不同的维度 Revit 构件（图元）有不同的分类； 对用用户来说：最为熟悉的就是“项目浏览器”中“族”节点的三级分类： 这里主要介绍以下几种分类维度；","text":"1、Revit 构件分类说明 从不同的维度 Revit 构件（图元）有不同的分类； 对用用户来说：最为熟悉的就是“项目浏览器”中“族”节点的三级分类： 这里主要介绍以下几种分类维度； 1.1 常见的三级分类 三级分类，一般用于用户分类管理各种构件，方便用户快速检索使用； 每一级分类都有自己的参数，只不过用户经常关注的时：类型参数、实例参数而已 image-20220121142116181 1.1.1 一级分类 - 类别 英文名字也是 API 的名字：Category Category 是 Revit 软件内置的基础数据，不能被用户和开发者“增删改”，用户只有使用权限； 对于某个确定的 Revit 版本 Category 数量是固定的，只有在 Revit 版本的变化的时候 Category 才可能变化（一般是新增） Category 内部也是有联系的，具体变现为子类别 SubCategory，这一点一般用户是看不到的； 下面是 Revit API 暴露出来的所有的 Category，可以通过切花版本查看； Revit API BuiltInCategory Enumeration (revitapidocs.com) 经过个人统计 Category 发现： 总数：2000+ 一般项目中用到的：900左右 实际建模常用的：不超过100 1.1.2 二级分类 - 族 Family 在类别之下的二级分类； 所有添加到 Revit 项目中的图元都是使用族创建的。 族 在 Revit 中也分为多种类型，具有一定的可扩展性，但并不是所有的族都能扩展，后面 1.2 章节会说明 这里需要特殊说明的是：族并不是单一的构件，它是可以嵌套，复合的，从而生成更加复杂高级的族； 更多详细说明参见 Autodesk Revit 官方文档：帮助: Revit 族 (autodesk.com) 1.1.3 三级分类 - 类型 xxx_Type，FamilySymbol 一个族，可以有多个类型；一般叫：族类型； 类型是用户建模的时候必须指定的信息， 指定了类型，就只定了族和类别； 类型下面就是“图元”了，也可以叫构件；所谓图元，就是在模型视图中实实在在看到的对象，但被选中时，会高亮显示，并且会在“属性”窗口中显示图元的参数信息； “属性”窗口中显示的并不是图元所有的属性信息 1.2 按族类型分类 1.2.1 系统族 特点： Revit 软件内置的，所有的 rvt 文件都是一样的； 有限的； 用户不能自己添加 / 删除（Revit 升级的时候或许会新增）； 常见的系统族：墙，楼板、各种管线、屋顶、…… 1.2.2 载入族 特点： 以 rfa 文件的形式存在； 可以载入不同的 rvt 文件中复用； 用户可以自己新增或者删除； 常见的系统族：梁、柱、管件、管道附件、末端、家具、设备…… 1.2.3 内建族 特点： 只存在于某一个 rvt 文件内，不能被复用； 只包含一个类型且类型名称和族名称一样 用户可以自己新增或者删除； 可以随意指定，创建的时候只需要指定 类别，输入一个族名称，Revit 就会自动创建一个内建族 1.3 按 Category 类型分类 这种分类是按照 Category 的属性信息 Category Type 进行划分的 一般较少关注 1.3.1 模型类构件(模型族) 可以在三维视图中进行查看的； 例如：墙、梁、板、柱、…… 1.3.2 详图类构件(注释族) 在平面视图中进行辅助查看，不能在三维视图中看到； 例如：标记、尺寸标注、…… 1.3.3 分析类构件(分析族) Revit 中有一个单独的分析模块，分析族用来展示分析结果的 例如：分析墙、分析柱、…… 1.3.4 内部类构件(内部族) Revit 内部使用的； 用户一般不直接使用，通常起到辅助类的构件； 例如：结构连接处理程序、部件、…… 2、Revit 参数分类说明 Revit 参数也有多个分类的维度， 这里主要介绍以下几种分类维度 2.1 按作用的层级 作用层级包含了三级分类，在 1.1 中说明过，每一级都有自己的描述参数； 除了三级分类，这里补充说明了“项目参数”和“实例参数” 2.1.1 项目级参数 这里项目有别于建筑设计的项目，意思是 rvt 文件，Revit 默认一个 rvt 文件就是一个项目文件，rvt 文件级别的参数就是项目参数，不同的 rvt 文件可以定义不同数量的参数； 所有的项目参数集合在一起，叫做“项目信息”，也是一个 Category 类别 符合 Revit 添加参数的统一流程 除此之外还有一种特殊的项目参数叫“全局参数”，是 2016 R2 以后新增的，具体参见 2.2 2.1.2 族级参数 被用来描述族 Family 的相关信息； 一边较少使用，且不能增删改 image-20220121181936225 2.1.3 类型级参数 一个族一般有多个类型，一个类型之所以区别于另一个类型，就是因为类型参数的参数值不一样（如果一样，那么就可以认为是相同的类型，就没必要新建这个类型了） 为了描述族下面的多个类型，因此产生了类型参数； image-20220121182705093 2.1.4 实例级参数 视图中看到的每一个图元，都有自己的属性信息，这些属性信息都是通过实例参数描述的； 具体变现为：Revit “属性”窗口中看到的参数（上面截图，左侧部分） 2.2 按参数的定义 这种分类方式，只关心参数是如何定义的，不关心这个参数将会被用于描述哪个对象； 通过不同不同的定义方式，可以将参数分为以下几类； 2.2.1 内置参数 BuiltinParameter 在 Revit 中通过枚举的方式暴露出来，用户不能做任何修改； BuiltInParameter Enumeration (revitapidocs.com) 2.2.2 共享参数 用户通过共享参数文件定义； 一般情况下一个用户定义并使用一个共享参数文件，也可以做到多个用户使用同一个共享参数文件； 2.2.3 族参数 在编辑 rfa 文件过程中定义的参数； image-20220121185129566 根据创建方式的不同，还可以划分为： 共享参数 一般族参数 这类参数比较特殊，该类型的参数只能在族文件范围内定义， 简单来说就是，只能在编辑 rfa 文件的时候进行定义；且有效的使用范围只能在 rfa 文件内部； 这中参数是造成 revit 参数被滥用的一个原因 族参数，在族内部作用的层级，还可以划分为： 类型参数 实例参数； 参考：2.1 中的类型参数和实例参数； 2.2.4 全局参数 image-20220124162335058 全局参数是 Autodesk 在 Revit 2016 R2 版本（17 及其以后的版本都有）增加的内容，是继共享参数与项目参数之后新增加的一种参数。 全局参数特定于单个项目文件，但未像项目参数那样指定给类别。全局参数可以是简单值、来自表达式的值或使用其他全局参数从模型获取的值。 有点类似于族文件里的“一般族参数” 详细的使用方式和案例，参见官方文档：帮助: 全局参数 (autodesk.com) 3、Revit 参数管理体系 Revit 中的参数主要有两类： 常规参数 材质类参数 3.1 常规参数的定义管理体系 在 Revit 中所有的参数都必须先定义，然后才能被使用； 关于参数定义，Revit 有自己的一套管理体系； 下面截图是各种参数的定义截图 [共享参数定义][项目参数定义][项目参数使用共享参数定义][族参数定义] image-20220121145632974 image-20220121150553052 image-20220121151733095 image-20220121151930344 从上面的截图可以看出来，用于参数管理的主要有以下几个信息： 规程 参数类型 参数分组 参数分组方式 类型 or 实例 是否报告参数 这些信息，主要用于描述一个参数，方便 Revit 对参数进行管理； “参数定义”并不关注这个参数将会被用于描述什么对象，或者单位是什么；参数的 描述对象，单位信息，则是通过一种关联关系进行使用 因为： 一个参数的定义可以被用于描述一个或者多个对象，在给对象添加参数的时候，去选择已经定义好的参数就行了；【添加项目参数的后最右侧会有关联对象的选择】 一个参数可能没有单位或者有多个单位；具体选择哪个单位，在显示或者使用的时候确定就可以了，如下图所示； image-20220121174516331 3.2 材质类参数管理体系 材质类参数，因为涉及到渲染、显示，因此十分复杂；Autodesk 的很多建模软件使用的材质库都是独立的，并不共享； 因为材质相关的参数体系太过复杂，API暴露有是有限的，所以下面主要以介绍为主； 功能入口：管理 -&gt; 设置 -&gt; 材质 在这里用户可以自己创建、定义、编辑、修改与材质相关的各种信息； [土建材质 - 示例][机电材质 - 示例] image-20220124163727041 image-20220124163317836 从上面的截图看，材质信息主要包含以下几类信息： 标识 图形 外观 物理（可选） 热度（可选） 每一类，都包含若干参数，并且通过分组进行管理 3.3 通用参数值的管理 上面说完了参数定义，另外一个话题就是参数值； 3.3.1 通用参数(值)特点 因为存在这样一部分参数，他们对于参数值的填写是有一些基本要求的； 比如说：颜色，只能在 0 ~ 255 之间； 还有一类：提供一些基本的参数值，让用户进行选择；同时可以暴露一些参数值定义的接口，让用户可以先定义参数值，然后再选择参数值进行使用。 这类参数值都有一些特点： 有限 可枚举 比较常见、通用 跟其他参数或者对象有关联关系 这类参数，主要集中在 管理 -&gt; 设置 面板中 3.3.2 例子 （1）规程类参数： 规程参数各处都有用，参数值是 Revit 规定的有限的几个，与其他参数有关联，比如说：参数分组，子规程等 （2）建筑/空间 类型参数 image-20220124171308987 （3）机电 - 系统类型 参数 image-20220124170329124 （4）显示类参数(值) 填充样式 线样式 线宽 线型图案 材质资源 这些跟材质或者显示类的参数都有关系，主要影响的就是渲染显示。","categories":[{"name":"Revit","slug":"Revit","permalink":"https://buctllx.github.io/categories/Revit/"}],"tags":[{"name":"Revit","slug":"Revit","permalink":"https://buctllx.github.io/tags/Revit/"}]},{"title":"Hexo 集成 PicGo Github 图床","slug":"Hexo-集成-PicGo-Github-图床","date":"2022-01-20T10:15:23.000Z","updated":"2022-01-20T10:40:20.604Z","comments":true,"path":"2022/01/20/Hexo-集成-PicGo-Github-图床/","link":"","permalink":"https://buctllx.github.io/2022/01/20/Hexo-%E9%9B%86%E6%88%90-PicGo-Github-%E5%9B%BE%E5%BA%8A/","excerpt":"0、背景说明 博主原来使用七牛云图床，好处：10G 免费空间；坏处：域名有效期一个月；超出一个月就没法使用了； 因而转向了其他图床，发现 PicGo 中支持的图床有 Github，觉得是一个不错的选择 使用 Github 图床的好处： 没有域名限制； 仓库虽然空间有限（1G），但是满了可以再新建一个仓库，因此相当于无限 有人说慢，但是可以设置加速 稳定，不用担心挂了或者失效","text":"0、背景说明 博主原来使用七牛云图床，好处：10G 免费空间；坏处：域名有效期一个月；超出一个月就没法使用了； 因而转向了其他图床，发现 PicGo 中支持的图床有 Github，觉得是一个不错的选择 使用 Github 图床的好处： 没有域名限制； 仓库虽然空间有限（1G），但是满了可以再新建一个仓库，因此相当于无限 有人说慢，但是可以设置加速 稳定，不用担心挂了或者失效 参考： MarkDown、Hexo博客、Coding托管、GitHub做图床、CDN加速 - 段十三 - 博客园 (cnblogs.com) 1、新建一个仓库 名字自定义，例如：pic_bed 选择 Public 勾选初始化复选框： Initialize this repository with a README 点击 Create repository 创建成功 New personal access token (github.com) 配置图床的时候要用： Note下面的文本框内容自定义 下面很多复选框，只需要勾选 repo 也就是第一个复选框 最下面点击Generate token即可生成 下面要用，如果忘记了可以在重新生成 2、安装配置 PicGo 下载安装，这里不再说明， 安装后启动 PicGo，找到 Github 图床，如下图所示： image-20220120182829709 填写第一步中创建的 仓库名，分支名，以及 Token 然后“确定”，并设置为默认图床即可 3、配置 JsDeliv，给图片镶上加速器 比如在GitHub的图片路径是：https://github.com/user/pic_bed/img/test_image.png 拼接链接方法1：https://cdn.jsdelivr.net/gh/user/pic_bed@latest/img/test_image.png 拼接链接方法2：https://cdn.jsdelivr.net/gh/user/pic_bed/img/test_image.png 将方法1和方法2拼接起来的链接前缀输入到上图第5步的自定义域名中即可 拼接链接方法1：https://cdn.jsdelivr.net/gh/user/pic_bed@latest/ 拼接链接方法2：https://cdn.jsdelivr.net/gh/user/pic_bed/ 4、再 Typora 中选择 PicGo app 作为图片上传服务 Typora 设置关联七牛云图床 | ConorLuo 博客 (buctllx.github.io)","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"},{"name":"PicGo","slug":"Hexo/PicGo","permalink":"https://buctllx.github.io/categories/Hexo/PicGo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"},{"name":"PicGo","slug":"PicGo","permalink":"https://buctllx.github.io/tags/PicGo/"}]},{"title":"Windows Terminal 集成 Oh My Posh","slug":"Windows-Terminal-集成-Oh-My-Posh","date":"2021-12-29T03:52:56.000Z","updated":"2022-05-27T07:37:36.283Z","comments":true,"path":"2021/12/29/Windows-Terminal-集成-Oh-My-Posh/","link":"","permalink":"https://buctllx.github.io/2021/12/29/Windows-Terminal-%E9%9B%86%E6%88%90-Oh-My-Posh/","excerpt":"1. 准备安装环境 Windows Termianl, PowerShell 都可以从 Microsoft Store 中下载 Windows Terminal (Windows 自带) PowerShell 具体安装这里不做详细说明","text":"1. 准备安装环境 Windows Termianl, PowerShell 都可以从 Microsoft Store 中下载 Windows Terminal (Windows 自带) PowerShell 具体安装这里不做详细说明 2. 安装 Oh My Posh 这里推荐去 Oh My Posh 官方网站查看最新的安装方法； 网上的大部分教程，存在时效性问题，因为 Oh My Posh 是不断更新的，不同时间不同版本的安装方法可能不一样 因此搜索到的二手安装教程不一定使用目前安装的你 Home | Oh My Posh Introduction | Oh My Posh 2.1 参考文档： 将美化进行到底，使用 Oh My Posh 把 PowerShell 做成 oh-my-zsh 的样子 - walterlv Making Windows Terminal look awesome with oh-my-posh and new fonts. (zimmergren.net) 2.2 可能使用到的命令 1234567891011121314# 查看已经安装的模块Get-InstalledModule# 当前用户安装一个模块 （-Verbose 参数显示细节）全局使用 AllUsers Install-Module oh-my-posh -Scope CurrentUser -Verbose# 导入加载一个模块 （-Verbose 参数显示细节）Import-Module oh-my-posh -Verbose# 卸载一个模块Uninstall-Module -Name oh-my-posh# 查看 PowerShell 安装源 GalleryGet-PSRepository 参考链接： Install-Module (PowerShellGet) - PowerShell | Microsoft Docs Get-PSRepository (PowerShellGet) - PowerShell | Microsoft Docs PowerShell Gallery | Home 关于配置文件 - PowerShell | Microsoft Docs 2.3 字体选择 官方推荐 Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp; fonts patcher 下载自定后安装方法： 解压、进入字体目录、全选、右键、安装 即可 3. Posh-Git 安装 dahlbyk/posh-git: A PowerShell environment for Git (github.com) Posh-Git 提供了强大的 tab 补全功能， 并针对提示符进行了增强；可以在 Terminal 中使用 官方文档安装方法： Git - Git 在 PowerShell 中使用 Git (git-scm.com) 1Install-Module posh-git -Scope CurrentUser -Force 这里不做详细说明 特殊说明 win 10 用户如果修改了用户文件夹的目录，会导致 $PROFILE 信息失效 ； 这个时候需要确认一下 $PROFILE 的最新路径，以及该路径下时候又相关配置； 如果需要修改 $PROFILE 的路径，可以参考： powershell - Is it possible to change the default value of $profile to a new value? - Stack Overflow PowerShell 7 Profile Paths and Locations - ridicurious.com 我这边是通过修改注册表修改成功恢复的","categories":[{"name":"Termianl","slug":"Termianl","permalink":"https://buctllx.github.io/categories/Termianl/"},{"name":"PowerShell","slug":"Termianl/PowerShell","permalink":"https://buctllx.github.io/categories/Termianl/PowerShell/"}],"tags":[{"name":"Termianl,PowerShell,Oh-My-Posh","slug":"Termianl-PowerShell-Oh-My-Posh","permalink":"https://buctllx.github.io/tags/Termianl-PowerShell-Oh-My-Posh/"}]},{"title":"Hexo Next Theme 使用问题总结","slug":"Hexo-Next-Theme-使用问题总结","date":"2021-12-21T09:36:03.000Z","updated":"2021-12-22T03:35:02.306Z","comments":true,"path":"2021/12/21/Hexo-Next-Theme-使用问题总结/","link":"","permalink":"https://buctllx.github.io/2021/12/21/Hexo-Next-Theme-%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"两个路径说明： site root directory：博客站点根目录 theme root directory：博客主题根目录 后面说明问题会一直沿用这中叫法； 1. 部署后“搜索”功能无法使用 原因 使用了最新的 master 版本，master 分支是主题作者的开发分支，每周都会更新，当时不稳定","text":"两个路径说明： site root directory：博客站点根目录 theme root directory：博客主题根目录 后面说明问题会一直沿用这中叫法； 1. 部署后“搜索”功能无法使用 原因 使用了最新的 master 版本，master 分支是主题作者的开发分支，每周都会更新，当时不稳定 解决方法 拉去稳定版本的分支，主要看最新的 Tag 参考 Issues 链接：https://github.com/hexojs/hexo/issues/4654 2. 替换图片资源路径 主题涉及到的，各种图片资源都是可以替换的， **替换路径：theme root directory* 为了显示效果，注意替换的图片最好是对应像素的，而且不易过大，图片类型可以自己修改 可替换图片说明： 图片名称 含义 avatar 博主图像 favicon-16x16-next 网站图标 16x16 像素 favicon-32x32-next 网站图标 32x32 像素 logo log apple-touch-icon-next 触摸图标 alipay 支付宝收款二维码 weixin 微信收款二维码 3. 增加自定义的“标签”，“分类”页面 默认安装好的 next 主题，是没有“标签”，“分类”页面的； 需要使用者自己新增页面： 新增方法：以“标签”也为例说明： 使用 hexo 命令新建 tags.md页面 12# cd site root directoryhexo new page tags 打开 tags.md 并修改页面类型 type 信息 123title: Tagsdate: 2021-12-22 12:00:00type: tags 修改主题配置文件 12345# cd next/_config.ymlmenu: home: / || fa fa-home archives: /archives/ || fa fa-archive tags: /tags/ || fa fa-tags 4. 开启首页文章部分显示 next 主题默认的是将你的文章全篇显示在自己的首页上，这就会导致一个问题，首页各个文章太长了不利于翻阅 想要让文章部分显示，并出现“阅读全文的按钮”，只需要在个人的文章 Markdown 源文件中添加一行代码就行 1&lt;!--more--&gt; 具体位置，自己确定，在自己想要显示的文章部分下面加上即可只在首页显示所需的文章部分。 参考文档： Custom Pages | NexT (theme-next.js.org) 创建分类页面 · iissnan/hexo-theme-next Wiki (github.com) Hexo + Theme Next -- 写作 | Knner.Wang's Blog","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"},{"name":"Hexo Theme","slug":"Hexo/Hexo-Theme","permalink":"https://buctllx.github.io/categories/Hexo/Hexo-Theme/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"},{"name":"Theme","slug":"Theme","permalink":"https://buctllx.github.io/tags/Theme/"}]},{"title":"ElasticSearch 操作异常总结","slug":"ElasticSearch-操作异常总结","date":"2021-12-15T09:41:01.000Z","updated":"2021-12-22T10:33:37.292Z","comments":true,"path":"2021/12/15/ElasticSearch-操作异常总结/","link":"","permalink":"https://buctllx.github.io/2021/12/15/ElasticSearch-%E6%93%8D%E4%BD%9C%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/","excerpt":"1. Index 写入数据 FORBIDDEN 问题 1.1 问题描述 在使用七牛云的 Logkit 往 ElasticSearch 发送数据的时候出现了以下异常信息； 123456789101112# SendError: bulk failed with last error&#123; &quot;_index&quot;:&quot;dev_cbim_tool_log&quot;, &quot;_type&quot;:&quot;cbim_tool_log&quot;, &quot;_id&quot;:&quot;UhoDvX0B7FSmwLI_OPym&quot;, &quot;status&quot;:403, &quot;error&quot;:&#123; &quot;type&quot;:&quot;cluster_block_exception&quot;, &quot;reason&quot;:&quot;blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];&quot; &#125;&#125;# failDatas size : 33 其核心异常提示是：[FORBIDDEN/12/index read-only / allow delete (api)]","text":"1. Index 写入数据 FORBIDDEN 问题 1.1 问题描述 在使用七牛云的 Logkit 往 ElasticSearch 发送数据的时候出现了以下异常信息； 123456789101112# SendError: bulk failed with last error&#123; &quot;_index&quot;:&quot;dev_cbim_tool_log&quot;, &quot;_type&quot;:&quot;cbim_tool_log&quot;, &quot;_id&quot;:&quot;UhoDvX0B7FSmwLI_OPym&quot;, &quot;status&quot;:403, &quot;error&quot;:&#123; &quot;type&quot;:&quot;cluster_block_exception&quot;, &quot;reason&quot;:&quot;blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];&quot; &#125;&#125;# failDatas size : 33 其核心异常提示是：[FORBIDDEN/12/index read-only / allow delete (api)] 1.2 原因分析 从字面意思看，ES 禁止数据写入； 联想到最近服务器发生的一系列问题，一切都能解释的通了； 最近发现：ES 集群的一个节点挂了（主要是因为服务器的磁盘坏了）； 在这样的情况下，触发了 ES 的保护机制，因此出现了上面的情况； 1.3 解决方法 1curl -XPUT -H &quot;Content-Type: application/json&quot; http://localhost:9200/_all/_settings -d &#x27;&#123;&quot;index.blocks.read_only_allow_delete&quot;: null&#125;&#x27; 参考链接：[如何修复 ElasticSearch FORBIDDEN/12/index read-only / allow delete （api）] – TechOverflow 2. ElasticSearch 启动参数问题 通过 docker 启动 es 的时候，相关参数设置跟 es 的镜像版本有关； 这里主要说明常见的各种 es 设置问题 2.1 unknown setting [discovery.seed_hosts] 产生背景 使用2019年的老脚本启动 es 的 docker 实例； 注：笔者是 2021.12.15 pull 最新的 es 镜像启动实例的，启动实例使用的参数是 2019 年底时的； 原因 2019 年底的 es 镜像和 2021 年的镜像文件参数设置不一致， 可以通过 dock inspect elasticsearch 查看 解决方法 使用下面的配置替代 1discovery.zen.ping.unicast.hosts: [&quot;192.168.10.11:9300&quot;,&quot;192.168.10.12:9300&quot;,&quot;192.168.10.13:9300&quot;] 注意：启动脚本，最好跟 docker 镜像配套使用 类似的问题 unknown setting [cluster.initial_master_nodes] 2.2 ES 缓存设置 默认设置：ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" 启动的时候可以加 -e 指定参数 1-e ES_JAVA_OPTS=&quot;-Xms1g -Xmx1g&quot; 设置过大可能导致本机缓存不够，启动时有如下错误提示： max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 解决方法：修改 centos 系统的缓存设置 1234567# 1. open and edit confvi /etc/sysctl.conf# 2. add at last vm.max_map_count=262144# 3. apply/sbin/sysctl -p 3. ElasticSearch 集群状态排查 Elasticsearch 集群故障排查及修复指南_铭毅天下（公众号同名）-CSDN博客 4. ES 索引 primary shard is unassigned 解决方法 12345678910111213POST /_cluster/reroute&#123; &quot;commands&quot; : [ &#123; &quot;allocate_stale_primary&quot; : &#123; &quot;index&quot; : &quot;.monitoring-kibana-6-2021.12.17&quot;, &quot;shard&quot; : 0, &quot;node&quot; : &quot;es-node-2&quot;, &quot;accept_data_loss&quot; : true &#125; &#125; ]&#125; [ES 遇到 unassigned shard如何处理？_weixin_34050519的博客-CSDN博客](https://blog.csdn.net/weixin_34050519/article/details/85936609) 解决elasticsearch分片unassigned的3个方法_dlm_bk的博客-CSDN博客_es分片unassigned","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://buctllx.github.io/categories/ElasticSearch/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://buctllx.github.io/tags/ElasticSearch/"},{"name":"ES","slug":"ES","permalink":"https://buctllx.github.io/tags/ES/"}]},{"title":"Typora 设置关联七牛云图床","slug":"Typora-设置关联七牛云图床","date":"2021-12-06T06:46:25.000Z","updated":"2021-12-22T03:34:21.566Z","comments":true,"path":"2021/12/06/Typora-设置关联七牛云图床/","link":"","permalink":"https://buctllx.github.io/2021/12/06/Typora-%E8%AE%BE%E7%BD%AE%E5%85%B3%E8%81%94%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A/","excerpt":"1. 七牛云存储环境准备 1.1 注册 七牛云官网：七牛云 - 国内领先的企业级云服务商 (qiniu.com) 注册流程不在这里详细说明； 说一下注意事项： 注册后，需要实名认证 个人认证 即可","text":"1. 七牛云存储环境准备 1.1 注册 七牛云官网：七牛云 - 国内领先的企业级云服务商 (qiniu.com) 注册流程不在这里详细说明； 说一下注意事项： 注册后，需要实名认证 个人认证 即可 1.2 新建图床存储空间 登录后，通过“管理控制台”进入管理页面； 点击“对象存储 Kodo”； 点击“空间管理” -&gt; “新建空间” 进行图床空间创建； 如下图所示，设置完相关参数，即可创建一个图床存储空间； image-20211207135828755 注意事项： 访问权限选择“公开” 存储区域一般选择“距离自己比较近的”，并且不同区域有不同的代号，后面会用到 2. PicGo 安装 PicGo 有两种类型； PicGo App（应用程序） PicGo-Core（命令行版本） 2.1 安装 2.1.1 图形界面版本 PicGo图形 选择对应系统的安装包安装即可 2.1.2 命令行版本 PicGo-core 没有nodejs环境，使用typora一键安装即可 本机有nodjs环境，直接npm全局安装 123npm install picgo -g# oryarn global add picgo 插件安装 picgo-plugin-web-uploader 这是一款可以上传自定义图床的插件 1picgo install web-uploader 2.2 配置 关于存储区域的填写跟在七牛云上新建空间的地理位置有关； 具体参考：存储区域_产品简介_对象存储 - 七牛开发者中心 (qiniu.com) image-20211206144124515 2.2.1 图形版直接图形界面配置 参考配置 image-20211208133520184 2.2.2 图形版直接图形界面配置 参考配置文件 123456789101112131415161718&#123; &quot;picBed&quot;: &#123; &quot;uploader&quot;: &quot;qi_niu&quot;, &quot;current&quot;: &quot;qi_niu&quot;, &quot;qi_niu&quot;: &#123; &quot;accessKey&quot;: &quot;you-access-key&quot;, &quot;secretKey&quot;: &quot;you-secret-key&quot;, &quot;bucket&quot;: &quot;blog-pic-resp&quot;, &quot;url&quot;: &quot;http://you-url&quot;, &quot;area&quot;: &quot;z1&quot;, &quot;options&quot;: &quot;&quot;, &quot;path&quot;: &quot;&quot; &#125; &#125;, &quot;picgoPlugins&quot;: &#123; &quot;picgo-plugin-web-uploader&quot;: true &#125;&#125; 3. Typora 图片存储设置 设置入口：设置 - 偏好设置 - 图像； 如下图所示： image-20211207102745086 image-20211207102901759 插入图片时：选择：上传图片； 上传服务设定 上传服务：选择：PicGo（app） PicGo 路径：选择：自己安装时候的路径 当上述两大项设置完毕后，点击：“验证图片上传选项” 设置成功后，会出现“验证成功”的提示，如下图： 如果你的主题设置是 Onedark 一类的黑色主题，这个提示可能会不明显，需要仔细查看才能看到； image-20211207103956991 image-20211207104327148","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://buctllx.github.io/categories/Markdown/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://buctllx.github.io/tags/PicGo/"},{"name":"Typora","slug":"Typora","permalink":"https://buctllx.github.io/tags/Typora/"}]},{"title":"Git fetch 同时更新子模块","slug":"Git-fetch-同时更新子模块","date":"2021-12-02T10:25:13.000Z","updated":"2021-12-22T03:34:02.662Z","comments":true,"path":"2021/12/02/Git-fetch-同时更新子模块/","link":"","permalink":"https://buctllx.github.io/2021/12/02/Git-fetch-%E5%90%8C%E6%97%B6%E6%9B%B4%E6%96%B0%E5%AD%90%E6%A8%A1%E5%9D%97/","excerpt":"1. 问题描述 默认情况，git checkout; git fetch 如果子模块 submodule 的版本不一致， git 是不会自动更新子模块；","text":"1. 问题描述 默认情况，git checkout; git fetch 如果子模块 submodule 的版本不一致， git 是不会自动更新子模块； 2. 传统解决方法： cd submodules 文件夹； git checkout / fetch； 3. 高级解决方法： 在全局进行 Git 设置： 1 git config --global submodule.recurse true 设置 submodule.recurse true 后，不仅仅 git checkout 会自动切换子模块，git fetch / pull 也会自动拉取子模块的更新 注意：这个设置对用户机器上安装的 git 版本有要求，详见下面说明 在发行说明中提到了这一点：https://github.com/git/git/commit/e1104a5ee539408b81566066aaa6963cb87d5cd6#diff-c24776ff22455a30fbb78e378b7df0b0R139 submodule.recurse 选项已添加到 git 2.14","categories":[{"name":"Git 相关","slug":"Git-相关","permalink":"https://buctllx.github.io/categories/Git-%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://buctllx.github.io/tags/Git/"}]},{"title":"WPF 在 Trigger 中修改 Button Content 注意事项","slug":"WPF-在-Trigger-中修改-Button-Content-注意事项","date":"2021-12-02T08:52:58.000Z","updated":"2021-12-22T03:34:31.422Z","comments":true,"path":"2021/12/02/WPF-在-Trigger-中修改-Button-Content-注意事项/","link":"","permalink":"https://buctllx.github.io/2021/12/02/WPF-%E5%9C%A8-Trigger-%E4%B8%AD%E4%BF%AE%E6%94%B9-Button-Content-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"1. 问题描述 xaml 代码块如下： 12345678910111213&lt;Button Content=&quot;333&quot;&gt; &lt;Button.Style&gt; &lt;Style TargetType=&quot;Button&quot;&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;70&quot;/&gt; &lt;Setter Property=&quot;Height&quot; Value=&quot;27&quot;/&gt; &lt;Style.Triggers&gt; &lt;DataTrigger Binding=&quot;&#123;Binding ElementName=listBox, Path=SelectedIndex&#125;&quot; Value=&quot;2&quot;&gt; &lt;Setter Property=&quot;Content&quot; Value=&quot;three&quot; /&gt; &lt;/DataTrigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/Button.Style&gt; &lt;/Button&gt; 运行后，触发 DataTrigger 发现 Button 的 Content 没有变化","text":"1. 问题描述 xaml 代码块如下： 12345678910111213&lt;Button Content=&quot;333&quot;&gt; &lt;Button.Style&gt; &lt;Style TargetType=&quot;Button&quot;&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;70&quot;/&gt; &lt;Setter Property=&quot;Height&quot; Value=&quot;27&quot;/&gt; &lt;Style.Triggers&gt; &lt;DataTrigger Binding=&quot;&#123;Binding ElementName=listBox, Path=SelectedIndex&#125;&quot; Value=&quot;2&quot;&gt; &lt;Setter Property=&quot;Content&quot; Value=&quot;three&quot; /&gt; &lt;/DataTrigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/Button.Style&gt; &lt;/Button&gt; 运行后，触发 DataTrigger 发现 Button 的 Content 没有变化 2. 原因和解决方法 原因：定义 Button 的时候直接指定 Content 相当于定死了 Button 的 Content ，所以在 Style 的 Trigger 中就无法修改了； 注意： 这个时候如果指定有默认的 Button Style，默认样式也会失效；原因是重写了 Style； 解决方案：将 Content 的默认值，写进 Button.Style，如下所示： 1234567891011121314&lt;Button&gt; &lt;Button.Style&gt; &lt;Style TargetType=&quot;Button&quot;&gt; &lt;Setter Property=&quot;Content&quot; Value=&quot;333&quot;/&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;70&quot;/&gt; &lt;Setter Property=&quot;Height&quot; Value=&quot;27&quot;/&gt; &lt;Style.Triggers&gt; &lt;DataTrigger Binding=&quot;&#123;Binding ElementName=listBox, Path=SelectedIndex&#125;&quot; Value=&quot;2&quot;&gt; &lt;Setter Property=&quot;Content&quot; Value=&quot;three&quot; /&gt; &lt;/DataTrigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/Button.Style&gt; &lt;/Button&gt;","categories":[{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/categories/WPF/"}],"tags":[{"name":".Net","slug":"Net","permalink":"https://buctllx.github.io/tags/Net/"},{"name":"C#","slug":"C","permalink":"https://buctllx.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/tags/WPF/"},{"name":"Style","slug":"Style","permalink":"https://buctllx.github.io/tags/Style/"}]},{"title":"wpf control window 范围内默认样式对第一个控件无效","slug":"wpf-control-window-范围内默认样式对第一个控件无效","date":"2021-12-02T07:12:32.000Z","updated":"2021-12-22T03:42:14.493Z","comments":true,"path":"2021/12/02/wpf-control-window-范围内默认样式对第一个控件无效/","link":"","permalink":"https://buctllx.github.io/2021/12/02/wpf-control-window-%E8%8C%83%E5%9B%B4%E5%86%85%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%E5%AF%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%8E%A7%E4%BB%B6%E6%97%A0%E6%95%88/","excerpt":"1、问题描述 wpf 页面设计中，有时候在 xaml 文件 Resource 中指定 window 范围的默认 control style，但是却发现对第一个控件不起作用，具体如下：","text":"1、问题描述 wpf 页面设计中，有时候在 xaml 文件 Resource 中指定 window 范围的默认 control style，但是却发现对第一个控件不起作用，具体如下： 1234567891011121314151617181920212223242526&lt;Window x:Class=&quot;TestApp.TestWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;TestWindow&quot; Height=&quot;400&quot; Width=&quot;500&quot; WindowStyle=&quot;None&quot; WindowState=&quot;Maximized&quot;&gt; &lt;Window.Resources&gt; &lt;ResourceDictionary&gt; &lt;ResourceDictionary.MergedDictionaries&gt; &lt;ResourceDictionary Source=&quot;Resources/AllResources.xaml&quot;/&gt; &lt;ResourceDictionary&gt; &lt;Style TargetType=&quot;&#123;x:Type Button&#125;&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;100&quot;/&gt; &lt;/Style&gt; &lt;/ResourceDictionary&gt; &lt;/ResourceDictionary.MergedDictionaries&gt; &lt;/ResourceDictionary&gt; &lt;/Window.Resources&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Column=&quot;0&quot; Content=&quot;1&quot; Name=&quot;Button1&quot;/&gt; &lt;Button Grid.Column=&quot;1&quot; Content=&quot;2&quot; Name=&quot;Button2&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; button1 的 FontSize 并不是 100；但是 button2 却没问题； 通常我们使用下面的代码是没问题的； 12345678910111213141516171819&lt;Window x:Class=&quot;TestApp.TestWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;TestWindow&quot; Height=&quot;400&quot; Width=&quot;500&quot; WindowStyle=&quot;None&quot; WindowState=&quot;Maximized&quot;&gt; &lt;Window.Resources&gt; &lt;Style TargetType=&quot;&#123;x:Type Button&#125;&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;100&quot;/&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Column=&quot;0&quot; Content=&quot;1&quot; Name=&quot;Button1&quot;/&gt; &lt;Button Grid.Column=&quot;1&quot; Content=&quot;2&quot; Name=&quot;Button2&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; 2、原因和解决方法 2.1 原因 因为把 Button 默认样式放在了 ResourceDictionary.MergedDictionaries 内部的ResourceDictionary 内了，这样在解析引用样式的时候会跳过第一个元素； 2.2 解决方案 将 style 提到 ResourceDictionary.MergedDictionaries 之外 123456789101112131415161718&lt;Window.Resources&gt; &lt;ResourceDictionary&gt; &lt;ResourceDictionary.MergedDictionaries&gt; &lt;ResourceDictionary Source=&quot;Resources/AllResources.xaml&quot;/&gt; &lt;/ResourceDictionary.MergedDictionaries&gt; &lt;Style TargetType=&quot;&#123;x:Type Button&#125;&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;100&quot;/&gt; &lt;/Style&gt; &lt;/ResourceDictionary&gt;&lt;/Window.Resources&gt;&lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Column=&quot;0&quot; Content=&quot;1&quot; Name=&quot;Button1&quot;/&gt; &lt;Button Grid.Column=&quot;1&quot; Content=&quot;2&quot; Name=&quot;Button2&quot;/&gt;&lt;/Grid&gt; 参考链接：resources - WPF doesn't apply style to first element - Stack Overflow","categories":[{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/categories/WPF/"}],"tags":[{"name":".Net","slug":"Net","permalink":"https://buctllx.github.io/tags/Net/"},{"name":"C#","slug":"C","permalink":"https://buctllx.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/tags/WPF/"},{"name":"Style","slug":"Style","permalink":"https://buctllx.github.io/tags/Style/"}]},{"title":"Fist Blog","slug":"test-my-site","date":"2020-04-12T15:31:00.000Z","updated":"2022-03-17T01:46:37.447Z","comments":true,"path":"2020/04/12/test-my-site/","link":"","permalink":"https://buctllx.github.io/2020/04/12/test-my-site/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"}]},{"title":"Hello Hexo","slug":"hello-world","date":"2020-04-12T10:25:00.000Z","updated":"2022-03-30T07:32:11.285Z","comments":true,"path":"2020/04/12/hello-world/","link":"","permalink":"https://buctllx.github.io/2020/04/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"}]}],"categories":[{"name":"DB","slug":"DB","permalink":"https://buctllx.github.io/categories/DB/"},{"name":"基础知识","slug":"DB/基础知识","permalink":"https://buctllx.github.io/categories/DB/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"MongoDB","slug":"DB/MongoDB","permalink":"https://buctllx.github.io/categories/DB/MongoDB/"},{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"IFC","slug":"工具/IFC","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/IFC/"},{"name":"Maven","slug":"工具/Maven","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/Maven/"},{"name":"network","slug":"network","permalink":"https://buctllx.github.io/categories/network/"},{"name":"Nginx","slug":"工具/Nginx","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/Nginx/"},{"name":"MVVM","slug":"工具/MVVM","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/MVVM/"},{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/categories/WPF/"},{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/categories/VisualStudio/"},{"name":"VisualStudio","slug":"工具/VisualStudio","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/VisualStudio/"},{"name":"windwos","slug":"windwos","permalink":"https://buctllx.github.io/categories/windwos/"},{"name":"web site","slug":"windwos/web-site","permalink":"https://buctllx.github.io/categories/windwos/web-site/"},{"name":"ftp server","slug":"windwos/ftp-server","permalink":"https://buctllx.github.io/categories/windwos/ftp-server/"},{"name":"Revit","slug":"Revit","permalink":"https://buctllx.github.io/categories/Revit/"},{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"},{"name":"PicGo","slug":"Hexo/PicGo","permalink":"https://buctllx.github.io/categories/Hexo/PicGo/"},{"name":"Termianl","slug":"Termianl","permalink":"https://buctllx.github.io/categories/Termianl/"},{"name":"PowerShell","slug":"Termianl/PowerShell","permalink":"https://buctllx.github.io/categories/Termianl/PowerShell/"},{"name":"Hexo Theme","slug":"Hexo/Hexo-Theme","permalink":"https://buctllx.github.io/categories/Hexo/Hexo-Theme/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://buctllx.github.io/categories/ElasticSearch/"},{"name":"Markdown","slug":"Markdown","permalink":"https://buctllx.github.io/categories/Markdown/"},{"name":"Git 相关","slug":"Git-相关","permalink":"https://buctllx.github.io/categories/Git-%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://buctllx.github.io/tags/DB/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://buctllx.github.io/tags/MongoDB/"},{"name":"IFC","slug":"IFC","permalink":"https://buctllx.github.io/tags/IFC/"},{"name":"BIM","slug":"BIM","permalink":"https://buctllx.github.io/tags/BIM/"},{"name":"Maven","slug":"Maven","permalink":"https://buctllx.github.io/tags/Maven/"},{"name":"network","slug":"network","permalink":"https://buctllx.github.io/tags/network/"},{"name":"Nginx","slug":"Nginx","permalink":"https://buctllx.github.io/tags/Nginx/"},{"name":"FileBrowsern","slug":"FileBrowsern","permalink":"https://buctllx.github.io/tags/FileBrowsern/"},{"name":"MVVM","slug":"MVVM","permalink":"https://buctllx.github.io/tags/MVVM/"},{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/tags/WPF/"},{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/tags/VisualStudio/"},{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"windwos","slug":"windwos","permalink":"https://buctllx.github.io/tags/windwos/"},{"name":"web site","slug":"web-site","permalink":"https://buctllx.github.io/tags/web-site/"},{"name":"ftp","slug":"ftp","permalink":"https://buctllx.github.io/tags/ftp/"},{"name":"Revit","slug":"Revit","permalink":"https://buctllx.github.io/tags/Revit/"},{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"},{"name":"PicGo","slug":"PicGo","permalink":"https://buctllx.github.io/tags/PicGo/"},{"name":"Termianl,PowerShell,Oh-My-Posh","slug":"Termianl-PowerShell-Oh-My-Posh","permalink":"https://buctllx.github.io/tags/Termianl-PowerShell-Oh-My-Posh/"},{"name":"Theme","slug":"Theme","permalink":"https://buctllx.github.io/tags/Theme/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://buctllx.github.io/tags/ElasticSearch/"},{"name":"ES","slug":"ES","permalink":"https://buctllx.github.io/tags/ES/"},{"name":"Typora","slug":"Typora","permalink":"https://buctllx.github.io/tags/Typora/"},{"name":"Git","slug":"Git","permalink":"https://buctllx.github.io/tags/Git/"},{"name":".Net","slug":"Net","permalink":"https://buctllx.github.io/tags/Net/"},{"name":"C#","slug":"C","permalink":"https://buctllx.github.io/tags/C/"},{"name":"Style","slug":"Style","permalink":"https://buctllx.github.io/tags/Style/"}]}