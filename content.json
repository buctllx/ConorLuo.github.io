{"meta":{"title":"ConorLuo 博客","subtitle":"胆小认生，不易相处","description":"北京化工大学10级，从事工程建设行业开发，擅长.Net, Python。此为博客一枚。","author":"ConorLuo","url":"https://buctllx.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-12-20T05:54:39.000Z","updated":"2021-12-20T06:01:52.896Z","comments":false,"path":"tags/index.html","permalink":"https://buctllx.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-12-20T05:59:49.000Z","updated":"2021-12-20T06:01:59.580Z","comments":false,"path":"categories/index.html","permalink":"https://buctllx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Nginx 反向代理 FileBrowser","slug":"Nginx-反向代理-FileBrowser","date":"2022-03-23T10:47:42.000Z","updated":"2022-03-23T11:40:59.089Z","comments":true,"path":"2022/03/23/Nginx-反向代理-FileBrowser/","link":"","permalink":"https://buctllx.github.io/2022/03/23/Nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-FileBrowser/","excerpt":"本文主要说明如果使用 Nginx 方向代理已经启动的 FileBrowser 服务。","text":"本文主要说明如果使用 Nginx 方向代理已经启动的 FileBrowser 服务。 1. 准备工作开始本文的主要内容前，默认已经做好了以下准备工作 使用 linux 系统，比如 centos； 已安装并启动 nginx 服务 已安装并启动 filebrowser 服务 2. 有关 FileBrowser 的配置如果不知道已经启动的 filebrowser 服务的相关配置，可以通过以下命令查看 123# 1. 查看 filebrowser 服务的进程 (可以看到启动命令的相关参数，比如说配置文件，数据库文件等)ps -ef |grep filebrowserpstree -ap |grep filebrowser 123456789101112# 2. 导出 filebrowser 的配置信息cd /etc/filebrowser # 首先进入包含 filebrowser 可执行文件的目录filebrowser config cat # 临时查看filebrowser config export config.json # 导出 filebrowser 配置信息到 config.json 文件# 如果存在多个 db 可以通过 -d 参数导出指定数据库中存储的配置信息(其他命令也是如此，后面不在重复说明举例)filebrowser -d /etc/filebrowser/filebrowser.db config export config.json# 可能用到的其他命令filebrowser users update admin -p admin # 更新 admin 用户的密码为 adminfilebrowser config set --port 18080 # 重新设置端口信息 以下 json 信息是我用到的配置 123456789101112131415&#123; &quot;port&quot;: 18080, &quot;root&quot;:&quot;/data/file&quot;, &quot;database&quot;:&quot;/etc/filebrowser/filebrowser.db&quot;, &quot;log&quot;:&quot;/etc/filebrowser/log.log&quot;, &quot;plugin&quot;: &quot;&quot;, &quot;baseURL&quot;: &quot;/files&quot;, &quot;allowCommands&quot;: true, &quot;allowEdit&quot;: true, &quot;allowNew&quot;: true, &quot;commands&quot;: [ &quot;ls&quot;, &quot;df&quot; ]&#125; 需要注意的问题： baseURL 配置项的值在后面 nginx 的配置中要使用到，一定要记录下来；如果没有设置，默认值是 files， 强烈建议设置一下； 使用 vi 或者 vim 写 json 配置文件的时候一定要注意，缩进符号是 空格，而且不能和 tab 混合用；尤其是从网页上面复制 json 文本的时候一定要确保是空格（有些网页上的缩进是 tab，但是默认空白看不到） 3. 在 Nginx 中配置 FileBrowser 服务核心配置如下： 12345678910111213server &#123; listen 80; server_name ai.cbim.com 10.80.253.133; access_log /var/logs/nginx/filebrowser.access.log; # file browser url location ^~ /files/ &#123; proxy_pass http://127.0.0.1:18080/; proxy_set_header Host $proxy_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 需要注意的问题： server_name 不要和 nginx/conf.d 中其他的配置文件中的 server_name 重复，否则可能被忽略； location 后面的匹配项，一定要和 前面 filebrowser 配置文件中的 baseURL 配置项保持一致，否则无法代理成功； location 的具体匹配规则视情况而定，我这里通过 ^~ 匹配以 files 开头的所有 api；^~ 如果删除，而又没有其他 location 匹配规则，同样会导致代理失败，无法访问 filebrowser 4. 相关参考资料：nginx documentation filebrowser/filebrowser: 📂 Web File Browser (github.com) Welcome - File Browser file browser介绍 - shanyu20 - 博客园 (cnblogs.com) timeout on commands that connect to a locked database · Issue #627 · filebrowser/filebrowser (github.com) Usable configuration for executing command behind NGINX. · Issue #549 · filebrowser/filebrowser (github.com)","categories":[{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Nginx","slug":"工具/Nginx","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://buctllx.github.io/tags/Nginx/"},{"name":"FileBrowsern","slug":"FileBrowsern","permalink":"https://buctllx.github.io/tags/FileBrowsern/"}]},{"title":"Microsoft.Toolkit.Mvvm 使用记录","slug":"Microsoft-Toolkit-Mvvm-使用记录","date":"2022-03-16T02:22:18.000Z","updated":"2022-03-16T03:33:24.722Z","comments":true,"path":"2022/03/16/Microsoft-Toolkit-Mvvm-使用记录/","link":"","permalink":"https://buctllx.github.io/2022/03/16/Microsoft-Toolkit-Mvvm-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"1. Microsoft.Toolkit.Mvvm 介绍 模型-视图-视图模型 (MVVM) 是用于解耦 UI 代码和非 UI 代码的 UI 体系结构设计模式。 借助 MVVM，可以在 XAML 中以声明方式定义 UI，并使用数据绑定标记将 UI 链接到包含数据和命令的其他层。 MVVM 最早是 Microsoft 提出来的，但是官方一直没有提供框架；很多人会说 Prism 框架，但是 Prism 已经出走了，而且比较臃肿；至于 MVVMLight 也很久没有更新了，直到 2020 年 Windows Community Toolkit 开源了一套 MVVM 框架 Microsoft.Toolkit.Mvvm。","text":"1. Microsoft.Toolkit.Mvvm 介绍 模型-视图-视图模型 (MVVM) 是用于解耦 UI 代码和非 UI 代码的 UI 体系结构设计模式。 借助 MVVM，可以在 XAML 中以声明方式定义 UI，并使用数据绑定标记将 UI 链接到包含数据和命令的其他层。 MVVM 最早是 Microsoft 提出来的，但是官方一直没有提供框架；很多人会说 Prism 框架，但是 Prism 已经出走了，而且比较臃肿；至于 MVVMLight 也很久没有更新了，直到 2020 年 Windows Community Toolkit 开源了一套 MVVM 框架 Microsoft.Toolkit.Mvvm。 Windows Community Toolkit 除了提供开源框架，也贴心的在文档中提供了，基本的使用案例，以及从其他 MVVM 框架迁移到 Microsoft.Toolkit.Mvvm 框架的说明文档。 官方文档：Introduction to the MVVM Toolkit - Windows Community Toolkit | Microsoft Docs [WPF] 使用 MVVM Toolkit 构建 MVVM 程序 - dino.c - 博客园 (cnblogs.com) MVVM Toolkit 延续了 MVVMLight 的风格，是一个轻量级的组件，而且它基于 .NET Standard 2.0，可用于UWP, WinForms, WPF, Xamarin, Uno 等多个平台。相比它的前身 MVVMLight，它有以下特点： 更高：版本号更高，一出手就是 7.0。 更快：速度更快，MVVM Toolkit 从一开始就以高性能为实现目标。 更强：后台更强，MVVM Toolkit 的全称是 ‘Microsoft.Toolkit.Mvvm’，根正苗红。 2. 各个组件说明前面说到 MVVM Toolkit 延续了 MVVMLight 的风格，因此他们大部分的组件都是相同的 2.1 ObservableObjectObservableObject 实现了 INotifyPropertyChanged 和INotifyPropertyChanging，并触发 PropertyChanged 和 PropertyChanging 事件。 12345678910public class User : ObservableObject&#123; private string name; public string Name &#123; get =&gt; name; set =&gt; SetProperty(ref name, value); &#125;&#125; 在这段示例代码中，如果 name 和 value 的值不同，首先触发 PropertyChanging 事件，然后触发 PropertyChanged。 2.2 RelayCommandRelayCommand 和 RelayCommand&lt;T&gt; 实现了 ICommand 接口，INotifyPropertyChanged 和 ICommand 是 MVVM 模式的基础。下面的代码使用 ObservableObject 和 RelayCommand 展示一个基本的 ViewModel： 12345678910111213141516171819public class MyViewModel : ObservableObject&#123; public MyViewModel() &#123; IncrementCounterCommand = new RelayCommand(IncrementCounter); &#125; private int counter; public int Counter &#123; get =&gt; counter; private set =&gt; SetProperty(ref counter, value); &#125; public ICommand IncrementCounterCommand &#123; get; &#125; private void IncrementCounter() =&gt; Counter++;&#125; 1234567891011121314&lt;Page x:Class=&quot;MyApp.Views.MyPage&quot; xmlns:viewModels=&quot;using:MyApp.ViewModels&quot;&gt; &lt;Page.DataContext&gt; &lt;viewModels:MyViewModel x:Name=&quot;ViewModel&quot;/&gt; &lt;/Page.DataContext&gt; &lt;StackPanel Spacing=&quot;8&quot;&gt; &lt;TextBlock Text=&quot;&#123;x:Bind ViewModel.Counter, Mode=OneWay&#125;&quot;/&gt; &lt;Button Content=&quot;Click me!&quot; Command=&quot;&#123;x:Bind ViewModel.IncrementCounterCommand&#125;&quot;/&gt; &lt;/StackPanel&gt;&lt;/Page&gt; 在这段示例里 IncrementCounterCommand 包装了 IncrementCounter 函数提供给 Button 绑定。IncrementCounter 函数更改 Counter 的值并通过 PropertyChanged 事件通知绑定的 TextBlock。 2.3 AsyncRelayCommandAsyncRelayCommand 和 AsyncRelayCommand&lt;T&gt; 也实现了 ICommand，不过它们支持异步操作，提供的 ExecutionTask 和 IsRunning 两个属性对监视任务运行状态十分有用。 例如这个 ViewModel： 12345678910111213public MyViewModel()&#123; DownloadTextCommand = new AsyncRelayCommand(DownloadTextAsync);&#125;public IAsyncRelayCommand DownloadTextCommand &#123; get; &#125;private async Task&lt;string&gt; DownloadTextAsync()&#123; await Task.Delay(3000); // Simulate a web request return &quot;Hello world!&quot;;&#125; 使用相关的 UI 代码： 123456789101112131415161718&lt;Page.Resources&gt; &lt;converters:TaskResultConverter x:Key=&quot;TaskResultConverter&quot;/&gt;&lt;/Page.Resources&gt;&lt;StackPanel Spacing=&quot;8&quot;&gt; &lt;TextBlock&gt; &lt;Run Text=&quot;Task status:&quot;/&gt; &lt;Run Text=&quot;&#123;x:Bind ViewModel.DownloadTextCommand.ExecutionTask.Status, Mode=OneWay&#125;&quot;/&gt; &lt;LineBreak/&gt; &lt;Run Text=&quot;Result:&quot;/&gt; &lt;Run Text=&quot;&#123;x:Bind ViewModel.DownloadTextCommand.ExecutionTask, Converter=&#123;StaticResource TaskResultConverter&#125;, Mode=OneWay&#125;&quot;/&gt; &lt;/TextBlock&gt; &lt;Button Content=&quot;Click me!&quot; Command=&quot;&#123;x:Bind ViewModel.DownloadTextCommand&#125;&quot;/&gt; &lt;muxc:ProgressRing HorizontalAlignment=&quot;Left&quot; IsActive=&quot;&#123;x:Bind ViewModel.DownloadTextCommand.IsRunning, Mode=OneWay&#125;&quot;/&gt;&lt;/StackPanel&gt; 点击 Button 后 DownloadTextAsync 开始运行，在 UI 上 TextBlock 和 ProgressRing 绑定到 ExecutionTask 和 IsRunning 并显示任务运行状态，最后通过 TaskResultConverter 显示任务结果。 2.4 Messenger对于主要目的是松耦合的 MVVM 框架，提供一个用于消息交换的系统十分有必要。MVVM Toolkit 中用于消息交换的核心是 WeakReferenceMessenger 类。 123456789101112131415161718// Create a messagepublic class LoggedInUserChangedMessage : ValueChangedMessage&lt;User&gt;&#123; public LoggedInUserChangedMessage(User user) : base(user) &#123; &#125;&#125;// Register a message in some moduleWeakReferenceMessenger.Default.Register&lt;LoggedInUserChangedMessage&gt;(this, (r, m) =&gt;&#123; // Handle the message here, with r being the recipient and m being the // input messenger. Using the recipient passed as input makes it so that // the lambda expression doesn&#x27;t capture &quot;this&quot;, improving performance.&#125;);// Send a message from some other moduleWeakReferenceMessenger.Default.Send(new LoggedInUserChangedMessage(user)); 正如这段代码所示，WeakReferenceMessenger 主要通过 Register 和 Send 进行信息交换，它的使用方式类似于 MVVMLight 的 messenger 类。MVVM Toolkit 另外还提供了一个 StrongReferenceMessenger 类，更多使用方法可以参考这篇 文档。Messenger 功能强大且简单易用，但也由于误用会带来风险而引发了一些争议，有必要更详细地理解它的原理和用法以避免它带来的其它风险，这篇文章只是简单地介绍一下它的用法。 2.5 ObservableRecipientObservableRecipient 继承了 ObservableObject 并支持从 Messenger 接收信息，可通过 IsActive 属性激活或停用。它可以用作 ViewModel 的基类，事实上它的作用基本上相遇于 MVVMLight 中的 [ViewModelBase](https://github.com/lbugnion/mvvmlight/blob/master/GalaSoft.MvvmLight/GalaSoft.MvvmLight (PCL)/ViewModelBase.cs) ： 1234567public class MyViewModel : ObservableRecipient, IRecipient&lt;LoggedInUserRequestMessage&gt;&#123; public void Receive(LoggedInUserRequestMessage message) &#123; // Handle the message here &#125;&#125; 2.6 ViewModelLocator在 MVVMLight 中，很多人使用 ViewModelLocator，然后在 xaml 中 binding View 的 DataContext，但是到了 Microsoft.Toolkit.Mvvm 中，却没有默认提供，这里根据官方的 Ioc 迁移说明，给出一个 WPF 应用程序的 ViewModelLocator 的实现方式。 需要的 Package 12&lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;6.0.0&quot; /&gt;&lt;PackageReference Include=&quot;Microsoft.Toolkit.Mvvm&quot; Version=&quot;7.1.2&quot; /&gt; ViewModelLocator.cs 代码文件如下 12345678910111213141516171819202122232425262728293031323334using Microsoft.Extensions.DependencyInjection;using Microsoft.Toolkit.Mvvm.DependencyInjection;using System;internal class ViewModelLocator&#123; public ViewModelLocator() &#123; ConfigureServices(); &#125; /// &lt;summary&gt; /// Configures the services for the application. /// &lt;/summary&gt; private IServiceProvider ConfigureServices() &#123; var services = new ServiceCollection(); // Services // services.AddSingleton&lt;IContactsService, ContactsService&gt;(); // services.AddSingleton&lt;IPhoneService, PhoneService&gt;(); // Viewmodels services.AddTransient&lt;MainViewModel&gt;(); var serviceProvider = services.BuildServiceProvider(); Ioc.Default.ConfigureServices(serviceProvider); return serviceProvider; &#125; public MainViewModel? MainVM &#123; get &#123; return Ioc.Default.GetService&lt;MainViewModel&gt;(); &#125; &#125;&#125; App.xaml 添加以下资源 123&lt;Application.Resources&gt; &lt;local:ViewModelLocator x:Key=&quot;Locator&quot; /&gt;&lt;/Application.Resources&gt; 在 View xaml 中的使用方法 123&lt;Window x:Class=&quot;Test.MainWindow&quot; DataContext=&quot;&#123;Binding Source=&#123;StaticResource Locator&#125;, Path=MainVM&#125;&quot;&lt;/Window&gt; 这样即可实现 MVVMLight 中 Locator 的效果。 3. The 性能 MVVM Toolkit 在开发过程中为了追求卓越的性能做了很多努力，例如提供一个 StrongReferenceMessenger 类，性能如上图所示地有了大幅提升。又例如下面这篇文章所介绍的： MVVM Toolkit Preview 3 &amp; The Journey of an API 有兴趣的话可以通过源码详细了解一下。","categories":[{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"MVVM","slug":"工具/MVVM","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/MVVM/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"https://buctllx.github.io/tags/MVVM/"}]},{"title":"WPF 窗口控件默认键盘焦点设置","slug":"WPF-窗口控件默认键盘焦点设置","date":"2022-03-14T06:10:52.000Z","updated":"2022-03-14T07:15:21.083Z","comments":true,"path":"2022/03/14/WPF-窗口控件默认键盘焦点设置/","link":"","permalink":"https://buctllx.github.io/2022/03/14/WPF-%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E9%BB%98%E8%AE%A4%E9%94%AE%E7%9B%98%E7%84%A6%E7%82%B9%E8%AE%BE%E7%BD%AE/","excerpt":"大家经常能够看到 WPF 窗口加载显示后，用户按 Tab 键，就会有一个控价获得焦点，如果这个控件是 Button，那么表现为：在 Button 文本周围有个虚线框；如果是 TextBox，那么表现为：在 TextBox 内部会有光标在闪烁。那么如何在 View 加载后设置默认显示这个效果，本文将会说明。","text":"大家经常能够看到 WPF 窗口加载显示后，用户按 Tab 键，就会有一个控价获得焦点，如果这个控件是 Button，那么表现为：在 Button 文本周围有个虚线框；如果是 TextBox，那么表现为：在 TextBox 内部会有光标在闪烁。那么如何在 View 加载后设置默认显示这个效果，本文将会说明。 一、关于 焦点 的 基本知识焦点概述 - WPF .NET Framework | Microsoft Docs 为控件中的焦点设置样式以及 FocusVisualStyle - WPF .NET Framework | Microsoft Docs 两种焦点： 键盘焦点 逻辑焦点 这里有一段话明确说明了虚线框是键盘焦点的由来 Focus visual styles act only when the focus action was initiated by the keyboard. Any mouse action or programmatic focus change disables the mode for focus visual styles. 意思是：虚线框这种焦点效果，只能通过按 Tab 键进行触发 二、实现方案明白了焦点效果产生的缘由，我们就可以思考如何实现 这里主要介绍如下实现方式； 2.1 模拟按键实现既然只能通过按 Tab 键触发产生想要的效果，最直接的方法就是： 在 View 加载后，通过编码实现模拟用户按键到达想要的键盘焦点效果； 具体实现方式编码，可以通过 PInvoke SendInput 实现， 也可以使用封装好的第三方包，NuGet Gallery | InputSimulator 1.0.4 缺点： 要提前计算好要按几次才能达到指定的控件； 2.2 重写键盘焦点样式在第一章节中了解了：想要的样式是通过那种 Style 控制产生的，那么我们就可以重新实现一种新的样式，默认显示我们想要的效果。 确定： 复杂，需要重写想过控件的样式 2.3 辅助方法实现通过反射的方法，调用 ShowFocusVisual Internal 方法实现。 笔者用的就是这种方法，因为我的需要没有复杂的样式要求，只需要显示默认的键盘焦点样式即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public sealed class KeyboardHelper&#123; private static KeyboardHelper _Instance; private readonly PropertyInfo _AlwaysShowFocusVisual; private readonly MethodInfo _ShowFocusVisual; // Explicit static constructor to tell C# compiler // not to mark type as beforefieldinit static KeyboardHelper() &#123; &#125; private KeyboardHelper() &#123; var type = typeof(KeyboardNavigation); _AlwaysShowFocusVisual = type.GetProperty(&quot;AlwaysShowFocusVisual&quot;, BindingFlags.NonPublic | BindingFlags.Static); _ShowFocusVisual = type.GetMethod(&quot;ShowFocusVisual&quot;, BindingFlags.NonPublic | BindingFlags.Static); &#125; internal static KeyboardHelper Instance =&gt; _Instance ?? (_Instance = new KeyboardHelper()); internal void ShowFocusVisualInternal() &#123; _ShowFocusVisual.Invoke(null, null); &#125; internal bool AlwaysShowFocusVisualInternal &#123; get &#123; return (bool)_AlwaysShowFocusVisual.GetValue(null, null); &#125; set &#123; _AlwaysShowFocusVisual.SetValue(null, value, null); &#125; &#125; public static void Focus(UIElement element) &#123; element?.Dispatcher.BeginInvoke(DispatcherPriority.Background, new Action(() =&gt; &#123; var keybHack = KeyboardHelper.Instance; var oldValue = keybHack.AlwaysShowFocusVisualInternal; keybHack.AlwaysShowFocusVisualInternal = true; try &#123; Keyboard.Focus(element); keybHack.ShowFocusVisualInternal(); &#125; finally &#123; keybHack.AlwaysShowFocusVisualInternal = oldValue; &#125; &#125;)); &#125;&#125; 使用方法: 在构造方法中的 InitializeComponent 方法 或者 Loaded 后添加下方代码即可 1KeyboardHelper.Focus(this.OkBtn); // Button Name 缺点： 需要使用控件 Name； 三、总结这第二章节中介绍了三种方法，大家可以根据自己的需要，选择合适的方法 笔者采用的是 2.3 ，目前没有发现什么问题； 参考链接： WPF Button to have Keyboard focus (dotted border around) during the startup or activation of window - Stack Overflow wpf - How to make CheckBox focus border appear when calling CheckBox.Focus()? - Stack Overflow","categories":[{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/categories/WPF/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/tags/WPF/"}]},{"title":"Visual Studio *.sln file 编辑 bug 记录","slug":"Visual-Studio-sln-file-编辑-bug-记录","date":"2022-03-03T05:47:03.000Z","updated":"2022-03-03T06:39:52.649Z","comments":true,"path":"2022/03/03/Visual-Studio-sln-file-编辑-bug-记录/","link":"","permalink":"https://buctllx.github.io/2022/03/03/Visual-Studio-sln-file-%E7%BC%96%E8%BE%91-bug-%E8%AE%B0%E5%BD%95/","excerpt":"sln 是 Visual Studio 20xx 自动创建的解决方案文件，里面存放了有关解决方案的设置信息，以及有关解决方案下项目文件的组织、结构、配置信息； 一般情况下，我们都是通过 Visual Studio 的可视化操作 对 sln 文件间接进行编辑修改的，但是有时候为了提高效果，需要手动进行编辑操作； 这里主要记录手动编辑 sln 文件遇到的问题：","text":"sln 是 Visual Studio 20xx 自动创建的解决方案文件，里面存放了有关解决方案的设置信息，以及有关解决方案下项目文件的组织、结构、配置信息； 一般情况下，我们都是通过 Visual Studio 的可视化操作 对 sln 文件间接进行编辑修改的，但是有时候为了提高效果，需要手动进行编辑操作； 这里主要记录手动编辑 sln 文件遇到的问题： 0. 有关 sln 文件的介绍这里假设读者对 sln 文件有一定了解，因此不在详细说明，主要用来说明遇到的问题 有关 sln 文件可以参考官方文档：解决方案 (。Sln) 文件 - Visual Studio (Windows) | Microsoft Docs 理解 Visual Studio 解决方案文件格式（.sln） - walterlv 1. sln 修改后不起效的 bug软件环境：visual studio 2022，sublime 3 1.1 问题描述使用 sublime 打开 sln 文件，然后编辑 GlobalSection(SolutionConfigurationPlatforms) = preSolution 信息，如下图所示： 红框里面是新增的内容； 修改后保存，然后再 visual studio 中重新载入，发现：新增的解决方案配置项，并没有出现，如下图所示： 注：一开始编辑，全部没有出现，这里为了说明问题，故意显示 出 Release R21 Store，便于后面分析问题 1.2 问题分析根据 1.1 中的现象发现，已经显示的配置项是 Release R21 Store，对应 sln 文件中的是 31 行，没有显示的是 32~40 行，这其中有什么区别不难发现。 唯一的区别是：31 行使用的 缩进是 tab 键，32~40 行使用的是空格 space； 注释：截图中的 —— 代表 Tab 键，…… 代表 Space 空格键 难道竟然是缩进符号的问题？？？ 通过验证发现：果然是缩进符号导致的 1.3 问题总结产生问题的原因： 笔者再根据 githu 上一篇技术文档的介绍，进行 sln 文件的编辑修改，文档中建议使用编辑器打开手动修改，而且附加上了修改的内容，于是我便很轻易的点击 copy 按钮，进行复制、粘贴，发现没有任何效果。 浪费了半天的事件才发现是 缩进符号导致的， 而且还是在 Sublime 中选中状态下才能发现的 复制粘贴代码害死人，一定要注意。","categories":[{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/categories/VisualStudio/"}],"tags":[{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/tags/VisualStudio/"}]},{"title":"Visual Studio 代码格式化工具","slug":"Visual-Studio-代码格式化工具","date":"2022-03-01T07:43:28.000Z","updated":"2022-03-16T10:05:41.910Z","comments":true,"path":"2022/03/01/Visual-Studio-代码格式化工具/","link":"","permalink":"https://buctllx.github.io/2022/03/01/Visual-Studio-%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7/","excerpt":"Visual Studio 设置 - &gt; 选项 里面自身包含有部分代码格式化的功能，但是比较弱，面对复杂的项目代码，尤其是团队开发的时候，依然存在一些问题，不能够很好的规范，格式化项目代码；比如说 XAML 文件等。 本篇文章，结合 Visual Studio 的基础设置，同时配合 Visual Studio 扩展相关的代码格式化工具进行项目级别代码格式化规范的统一说明。","text":"Visual Studio 设置 - &gt; 选项 里面自身包含有部分代码格式化的功能，但是比较弱，面对复杂的项目代码，尤其是团队开发的时候，依然存在一些问题，不能够很好的规范，格式化项目代码；比如说 XAML 文件等。 本篇文章，结合 Visual Studio 的基础设置，同时配合 Visual Studio 扩展相关的代码格式化工具进行项目级别代码格式化规范的统一说明。 Visual Studio 代码格式化基础设置vs 自带的文件格式化设置功能位于：工具 -&gt; 选项 -&gt; 文本编辑器 在这里，既可以按照编程语言设置，也可以在“所有语言”中进行统一设置； 这里的设置都是一些基本的设置，比如说：行号，自动补全，缩进等； 以C#为例，在写代码的过程中一般只有在 补全 {} 的时候才会进行自动格式化，如果实在 {} 内部写代码，比如说缩进不对，没有加空格等，那么在保存的时候就不会自动格式化（除非使用了手动/快捷键格式化或者高级插件） 还有，在进行 XAML 开发的时候，由于其标签语言的特性，属性有时候会比较多，尤其实在团队开发的过程中，每个人都有自己的习惯，有些人喜欢一行写下去不带换行，有些喜欢加换行（换行的时候属性的数量也不同，极端的一个属性就换行，或者三五个属性后再换行），而且相同标签的空间在一起，属性的顺序也可能不一样，这就给代码的可读性增加了困难； 如何解决这些问题，下面将会结合高级工具进行说明； 1. Format Document On Save 扩展插件主要用户解决，再保存代码的时候进行自动格式化； 保存操作支持 ctrl+s vs ide 中保存按钮 1.1 安装设置插件链接：Format document on Save - Visual Studio Marketplace Elders/VSE-FormatDocumentOnSave: Visual Studio - Format Document on Save (github.com) 安装后，可以在 工具 -&gt; 选项 -&gt; Format Document On Save 中进行格式化的一些设置，操作； 设置项比较简单，也有注释，这里就不在一一说明了； 1.2 项目级使用上面介绍的使用方法，可以满足一般个人的使用，但是在团队开发的过程中，每个人的设置可能不一样，如何解决这个问题能，这里就要使用到项目级的文件格式化配置 EditConfig。 项目级的文件格式化配置 EditConfig，不是针对某个人的；具有以下特点： 一个项目（sln）一个配置文件； 项目配置的优先级高于 工具 -&gt; 选项 -&gt; Format Document On Save 插件中的配置； 这样，有了EditorConfig 即便团队中的人员插件设置不一样，也能使用相同的格式化配置； 有关 EditorConfig 的详细信息可以查看链接，这里不详细说明了。 有了这个插件，可以很好的解决 99% 的代码格式问题，唯一例外的就是 xaml 文件不能格式化，这个会在下面单独说明。 2. XAML Styler 扩展插件在 .Net 开发中，有一种特殊的代码文件：XAML，是前面讲的代码格式化插件所不能格式的； 而 XAML Styler 就是专门针对 xaml 文件进行格式化，这一点从名字上就能看出来。 参考链接：使用 XAML 格式化工具：XAML Styler - dino.c - 博客园 (cnblogs.com) 2.1 XAML 的问题XAML 格式化主要的难题是下面几个： 如果所有属性都写在同一行，它太宽了很难看到后面的属性 如果每个属性单独一行，它又太长了很难看清楚它的结构 属性之间没有排序，重要属性的属性找起来很困难 团队没有统一的标准，不小心格式化一下代码的话全部都会变，CodeReview 烦死人 如果不想得过且过忍受上述这些问题的话，可以试试用 XAML Styler 这个工具，它正好解决了这些问题。 2.2 安装使用XAML Styler 是一个 VisualStudio插件（也可用于其它 IDE），这是它在 Visual Studio Marketplace 和 Github 上的地址： XAML Styler - Visual Studio Marketplace Xavalon/XamlStyler: Visual Studio extension to help format your XAML source code (github.com) Home · Xavalon/XamlStyler Wiki (github.com) 在 VisualStudio 的管理扩展窗口中，输入 XamlStyle 搜索，点击“下载”然后关闭 VisualStudio 即可完成安装。 具体安装步骤不在这里说明了。 安装完成后重启 Visual Studio，可以在“选项”窗口中看到它的配置： 之后，每次在 XAML 编辑器中执行保存都会自动进行格式化操作。你也可以在 XAML 编辑器的右键菜单选择 Format XAML 或使用快捷键进行格式化。 2.3 关键格式化设置项说明XAML 的格式主要有两种方式：所有属性放一行和每个属性单独一行。 如果选择所有属性放一行的时候，XAML 结构清晰，结构严谨，段落分明，而且文件也很短。 可是万一很多属性问题就出来了，一行 XAML 会变得很长。而且看看下面两个 ContentPresenter，同样都有 Margin 属性、HorizontalAlignment 属性，VerticalAlignment 属性，RecognizesAccessKey 属性，SnapsToDevicePixels 顺序ing，但你能看到第二个 ContentPresenter 后面偷偷塞了个 Margin 吗： 12Copy&lt;ContentPresenter Margin=&quot;&#123;TemplateBinding Padding&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot; SnapsToDevicePixels=&quot;&#123;TemplateBinding SnapsToDevicePixels&#125;&quot;/&gt;&lt;ContentPresenter Margin=&quot;&#123;TemplateBinding Padding&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot; SnapsToDevicePixels=&quot;&#123;TemplateBinding SnapsToDevicePixels&#125;&quot; Margin=&quot;40&quot;/&gt; 如果在 VisualStudio 中“文本编辑器-&gt;XAML-&gt;格式化-&gt;间距-&gt;特性间距”这个选项中选择了“将各个属性分别放置”： 格式化文档后上面的 XAML 就会变成这样： 1234567891011&lt;ContentPresenter Margin=&quot;&#123;TemplateBinding Padding&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot; SnapsToDevicePixels=&quot;&#123;TemplateBinding SnapsToDevicePixels&#125;&quot; /&gt;&lt;ContentPresenter Margin=&quot;&#123;TemplateBinding Padding&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot; SnapsToDevicePixels=&quot;&#123;TemplateBinding SnapsToDevicePixels&#125;&quot; Margin=&quot;40&quot; /&gt; 每个属性单独一行不仅不会看漏属性，而且编辑器本身也不会有横向和纵向两种方向的移动，只有从上到下的移动，这就舒服多了。 可是大部分情况下每个属性分行放置会破坏原本清晰的 XAML 层次结构，例如下面这种本来好好的 XAML: 123456&lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Normal&quot; /&gt;&lt;Setter Property=&quot;UseSystemFocusVisuals&quot; Value=&quot;True&quot; /&gt;&lt;Setter Property=&quot;FocusVisualMargin&quot; Value=&quot;-3&quot; /&gt;&lt;Setter Property=&quot;Height&quot; Value=&quot;50&quot; /&gt;&lt;Setter Property=&quot;Width&quot; Value=&quot;50&quot; /&gt;&lt;Setter Property=&quot;Maximum&quot; Value=&quot;1&quot; /&gt; 变成这样： 123456789101112&lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Normal&quot; /&gt;&lt;Setter Property=&quot;UseSystemFocusVisuals&quot; Value=&quot;True&quot; /&gt;&lt;Setter Property=&quot;FocusVisualMargin&quot; Value=&quot;-3&quot; /&gt;&lt;Setter Property=&quot;Height&quot; Value=&quot;50&quot; /&gt;&lt;Setter Property=&quot;Width&quot; Value=&quot;50&quot; /&gt;&lt;Setter Property=&quot;Maximum&quot; Value=&quot;1&quot; /&gt; 这种风格优雅得像诗歌我偶尔称为豆瓣风一行变两行两行变四行本来一页看得完的代码变成两页才看得完也是够麻烦的。 XAML Styler 很好地解决了这个问题，它通过 “Attribute tolerance” 属性控制每一行的容许的最多的属性数量，如果一个元素的属性数量少于设定值，那就放在一行，如果超过就所有属性单独一行。通常我将这个属性设置为 2，再配合 “Keep first attribute on same line = true” 的设置，可以做到下面这种格式化效果： 1234567891011121314151617&lt;SolidColorBrush x:Key=&quot;NormalTextColor&quot; Color=&quot;#2E2F33&quot; /&gt;&lt;SolidColorBrush x:Key=&quot;PrimaryColor&quot; Color=&quot;#FFED5B8C&quot; /&gt;&lt;SolidColorBrush x:Key=&quot;LineColor&quot; Color=&quot;#E1E1E1&quot; /&gt;&lt;SolidColorBrush x:Key=&quot;TransparentBackground&quot; Color=&quot;Transparent&quot; /&gt;&lt;ControlTemplate x:Key=&quot;CompletedTemplate&quot; TargetType=&quot;ContentControl&quot;&gt; &lt;Grid x:Name=&quot;CompletedElement&quot; Margin=&quot;-2&quot;&gt; &lt;control:DropShadowPanel HorizontalContentAlignment=&quot;Stretch&quot; VerticalContentAlignment=&quot;Stretch&quot; BlurRadius=&quot;8&quot; OffsetX=&quot;0&quot; OffsetY=&quot;0&quot; Color=&quot;#FFED5B8C&quot;&gt; &lt;Ellipse x:Name=&quot;CompletedRectangle&quot; Fill=&quot;&#123;StaticResource PrimaryColor&#125;&quot; /&gt; &lt;/control:DropShadowPanel&gt; &lt;/Grid&gt;&lt;/ControlTemplate&gt; 这样就可以兼顾两种格式化的优点。 2.4 排序如果元素有多个属性，要找到它的主要属性（通常是 Name 和 Grid.Row）需要颇费一番功夫。XAML Styler 根据一个可设定的规则自动将元素的各个属性排序，这个规则如下： 12345678910111213&quot;AttributeOrderingRuleGroups&quot;: [ &quot;x:Class&quot;, &quot;xmlns, xmlns:x&quot;, &quot;xmlns:*&quot;, &quot;x:Key, Key, x:Name, Name, x:Uid, Uid, Title&quot;, &quot;Grid.Row, Grid.RowSpan, Grid.Column, Grid.ColumnSpan, Canvas.Left, Canvas.Top, Canvas.Right, Canvas.Bottom&quot;, &quot;Width, Height, MinWidth, MinHeight, MaxWidth, MaxHeight&quot;, &quot;Margin, Padding, HorizontalAlignment, VerticalAlignment, HorizontalContentAlignment, VerticalContentAlignment, Panel.ZIndex&quot;, &quot;*:*, *&quot;, &quot;PageSource, PageIndex, Offset, Color, TargetName, Property, Value, StartPoint, EndPoint&quot;, &quot;mc:Ignorable, d:IsDataSource, d:LayoutOverrides, d:IsStaticText&quot;, &quot;Storyboard.*, From, To, Duration&quot;], 排序结果大致如下： 123456789&lt;Button x:Name=&quot;Show&quot; Grid.Row=&quot;1&quot; Padding=&quot;40,20&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Background=&quot;#00aef1&quot; Content=&quot;Show&quot; Foreground=&quot;White&quot; Style=&quot;&#123;StaticResource BubbleButtonStyle&#125;&quot; /&gt; 2.5 项目级使用最后，就算自己做好了格式化，团队中的其它成员使用了不同的格式化标准也会引起很多问题。针对这个问题 Xaml Styler 也提供了解决方案。 在项目的根目录创建一个名为“Settings.XamlStyler”的文件，内容参考这个网址：https://github.com/Xavalon/XamlStyler/wiki/External-Configurations 中的 Default Configuration。有了这个配置文件，XAML Styler 就会根据它而不是全局配置进行格式化，作为项目的统一格式化标准。 2.6 ctrl+s 保存时的冲突问题解决设置完这两个插件后，在实际使用的过程中可能会发现：在使用 ctrl + s 保存的时候会达不到效果 现象分析在 xaml 中按 ctrl + s 保存的时候，仔细查看画面，会发现 xaml 文件被保存了两次，而且第一一闪而过的结果好像还是正确的，最初呈现的第二次保存解决却不对了， 原因分析根据现象可以分析出来，不止一个插件触发了xaml 的保存操作，那个捣乱者是谁，很容易想到是 Format Document On Save 解决方法从现象中我们看到，保存了两次导致解结果不对； 那么就有两个解决方案： 让 xaml styler 最后保存， 不然 Format Document On Save 保存 xaml； 方案 1 我们无法控制保存顺序，暂时无解； 方案 2 如果我们在设置中可以设置 不存在 xaml 文件就可以了，或许可行 打开 Format Document On Save 设置信息，我们仔细查看，有一个叫 Denied Extensions 的设置项，我们可以通过它设置不格式化 xaml 文件，设置后试了一些，依然达不到效果，查看那里除了问题，仔细看 Denied Extensions 设置项的说明发现： Denied Extensions 设置项，只有在 Allowed Extensions 设置项为空的情况下才能生效，于是赶紧删除试一下，果然成功了。","categories":[{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"VisualStudio","slug":"工具/VisualStudio","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/VisualStudio/"}],"tags":[{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/tags/VisualStudio/"},{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"使用 Windows Server 建立 Web Site 并关联 FTP Server","slug":"使用-Windows-Server-建立-Web-Site-并关联-FTP-Server","date":"2022-01-25T03:20:44.000Z","updated":"2022-01-25T03:41:16.430Z","comments":true,"path":"2022/01/25/使用-Windows-Server-建立-Web-Site-并关联-FTP-Server/","link":"","permalink":"https://buctllx.github.io/2022/01/25/%E4%BD%BF%E7%94%A8-Windows-Server-%E5%BB%BA%E7%AB%8B-Web-Site-%E5%B9%B6%E5%85%B3%E8%81%94-FTP-Server/","excerpt":"本文主要说明，如何在 windows server 中建立 web site，并关联 ftp 服务；最终达到的效果是，可以通过 https 链接访问 ftp 服务的所有内容； 系统环境：window server 2019","text":"本文主要说明，如何在 windows server 中建立 web site，并关联 ftp 服务；最终达到的效果是，可以通过 https 链接访问 ftp 服务的所有内容； 系统环境：window server 2019 1、开启系统必备的服务组件2、新建 SSL 证书3、建立 web site 并关联 FTP Server4、其他设置4.1 ftp 服务直通网络位置4.2 web site 开启浏览文件目录结构的功能4.3 web site 绑定 https 访问参考资料：","categories":[{"name":"windwos","slug":"windwos","permalink":"https://buctllx.github.io/categories/windwos/"},{"name":"web site","slug":"windwos/web-site","permalink":"https://buctllx.github.io/categories/windwos/web-site/"},{"name":"ftp server","slug":"windwos/ftp-server","permalink":"https://buctllx.github.io/categories/windwos/ftp-server/"}],"tags":[{"name":"windwos","slug":"windwos","permalink":"https://buctllx.github.io/tags/windwos/"},{"name":"web site","slug":"web-site","permalink":"https://buctllx.github.io/tags/web-site/"},{"name":"ftp","slug":"ftp","permalink":"https://buctllx.github.io/tags/ftp/"}]},{"title":"Revit 构件参数体系说明","slug":"Revit-构件参数体系说明","date":"2022-01-20T10:45:52.000Z","updated":"2022-01-25T06:24:30.143Z","comments":true,"path":"2022/01/20/Revit-构件参数体系说明/","link":"","permalink":"https://buctllx.github.io/2022/01/20/Revit-%E6%9E%84%E4%BB%B6%E5%8F%82%E6%95%B0%E4%BD%93%E7%B3%BB%E8%AF%B4%E6%98%8E/","excerpt":"1、Revit 构件分类说明从不同的维度 Revit 构件（图元）有不同的分类； 对用用户来说：最为熟悉的就是“项目浏览器”中“族”节点的三级分类： 这里主要介绍以下几种分类维度；","text":"1、Revit 构件分类说明从不同的维度 Revit 构件（图元）有不同的分类； 对用用户来说：最为熟悉的就是“项目浏览器”中“族”节点的三级分类： 这里主要介绍以下几种分类维度； 1.1 常见的三级分类三级分类，一般用于用户分类管理各种构件，方便用户快速检索使用； 每一级分类都有自己的参数，只不过用户经常关注的时：类型参数、实例参数而已 1.1.1 一级分类 - 类别英文名字也是 API 的名字：Category Category 是 Revit 软件内置的基础数据，不能被用户和开发者“增删改”，用户只有使用权限； 对于某个确定的 Revit 版本 Category 数量是固定的，只有在 Revit 版本的变化的时候 Category 才可能变化（一般是新增） Category 内部也是有联系的，具体变现为子类别 SubCategory，这一点一般用户是看不到的； 下面是 Revit API 暴露出来的所有的 Category，可以通过切花版本查看； Revit API BuiltInCategory Enumeration (revitapidocs.com) 经过个人统计 Category 发现： 总数：2000+ 一般项目中用到的：900左右 实际建模常用的：不超过100 1.1.2 二级分类 - 族Family 在类别之下的二级分类； 所有添加到 Revit 项目中的图元都是使用族创建的。 族 在 Revit 中也分为多种类型，具有一定的可扩展性，但并不是所有的族都能扩展，后面 1.2 章节会说明 这里需要特殊说明的是：族并不是单一的构件，它是可以嵌套，复合的，从而生成更加复杂高级的族； 更多详细说明参见 Autodesk Revit 官方文档：帮助: Revit 族 (autodesk.com) 1.1.3 三级分类 - 类型xxx_Type，FamilySymbol 一个族，可以有多个类型；一般叫：族类型； 类型是用户建模的时候必须指定的信息， 指定了类型，就只定了族和类别； 类型下面就是“图元”了，也可以叫构件；所谓图元，就是在模型视图中实实在在看到的对象，但被选中时，会高亮显示，并且会在“属性”窗口中显示图元的参数信息； “属性”窗口中显示的并不是图元所有的属性信息 1.2 按族类型分类1.2.1 系统族特点： Revit 软件内置的，所有的 rvt 文件都是一样的； 有限的； 用户不能自己添加 / 删除（Revit 升级的时候或许会新增）； 常见的系统族：墙，楼板、各种管线、屋顶、…… 1.2.2 载入族特点： 以 rfa 文件的形式存在； 可以载入不同的 rvt 文件中复用； 用户可以自己新增或者删除； 常见的系统族：梁、柱、管件、管道附件、末端、家具、设备…… 1.2.3 内建族特点： 只存在于某一个 rvt 文件内，不能被复用； 只包含一个类型且类型名称和族名称一样 用户可以自己新增或者删除； 可以随意指定，创建的时候只需要指定 类别，输入一个族名称，Revit 就会自动创建一个内建族 1.3 按 Category 类型分类这种分类是按照 Category 的属性信息 Category Type 进行划分的 一般较少关注 1.3.1 模型类构件(模型族)可以在三维视图中进行查看的； 例如：墙、梁、板、柱、…… 1.3.2 详图类构件(注释族)在平面视图中进行辅助查看，不能在三维视图中看到； 例如：标记、尺寸标注、…… 1.3.3 分析类构件(分析族)Revit 中有一个单独的分析模块，分析族用来展示分析结果的 例如：分析墙、分析柱、…… 1.3.4 内部类构件(内部族)Revit 内部使用的； 用户一般不直接使用，通常起到辅助类的构件； 例如：结构连接处理程序、部件、…… 2、Revit 参数分类说明Revit 参数也有多个分类的维度， 这里主要介绍以下几种分类维度 2.1 按作用的层级作用层级包含了三级分类，在 1.1 中说明过，每一级都有自己的描述参数； 除了三级分类，这里补充说明了“项目参数”和“实例参数” 2.1.1 项目级参数这里项目有别于建筑设计的项目，意思是 rvt 文件，Revit 默认一个 rvt 文件就是一个项目文件，rvt 文件级别的参数就是项目参数，不同的 rvt 文件可以定义不同数量的参数； 所有的项目参数集合在一起，叫做“项目信息”，也是一个 Category 类别 符合 Revit 添加参数的统一流程 除此之外还有一种特殊的项目参数叫“全局参数”，是 2016 R2 以后新增的，具体参见 2.2 2.1.2 族级参数被用来描述族 Family 的相关信息； 一边较少使用，且不能增删改 2.1.3 类型级参数一个族一般有多个类型，一个类型之所以区别于另一个类型，就是因为类型参数的参数值不一样（如果一样，那么就可以认为是相同的类型，就没必要新建这个类型了） 为了描述族下面的多个类型，因此产生了类型参数； 2.1.4 实例级参数视图中看到的每一个图元，都有自己的属性信息，这些属性信息都是通过实例参数描述的； 具体变现为：Revit “属性”窗口中看到的参数（上面截图，左侧部分） 2.2 按参数的定义这种分类方式，只关心参数是如何定义的，不关心这个参数将会被用于描述哪个对象； 通过不同不同的定义方式，可以将参数分为以下几类； 2.2.1 内置参数BuiltinParameter 在 Revit 中通过枚举的方式暴露出来，用户不能做任何修改； BuiltInParameter Enumeration (revitapidocs.com) 2.2.2 共享参数用户通过共享参数文件定义； 一般情况下一个用户定义并使用一个共享参数文件，也可以做到多个用户使用同一个共享参数文件； 2.2.3 族参数在编辑 rfa 文件过程中定义的参数； 根据创建方式的不同，还可以划分为： 共享参数 一般族参数 这类参数比较特殊，该类型的参数只能在族文件范围内定义， 简单来说就是，只能在编辑 rfa 文件的时候进行定义；且有效的使用范围只能在 rfa 文件内部； 这中参数是造成 revit 参数被滥用的一个原因 族参数，在族内部作用的层级，还可以划分为： 类型参数 实例参数； 参考：2.1 中的类型参数和实例参数； 2.2.4 全局参数 全局参数是 Autodesk 在 Revit 2016 R2 版本（17 及其以后的版本都有）增加的内容，是继共享参数与项目参数之后新增加的一种参数。 全局参数特定于单个项目文件，但未像项目参数那样指定给类别。全局参数可以是简单值、来自表达式的值或使用其他全局参数从模型获取的值。 有点类似于族文件里的“一般族参数” 详细的使用方式和案例，参见官方文档：帮助: 全局参数 (autodesk.com) 3、Revit 参数管理体系Revit 中的参数主要有两类： 常规参数 材质类参数 3.1 常规参数的定义管理体系在 Revit 中所有的参数都必须先定义，然后才能被使用； 关于参数定义，Revit 有自己的一套管理体系； 下面截图是各种参数的定义截图 [共享参数定义][项目参数定义][项目参数使用共享参数定义][族参数定义] 从上面的截图可以看出来，用于参数管理的主要有以下几个信息： 规程 参数类型 参数分组 参数分组方式 类型 or 实例 是否报告参数 这些信息，主要用于描述一个参数，方便 Revit 对参数进行管理； “参数定义”并不关注这个参数将会被用于描述什么对象，或者单位是什么；参数的 描述对象，单位信息，则是通过一种关联关系进行使用 因为： 一个参数的定义可以被用于描述一个或者多个对象，在给对象添加参数的时候，去选择已经定义好的参数就行了；【添加项目参数的后最右侧会有关联对象的选择】 一个参数可能没有单位或者有多个单位；具体选择哪个单位，在显示或者使用的时候确定就可以了，如下图所示； 3.2 材质类参数管理体系材质类参数，因为涉及到渲染、显示，因此十分复杂；Autodesk 的很多建模软件使用的材质库都是独立的，并不共享； 因为材质相关的参数体系太过复杂，API暴露有是有限的，所以下面主要以介绍为主； 功能入口：管理 -&gt; 设置 -&gt; 材质 在这里用户可以自己创建、定义、编辑、修改与材质相关的各种信息； [土建材质 - 示例][机电材质 - 示例] 从上面的截图看，材质信息主要包含以下几类信息： 标识 图形 外观 物理（可选） 热度（可选） 每一类，都包含若干参数，并且通过分组进行管理 3.3 通用参数值的管理上面说完了参数定义，另外一个话题就是参数值； 3.3.1 通用参数(值)特点因为存在这样一部分参数，他们对于参数值的填写是有一些基本要求的； 比如说：颜色，只能在 0 ~ 255 之间； 还有一类：提供一些基本的参数值，让用户进行选择；同时可以暴露一些参数值定义的接口，让用户可以先定义参数值，然后再选择参数值进行使用。 这类参数值都有一些特点： 有限 可枚举 比较常见、通用 跟其他参数或者对象有关联关系 这类参数，主要集中在 管理 -&gt; 设置 面板中 3.3.2 例子（1）规程类参数：规程参数各处都有用，参数值是 Revit 规定的有限的几个，与其他参数有关联，比如说：参数分组，子规程等 （2）建筑/空间 类型参数 （3）机电 - 系统类型 参数 （4）显示类参数(值) 填充样式 线样式 线宽 线型图案 材质资源 这些跟材质或者显示类的参数都有关系，主要影响的就是渲染显示。","categories":[{"name":"Revit","slug":"Revit","permalink":"https://buctllx.github.io/categories/Revit/"}],"tags":[{"name":"Revit","slug":"Revit","permalink":"https://buctllx.github.io/tags/Revit/"}]},{"title":"Hexo 集成 PicGo Github 图床","slug":"Hexo-集成-PicGo-Github-图床","date":"2022-01-20T10:15:23.000Z","updated":"2022-01-20T10:40:20.604Z","comments":true,"path":"2022/01/20/Hexo-集成-PicGo-Github-图床/","link":"","permalink":"https://buctllx.github.io/2022/01/20/Hexo-%E9%9B%86%E6%88%90-PicGo-Github-%E5%9B%BE%E5%BA%8A/","excerpt":"0、背景说明博主原来使用七牛云图床，好处：10G 免费空间；坏处：域名有效期一个月；超出一个月就没法使用了； 因而转向了其他图床，发现 PicGo 中支持的图床有 Github，觉得是一个不错的选择 使用 Github 图床的好处： 没有域名限制； 仓库虽然空间有限（1G），但是满了可以再新建一个仓库，因此相当于无限 有人说慢，但是可以设置加速 稳定，不用担心挂了或者失效","text":"0、背景说明博主原来使用七牛云图床，好处：10G 免费空间；坏处：域名有效期一个月；超出一个月就没法使用了； 因而转向了其他图床，发现 PicGo 中支持的图床有 Github，觉得是一个不错的选择 使用 Github 图床的好处： 没有域名限制； 仓库虽然空间有限（1G），但是满了可以再新建一个仓库，因此相当于无限 有人说慢，但是可以设置加速 稳定，不用担心挂了或者失效 参考： MarkDown、Hexo博客、Coding托管、GitHub做图床、CDN加速 - 段十三 - 博客园 (cnblogs.com) 1、新建一个仓库 名字自定义，例如：pic_bed 选择 Public 勾选初始化复选框： Initialize this repository with a README 点击 Create repository 创建成功 New personal access token (github.com) 配置图床的时候要用： Note下面的文本框内容自定义 下面很多复选框，只需要勾选 repo 也就是第一个复选框 最下面点击Generate token即可生成 下面要用，如果忘记了可以在重新生成 2、安装配置 PicGo下载安装，这里不再说明， 安装后启动 PicGo，找到 Github 图床，如下图所示： 填写第一步中创建的 仓库名，分支名，以及 Token 然后“确定”，并设置为默认图床即可 3、配置 JsDeliv，给图片镶上加速器 比如在GitHub的图片路径是：https://github.com/user/pic_bed/img/test_image.png 拼接链接方法1：https://cdn.jsdelivr.net/gh/user/pic_bed@latest/img/test_image.png 拼接链接方法2：https://cdn.jsdelivr.net/gh/user/pic_bed/img/test_image.png 将方法1和方法2拼接起来的链接前缀输入到上图第5步的自定义域名中即可 拼接链接方法1：https://cdn.jsdelivr.net/gh/user/pic_bed@latest/ 拼接链接方法2：https://cdn.jsdelivr.net/gh/user/pic_bed/ 4、再 Typora 中选择 PicGo app 作为图片上传服务Typora 设置关联七牛云图床 | ConorLuo 博客 (buctllx.github.io)","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"},{"name":"PicGo","slug":"Hexo/PicGo","permalink":"https://buctllx.github.io/categories/Hexo/PicGo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"},{"name":"PicGo","slug":"PicGo","permalink":"https://buctllx.github.io/tags/PicGo/"}]},{"title":"Windows Terminal 集成 Oh My Posh","slug":"Windows-Terminal-集成-Oh-My-Posh","date":"2021-12-29T03:52:56.000Z","updated":"2022-03-22T06:42:18.875Z","comments":true,"path":"2021/12/29/Windows-Terminal-集成-Oh-My-Posh/","link":"","permalink":"https://buctllx.github.io/2021/12/29/Windows-Terminal-%E9%9B%86%E6%88%90-Oh-My-Posh/","excerpt":"1. 准备安装环境Windows Termianl, PowerShell 都可以从 Microsoft Store 中下载 Windows Terminal (Windows 自带) PowerShell 具体安装这里不做详细说明","text":"1. 准备安装环境Windows Termianl, PowerShell 都可以从 Microsoft Store 中下载 Windows Terminal (Windows 自带) PowerShell 具体安装这里不做详细说明 2. 安装 Oh My Posh这里推荐去 Oh My Posh 官方网站查看最新的安装方法； 网上的大部分教程，存在时效性问题，因为 Oh My Posh 是不断更新的，不同时间不同版本的安装方法可能不一样 因此搜索到的二手安装教程不一定使用目前安装的你 Home | Oh My Posh Introduction | Oh My Posh 2.1 参考文档：将美化进行到底，使用 Oh My Posh 把 PowerShell 做成 oh-my-zsh 的样子 - walterlv Making Windows Terminal look awesome with oh-my-posh and new fonts. (zimmergren.net) 2.2 可能使用到的命令1234567891011121314# 查看已经安装的模块Get-InstalledModule# 当前用户安装一个模块 （-Verbose 参数显示细节）全局使用 AllUsers Install-Module oh-my-posh -Scope CurrentUser -Verbose# 导入加载一个模块 （-Verbose 参数显示细节）Import-Module oh-my-posh -Verbose# 卸载一个模块Uninstall-Module -Name oh-my-posh# 查看 PowerShell 安装源 GalleryGet-PSRepository 参考链接： Install-Module (PowerShellGet) - PowerShell | Microsoft Docs Get-PSRepository (PowerShellGet) - PowerShell | Microsoft Docs PowerShell Gallery | Home 2.3 字体选择官方推荐 Nerd Fonts - Iconic font aggregator, glyphs/icons collection, &amp; fonts patcher 下载自定后安装方法： 解压、进入字体目录、全选、右键、安装 即可 3. Posh-Git 安装dahlbyk/posh-git: A PowerShell environment for Git (github.com) Posh-Git 提供了强大的 tab 补全功能， 并针对提示符进行了增强；可以在 Terminal 中使用 官方文档安装方法： Git - Git 在 PowerShell 中使用 Git (git-scm.com) 1Install-Module posh-git -Scope CurrentUser -Force 这里不做详细说明","categories":[{"name":"Termianl","slug":"Termianl","permalink":"https://buctllx.github.io/categories/Termianl/"},{"name":"PowerShell","slug":"Termianl/PowerShell","permalink":"https://buctllx.github.io/categories/Termianl/PowerShell/"}],"tags":[{"name":"Termianl,PowerShell,Oh-My-Posh","slug":"Termianl-PowerShell-Oh-My-Posh","permalink":"https://buctllx.github.io/tags/Termianl-PowerShell-Oh-My-Posh/"}]},{"title":"Hexo Next Theme 使用问题总结","slug":"Hexo-Next-Theme-使用问题总结","date":"2021-12-21T09:36:03.000Z","updated":"2021-12-22T03:35:02.306Z","comments":true,"path":"2021/12/21/Hexo-Next-Theme-使用问题总结/","link":"","permalink":"https://buctllx.github.io/2021/12/21/Hexo-Next-Theme-%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"两个路径说明： site root directory：博客站点根目录 theme root directory：博客主题根目录 后面说明问题会一直沿用这中叫法； 1. 部署后“搜索”功能无法使用原因 使用了最新的 master 版本，master 分支是主题作者的开发分支，每周都会更新，当时不稳定","text":"两个路径说明： site root directory：博客站点根目录 theme root directory：博客主题根目录 后面说明问题会一直沿用这中叫法； 1. 部署后“搜索”功能无法使用原因 使用了最新的 master 版本，master 分支是主题作者的开发分支，每周都会更新，当时不稳定 解决方法 拉去稳定版本的分支，主要看最新的 Tag 参考 Issues 链接：https://github.com/hexojs/hexo/issues/4654 2. 替换图片资源路径主题涉及到的，各种图片资源都是可以替换的， 替换路径：theme root directory\\theme\\next\\source\\images 为了显示效果，注意替换的图片最好是对应像素的，而且不易过大，图片类型可以自己修改 可替换图片说明： 图片名称 含义 avatar 博主图像 favicon-16x16-next 网站图标 16x16 像素 favicon-32x32-next 网站图标 32x32 像素 logo log apple-touch-icon-next 触摸图标 alipay 支付宝收款二维码 weixin 微信收款二维码 3. 增加自定义的“标签”，“分类”页面默认安装好的 next 主题，是没有“标签”，“分类”页面的； 需要使用者自己新增页面： 新增方法：以“标签”也为例说明： 使用 hexo 命令新建 tags.md页面 12# cd site root directoryhexo new page tags 打开 tags.md 并修改页面类型 type 信息 123title: Tagsdate: 2021-12-22 12:00:00type: tags 修改主题配置文件 12345# cd next/_config.ymlmenu: home: / || fa fa-home archives: /archives/ || fa fa-archive tags: /tags/ || fa fa-tags 4. 开启首页文章部分显示next 主题默认的是将你的文章全篇显示在自己的首页上，这就会导致一个问题，首页各个文章太长了不利于翻阅 想要让文章部分显示，并出现“阅读全文的按钮”，只需要在个人的文章 Markdown 源文件中添加一行代码就行 1&lt;!--more--&gt; 具体位置，自己确定，在自己想要显示的文章部分下面加上即可只在首页显示所需的文章部分。 参考文档： Custom Pages | NexT (theme-next.js.org) 创建分类页面 · iissnan/hexo-theme-next Wiki (github.com) Hexo + Theme Next – 写作 | Knner.Wang’s Blog","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"},{"name":"Hexo Theme","slug":"Hexo/Hexo-Theme","permalink":"https://buctllx.github.io/categories/Hexo/Hexo-Theme/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"},{"name":"Theme","slug":"Theme","permalink":"https://buctllx.github.io/tags/Theme/"}]},{"title":"ElasticSearch 操作异常总结","slug":"ElasticSearch-操作异常总结","date":"2021-12-15T09:41:01.000Z","updated":"2021-12-22T10:33:37.292Z","comments":true,"path":"2021/12/15/ElasticSearch-操作异常总结/","link":"","permalink":"https://buctllx.github.io/2021/12/15/ElasticSearch-%E6%93%8D%E4%BD%9C%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/","excerpt":"1. Index 写入数据 FORBIDDEN 问题1.1 问题描述在使用七牛云的 Logkit 往 ElasticSearch 发送数据的时候出现了以下异常信息； 123456789101112# SendError: bulk failed with last error&#123; &quot;_index&quot;:&quot;dev_cbim_tool_log&quot;, &quot;_type&quot;:&quot;cbim_tool_log&quot;, &quot;_id&quot;:&quot;UhoDvX0B7FSmwLI_OPym&quot;, &quot;status&quot;:403, &quot;error&quot;:&#123; &quot;type&quot;:&quot;cluster_block_exception&quot;, &quot;reason&quot;:&quot;blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];&quot; &#125;&#125;# failDatas size : 33 其核心异常提示是：[FORBIDDEN/12/index read-only / allow delete (api)]","text":"1. Index 写入数据 FORBIDDEN 问题1.1 问题描述在使用七牛云的 Logkit 往 ElasticSearch 发送数据的时候出现了以下异常信息； 123456789101112# SendError: bulk failed with last error&#123; &quot;_index&quot;:&quot;dev_cbim_tool_log&quot;, &quot;_type&quot;:&quot;cbim_tool_log&quot;, &quot;_id&quot;:&quot;UhoDvX0B7FSmwLI_OPym&quot;, &quot;status&quot;:403, &quot;error&quot;:&#123; &quot;type&quot;:&quot;cluster_block_exception&quot;, &quot;reason&quot;:&quot;blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];&quot; &#125;&#125;# failDatas size : 33 其核心异常提示是：[FORBIDDEN/12/index read-only / allow delete (api)] 1.2 原因分析从字面意思看，ES 禁止数据写入； 联想到最近服务器发生的一系列问题，一切都能解释的通了； 最近发现：ES 集群的一个节点挂了（主要是因为服务器的磁盘坏了）； 在这样的情况下，触发了 ES 的保护机制，因此出现了上面的情况； 1.3 解决方法1curl -XPUT -H &quot;Content-Type: application/json&quot; http://localhost:9200/_all/_settings -d &#x27;&#123;&quot;index.blocks.read_only_allow_delete&quot;: null&#125;&#x27; 参考链接：[如何修复 ElasticSearch FORBIDDEN/12/index read-only / allow delete （api）] – TechOverflow 2. ElasticSearch 启动参数问题通过 docker 启动 es 的时候，相关参数设置跟 es 的镜像版本有关； 这里主要说明常见的各种 es 设置问题 2.1 unknown setting [discovery.seed_hosts]产生背景使用2019年的老脚本启动 es 的 docker 实例； 注：笔者是 2021.12.15 pull 最新的 es 镜像启动实例的，启动实例使用的参数是 2019 年底时的； 原因2019 年底的 es 镜像和 2021 年的镜像文件参数设置不一致， 可以通过 dock inspect elasticsearch 查看 解决方法使用下面的配置替代 1discovery.zen.ping.unicast.hosts: [&quot;192.168.10.11:9300&quot;,&quot;192.168.10.12:9300&quot;,&quot;192.168.10.13:9300&quot;] 注意：启动脚本，最好跟 docker 镜像配套使用 类似的问题unknown setting [cluster.initial_master_nodes] 2.2 ES 缓存设置默认设置：ES_JAVA_OPTS=”-Xms256m -Xmx256m” 启动的时候可以加 -e 指定参数 1-e ES_JAVA_OPTS=&quot;-Xms1g -Xmx1g&quot; 设置过大可能导致本机缓存不够，启动时有如下错误提示： max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 解决方法：修改 centos 系统的缓存设置 1234567# 1. open and edit confvi /etc/sysctl.conf# 2. add at last vm.max_map_count=262144# 3. apply/sbin/sysctl -p 3. ElasticSearch 集群状态排查Elasticsearch 集群故障排查及修复指南_铭毅天下（公众号同名）-CSDN博客 4. ES 索引 primary shard is unassigned 解决方法12345678910111213POST /_cluster/reroute&#123; &quot;commands&quot; : [ &#123; &quot;allocate_stale_primary&quot; : &#123; &quot;index&quot; : &quot;.monitoring-kibana-6-2021.12.17&quot;, &quot;shard&quot; : 0, &quot;node&quot; : &quot;es-node-2&quot;, &quot;accept_data_loss&quot; : true &#125; &#125; ]&#125; ES 遇到 unassigned shard如何处理？_weixin_34050519的博客-CSDN博客 解决elasticsearch分片unassigned的3个方法_dlm_bk的博客-CSDN博客_es分片unassigned","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://buctllx.github.io/categories/ElasticSearch/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://buctllx.github.io/tags/ElasticSearch/"},{"name":"ES","slug":"ES","permalink":"https://buctllx.github.io/tags/ES/"}]},{"title":"Typora 设置关联七牛云图床","slug":"Typora-设置关联七牛云图床","date":"2021-12-06T06:46:25.000Z","updated":"2021-12-22T03:34:21.566Z","comments":true,"path":"2021/12/06/Typora-设置关联七牛云图床/","link":"","permalink":"https://buctllx.github.io/2021/12/06/Typora-%E8%AE%BE%E7%BD%AE%E5%85%B3%E8%81%94%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A/","excerpt":"1. 七牛云存储环境准备1.1 注册七牛云官网：七牛云 - 国内领先的企业级云服务商 (qiniu.com) 注册流程不在这里详细说明； 说一下注意事项： 注册后，需要实名认证 个人认证 即可","text":"1. 七牛云存储环境准备1.1 注册七牛云官网：七牛云 - 国内领先的企业级云服务商 (qiniu.com) 注册流程不在这里详细说明； 说一下注意事项： 注册后，需要实名认证 个人认证 即可 1.2 新建图床存储空间 登录后，通过“管理控制台”进入管理页面； 点击“对象存储 Kodo”； 点击“空间管理” -&gt; “新建空间” 进行图床空间创建； 如下图所示，设置完相关参数，即可创建一个图床存储空间； 注意事项： 访问权限选择“公开” 存储区域一般选择“距离自己比较近的”，并且不同区域有不同的代号，后面会用到 2. PicGo 安装PicGo 有两种类型； PicGo App（应用程序） PicGo-Core（命令行版本） 2.1 安装2.1.1 图形界面版本PicGo图形 选择对应系统的安装包安装即可 2.1.2 命令行版本PicGo-core 没有nodejs环境，使用typora一键安装即可 本机有nodjs环境，直接npm全局安装 123npm install picgo -g# oryarn global add picgo 插件安装 picgo-plugin-web-uploader 这是一款可以上传自定义图床的插件 1picgo install web-uploader 2.2 配置关于存储区域的填写跟在七牛云上新建空间的地理位置有关； 具体参考：存储区域_产品简介_对象存储 - 七牛开发者中心 (qiniu.com) 2.2.1 图形版直接图形界面配置参考配置 2.2.2 图形版直接图形界面配置参考配置文件 123456789101112131415161718&#123; &quot;picBed&quot;: &#123; &quot;uploader&quot;: &quot;qi_niu&quot;, &quot;current&quot;: &quot;qi_niu&quot;, &quot;qi_niu&quot;: &#123; &quot;accessKey&quot;: &quot;you-access-key&quot;, &quot;secretKey&quot;: &quot;you-secret-key&quot;, &quot;bucket&quot;: &quot;blog-pic-resp&quot;, &quot;url&quot;: &quot;http://you-url&quot;, &quot;area&quot;: &quot;z1&quot;, &quot;options&quot;: &quot;&quot;, &quot;path&quot;: &quot;&quot; &#125; &#125;, &quot;picgoPlugins&quot;: &#123; &quot;picgo-plugin-web-uploader&quot;: true &#125;&#125; 3. Typora 图片存储设置设置入口：设置 - 偏好设置 - 图像； 如下图所示： 插入图片时：选择：上传图片； 上传服务设定 上传服务：选择：PicGo（app） PicGo 路径：选择：自己安装时候的路径 当上述两大项设置完毕后，点击：“验证图片上传选项” 设置成功后，会出现“验证成功”的提示，如下图： 如果你的主题设置是 Onedark 一类的黑色主题，这个提示可能会不明显，需要仔细查看才能看到；","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://buctllx.github.io/categories/Markdown/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://buctllx.github.io/tags/PicGo/"},{"name":"Typora","slug":"Typora","permalink":"https://buctllx.github.io/tags/Typora/"}]},{"title":"Git fetch 同时更新子模块","slug":"Git-fetch-同时更新子模块","date":"2021-12-02T10:25:13.000Z","updated":"2021-12-22T03:34:02.662Z","comments":true,"path":"2021/12/02/Git-fetch-同时更新子模块/","link":"","permalink":"https://buctllx.github.io/2021/12/02/Git-fetch-%E5%90%8C%E6%97%B6%E6%9B%B4%E6%96%B0%E5%AD%90%E6%A8%A1%E5%9D%97/","excerpt":"1. 问题描述默认情况，git checkout; git fetch 如果子模块 submodule 的版本不一致， git 是不会自动更新子模块；","text":"1. 问题描述默认情况，git checkout; git fetch 如果子模块 submodule 的版本不一致， git 是不会自动更新子模块； 2. 传统解决方法：cd submodules 文件夹； git checkout / fetch； 3. 高级解决方法：在全局进行 Git 设置： 1 git config –global submodule.recurse true 设置 submodule.recurse true 后，不仅仅 git checkout 会自动切换子模块，git fetch / pull 也会自动拉取子模块的更新 注意：这个设置对用户机器上安装的 git 版本有要求，详见下面说明 在发行说明中提到了这一点：https://github.com/git/git/commit/e1104a5ee539408b81566066aaa6963cb87d5cd6#diff-c24776ff22455a30fbb78e378b7df0b0R139 submodule.recurse 选项已添加到 git 2.14","categories":[{"name":"Git 相关","slug":"Git-相关","permalink":"https://buctllx.github.io/categories/Git-%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://buctllx.github.io/tags/Git/"}]},{"title":"WPF 在 Trigger 中修改 Button Content 注意事项","slug":"WPF-在-Trigger-中修改-Button-Content-注意事项","date":"2021-12-02T08:52:58.000Z","updated":"2021-12-22T03:34:31.422Z","comments":true,"path":"2021/12/02/WPF-在-Trigger-中修改-Button-Content-注意事项/","link":"","permalink":"https://buctllx.github.io/2021/12/02/WPF-%E5%9C%A8-Trigger-%E4%B8%AD%E4%BF%AE%E6%94%B9-Button-Content-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"1. 问题描述xaml 代码块如下： 12345678910111213&lt;Button Content=&quot;333&quot;&gt; &lt;Button.Style&gt; &lt;Style TargetType=&quot;Button&quot;&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;70&quot;/&gt; &lt;Setter Property=&quot;Height&quot; Value=&quot;27&quot;/&gt; &lt;Style.Triggers&gt; &lt;DataTrigger Binding=&quot;&#123;Binding ElementName=listBox, Path=SelectedIndex&#125;&quot; Value=&quot;2&quot;&gt; &lt;Setter Property=&quot;Content&quot; Value=&quot;three&quot; /&gt; &lt;/DataTrigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/Button.Style&gt; &lt;/Button&gt; 运行后，触发 DataTrigger 发现 Button 的 Content 没有变化","text":"1. 问题描述xaml 代码块如下： 12345678910111213&lt;Button Content=&quot;333&quot;&gt; &lt;Button.Style&gt; &lt;Style TargetType=&quot;Button&quot;&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;70&quot;/&gt; &lt;Setter Property=&quot;Height&quot; Value=&quot;27&quot;/&gt; &lt;Style.Triggers&gt; &lt;DataTrigger Binding=&quot;&#123;Binding ElementName=listBox, Path=SelectedIndex&#125;&quot; Value=&quot;2&quot;&gt; &lt;Setter Property=&quot;Content&quot; Value=&quot;three&quot; /&gt; &lt;/DataTrigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/Button.Style&gt; &lt;/Button&gt; 运行后，触发 DataTrigger 发现 Button 的 Content 没有变化 2. 原因和解决方法原因：定义 Button 的时候直接指定 Content 相当于定死了 Button 的 Content ，所以在 Style 的 Trigger 中就无法修改了； 注意： 这个时候如果指定有默认的 Button Style，默认样式也会失效；原因是重写了 Style； 解决方案：将 Content 的默认值，写进 Button.Style，如下所示： 1234567891011121314&lt;Button&gt; &lt;Button.Style&gt; &lt;Style TargetType=&quot;Button&quot;&gt; &lt;Setter Property=&quot;Content&quot; Value=&quot;333&quot;/&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;70&quot;/&gt; &lt;Setter Property=&quot;Height&quot; Value=&quot;27&quot;/&gt; &lt;Style.Triggers&gt; &lt;DataTrigger Binding=&quot;&#123;Binding ElementName=listBox, Path=SelectedIndex&#125;&quot; Value=&quot;2&quot;&gt; &lt;Setter Property=&quot;Content&quot; Value=&quot;three&quot; /&gt; &lt;/DataTrigger&gt; &lt;/Style.Triggers&gt; &lt;/Style&gt; &lt;/Button.Style&gt; &lt;/Button&gt;","categories":[{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/categories/WPF/"}],"tags":[{"name":".Net","slug":"Net","permalink":"https://buctllx.github.io/tags/Net/"},{"name":"C#","slug":"C","permalink":"https://buctllx.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/tags/WPF/"},{"name":"Style","slug":"Style","permalink":"https://buctllx.github.io/tags/Style/"}]},{"title":"wpf control window 范围内默认样式对第一个控件无效","slug":"wpf-control-window-范围内默认样式对第一个控件无效","date":"2021-12-02T07:12:32.000Z","updated":"2021-12-22T03:42:14.493Z","comments":true,"path":"2021/12/02/wpf-control-window-范围内默认样式对第一个控件无效/","link":"","permalink":"https://buctllx.github.io/2021/12/02/wpf-control-window-%E8%8C%83%E5%9B%B4%E5%86%85%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%E5%AF%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%8E%A7%E4%BB%B6%E6%97%A0%E6%95%88/","excerpt":"1、问题描述wpf 页面设计中，有时候在 xaml 文件 Resource 中指定 window 范围的默认 control style，但是却发现对第一个控件不起作用，具体如下：","text":"1、问题描述wpf 页面设计中，有时候在 xaml 文件 Resource 中指定 window 范围的默认 control style，但是却发现对第一个控件不起作用，具体如下： 1234567891011121314151617181920212223242526&lt;Window x:Class=&quot;TestApp.TestWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;TestWindow&quot; Height=&quot;400&quot; Width=&quot;500&quot; WindowStyle=&quot;None&quot; WindowState=&quot;Maximized&quot;&gt; &lt;Window.Resources&gt; &lt;ResourceDictionary&gt; &lt;ResourceDictionary.MergedDictionaries&gt; &lt;ResourceDictionary Source=&quot;Resources/AllResources.xaml&quot;/&gt; &lt;ResourceDictionary&gt; &lt;Style TargetType=&quot;&#123;x:Type Button&#125;&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;100&quot;/&gt; &lt;/Style&gt; &lt;/ResourceDictionary&gt; &lt;/ResourceDictionary.MergedDictionaries&gt; &lt;/ResourceDictionary&gt; &lt;/Window.Resources&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Column=&quot;0&quot; Content=&quot;1&quot; Name=&quot;Button1&quot;/&gt; &lt;Button Grid.Column=&quot;1&quot; Content=&quot;2&quot; Name=&quot;Button2&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; button1 的 FontSize 并不是 100；但是 button2 却没问题； 通常我们使用下面的代码是没问题的； 12345678910111213141516171819&lt;Window x:Class=&quot;TestApp.TestWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Title=&quot;TestWindow&quot; Height=&quot;400&quot; Width=&quot;500&quot; WindowStyle=&quot;None&quot; WindowState=&quot;Maximized&quot;&gt; &lt;Window.Resources&gt; &lt;Style TargetType=&quot;&#123;x:Type Button&#125;&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;100&quot;/&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Column=&quot;0&quot; Content=&quot;1&quot; Name=&quot;Button1&quot;/&gt; &lt;Button Grid.Column=&quot;1&quot; Content=&quot;2&quot; Name=&quot;Button2&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; 2、原因和解决方法2.1 原因因为把 Button 默认样式放在了 ResourceDictionary.MergedDictionaries 内部的ResourceDictionary 内了，这样在解析引用样式的时候会跳过第一个元素； 2.2 解决方案将 style 提到 ResourceDictionary.MergedDictionaries 之外 123456789101112131415161718&lt;Window.Resources&gt; &lt;ResourceDictionary&gt; &lt;ResourceDictionary.MergedDictionaries&gt; &lt;ResourceDictionary Source=&quot;Resources/AllResources.xaml&quot;/&gt; &lt;/ResourceDictionary.MergedDictionaries&gt; &lt;Style TargetType=&quot;&#123;x:Type Button&#125;&quot;&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;100&quot;/&gt; &lt;/Style&gt; &lt;/ResourceDictionary&gt;&lt;/Window.Resources&gt;&lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Grid.Column=&quot;0&quot; Content=&quot;1&quot; Name=&quot;Button1&quot;/&gt; &lt;Button Grid.Column=&quot;1&quot; Content=&quot;2&quot; Name=&quot;Button2&quot;/&gt;&lt;/Grid&gt; 参考链接：resources - WPF doesn’t apply style to first element - Stack Overflow","categories":[{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/categories/WPF/"}],"tags":[{"name":".Net","slug":"Net","permalink":"https://buctllx.github.io/tags/Net/"},{"name":"C#","slug":"C","permalink":"https://buctllx.github.io/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/tags/WPF/"},{"name":"Style","slug":"Style","permalink":"https://buctllx.github.io/tags/Style/"}]},{"title":"Fist Blog","slug":"test-my-site","date":"2020-04-12T15:31:00.000Z","updated":"2022-03-17T01:46:37.447Z","comments":true,"path":"2020/04/12/test-my-site/","link":"","permalink":"https://buctllx.github.io/2020/04/12/test-my-site/","excerpt":"","text":"Welcome to Hexo!This is your very first post. Check documentation for more info.If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"}]},{"title":"Hello Hexo","slug":"hello-world","date":"2020-04-12T10:25:00.000Z","updated":"2022-03-16T10:34:54.800Z","comments":true,"path":"2020/04/12/hello-world/","link":"","permalink":"https://buctllx.github.io/2020/04/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"}]}],"categories":[{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Nginx","slug":"工具/Nginx","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/Nginx/"},{"name":"MVVM","slug":"工具/MVVM","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/MVVM/"},{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/categories/WPF/"},{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/categories/VisualStudio/"},{"name":"VisualStudio","slug":"工具/VisualStudio","permalink":"https://buctllx.github.io/categories/%E5%B7%A5%E5%85%B7/VisualStudio/"},{"name":"windwos","slug":"windwos","permalink":"https://buctllx.github.io/categories/windwos/"},{"name":"web site","slug":"windwos/web-site","permalink":"https://buctllx.github.io/categories/windwos/web-site/"},{"name":"ftp server","slug":"windwos/ftp-server","permalink":"https://buctllx.github.io/categories/windwos/ftp-server/"},{"name":"Revit","slug":"Revit","permalink":"https://buctllx.github.io/categories/Revit/"},{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/categories/Hexo/"},{"name":"PicGo","slug":"Hexo/PicGo","permalink":"https://buctllx.github.io/categories/Hexo/PicGo/"},{"name":"Termianl","slug":"Termianl","permalink":"https://buctllx.github.io/categories/Termianl/"},{"name":"PowerShell","slug":"Termianl/PowerShell","permalink":"https://buctllx.github.io/categories/Termianl/PowerShell/"},{"name":"Hexo Theme","slug":"Hexo/Hexo-Theme","permalink":"https://buctllx.github.io/categories/Hexo/Hexo-Theme/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://buctllx.github.io/categories/ElasticSearch/"},{"name":"Markdown","slug":"Markdown","permalink":"https://buctllx.github.io/categories/Markdown/"},{"name":"Git 相关","slug":"Git-相关","permalink":"https://buctllx.github.io/categories/Git-%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://buctllx.github.io/tags/Nginx/"},{"name":"FileBrowsern","slug":"FileBrowsern","permalink":"https://buctllx.github.io/tags/FileBrowsern/"},{"name":"MVVM","slug":"MVVM","permalink":"https://buctllx.github.io/tags/MVVM/"},{"name":"WPF","slug":"WPF","permalink":"https://buctllx.github.io/tags/WPF/"},{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://buctllx.github.io/tags/VisualStudio/"},{"name":"工具","slug":"工具","permalink":"https://buctllx.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"windwos","slug":"windwos","permalink":"https://buctllx.github.io/tags/windwos/"},{"name":"web site","slug":"web-site","permalink":"https://buctllx.github.io/tags/web-site/"},{"name":"ftp","slug":"ftp","permalink":"https://buctllx.github.io/tags/ftp/"},{"name":"Revit","slug":"Revit","permalink":"https://buctllx.github.io/tags/Revit/"},{"name":"Hexo","slug":"Hexo","permalink":"https://buctllx.github.io/tags/Hexo/"},{"name":"PicGo","slug":"PicGo","permalink":"https://buctllx.github.io/tags/PicGo/"},{"name":"Termianl,PowerShell,Oh-My-Posh","slug":"Termianl-PowerShell-Oh-My-Posh","permalink":"https://buctllx.github.io/tags/Termianl-PowerShell-Oh-My-Posh/"},{"name":"Theme","slug":"Theme","permalink":"https://buctllx.github.io/tags/Theme/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://buctllx.github.io/tags/ElasticSearch/"},{"name":"ES","slug":"ES","permalink":"https://buctllx.github.io/tags/ES/"},{"name":"Typora","slug":"Typora","permalink":"https://buctllx.github.io/tags/Typora/"},{"name":"Git","slug":"Git","permalink":"https://buctllx.github.io/tags/Git/"},{"name":".Net","slug":"Net","permalink":"https://buctllx.github.io/tags/Net/"},{"name":"C#","slug":"C","permalink":"https://buctllx.github.io/tags/C/"},{"name":"Style","slug":"Style","permalink":"https://buctllx.github.io/tags/Style/"}]}